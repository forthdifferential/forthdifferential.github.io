<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux - Linux网络编程 | 个人主页</title><meta name="author" content="陈锴烺"><meta name="copyright" content="陈锴烺"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux服务器 网络编程 1. Linux系统编程入门GCCgcc和g++都是GCC组织的编译器 ，套件和库；一般用gcc和g++两个编译器  gcc不能自动和cpp程序库链接，一般编译和链接都用g++，因为g++会调用gcc  gcc编译c文件 gcc test.c -o app 然后.&#x2F;app其中-o 指明输出文件名  预处理 编译 汇编 链接   -c 只是汇编不链接,生成目标文">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux - Linux网络编程">
<meta property="og:url" content="https://forthdifferential.github.io/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="个人主页">
<meta property="og:description" content="Linux服务器 网络编程 1. Linux系统编程入门GCCgcc和g++都是GCC组织的编译器 ，套件和库；一般用gcc和g++两个编译器  gcc不能自动和cpp程序库链接，一般编译和链接都用g++，因为g++会调用gcc  gcc编译c文件 gcc test.c -o app 然后.&#x2F;app其中-o 指明输出文件名  预处理 编译 汇编 链接   -c 只是汇编不链接,生成目标文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://forthdifferential.github.io/imgs/$%7Bfiilename%7D/wangluobiancheng.png">
<meta property="article:published_time" content="2023-11-14T07:12:13.923Z">
<meta property="article:modified_time" content="2023-11-18T08:42:18.558Z">
<meta property="article:author" content="陈锴烺">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://forthdifferential.github.io/imgs/$%7Bfiilename%7D/wangluobiancheng.png"><link rel="shortcut icon" href="/imgs/head.ico"><link rel="canonical" href="https://forthdifferential.github.io/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux - Linux网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-18 16:42:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="个人主页"><span class="site-name">个人主页</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux - Linux网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-14T07:12:13.923Z" title="发表于 2023-11-14 15:12:13">2023-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-18T08:42:18.558Z" title="更新于 2023-11-18 16:42:18">2023-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">57.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>222分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux - Linux网络编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>Linux服务器 网络编程</p>
<h2 id="1-Linux系统编程入门"><a href="#1-Linux系统编程入门" class="headerlink" title="1. Linux系统编程入门"></a>1. Linux系统编程入门</h2><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>gcc和g++都是GCC组织的编译器 ，套件和库；一般用gcc和g++两个编译器</p>
<ul>
<li><p>gcc不能自动和cpp程序库链接，一般编译和链接都用g++，因为g++会调用gcc</p>
</li>
<li><p>gcc编译c文件 gcc test.c -o app 然后.&#x2F;app<br>其中-o 指明输出文件名</p>
</li>
<li><p>预处理 编译 汇编 链接 </p>
</li>
<li><p>-c 只是汇编不链接,生成目标文件“.o”  test.o</p>
<p>-S 只是编译不汇编,生成汇编代码  test.s</p>
<p>-E 只进行预编译,不做其他处理    test.i</p>
<p><strong>后置</strong> ：</p>
</li>
<li><p>-D 指定宏 配合#ifdef DEBUG #endif<br>g++ test.cpp -o test -DDEBUG <em>指定宏DEGUB</em></p>
</li>
<li><p>-I 指定include包含文件搜索目录</p>
</li>
<li><p>-L 指定编译时 库 的路径</p>
</li>
<li><p>-l 指定编译时 使用的 库</p>
</li>
</ul>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul>
<li><p>代码仓库，保存一些变量、函数、类等；编写差不多，但不能单独运行；</p>
</li>
<li><p>静态库在程序的链接阶段被复制到程序中；动态库在程序运行时，加载到内存中供程序调用</p>
</li>
<li><p>好处：1. 代码保密（cpp反汇编还原度低）；2. 方便部署和分发</p>
</li>
<li><p><strong>工作原理</strong>：静态库GCC链接时，把静态库代码打包到可执行程序中；<br>动态度GCC链接时，动态库代码<strong>不会</strong>被打包到可执行程序中，运行时加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系；系统加载可执行代码时，需要知道库的名字和绝对路径，一般用<strong>动态载入器获取绝对路径，然后找到库文件载入内存中</strong><br><strong>优缺点比较</strong>：</p>
<ul>
<li>静态库被打包到应用程序 ；加载速度快；<br>但消耗资源，浪费内存； 更新速度慢；</li>
<li>动态库 可以进程资源共享（共享库）；更新部署简单；控制加载时间；<br>但加载速度慢；发布程序需要提供依赖的动态库；</li>
<li>库比较小用静态 大用动态</li>
</ul>
</li>
</ul>
<h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><ul>
<li><p>命名规则 Linux:    libxxx.a<br>Win :     libxxx.lib</p>
</li>
<li><p>制作静态库</p>
<ol>
<li><p>gcc获得.o文件 - c</p>
</li>
<li><p>将 .o文件打包，使用ar工具 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a  xxx.o xxx.o</span><br></pre></td></tr></table></figure>

<p>静态库移动到lib目录下</p>
</li>
<li><p>编译main程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -I ./include/ -L ./lib/ -l xxx</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><ul>
<li><p>命名规则 Linux:   libxxx.so 在Linux下是一个可执行文件<br>Win :    libxxx.dll</p>
</li>
<li><p>制作动态库</p>
<ol>
<li><p>gcc得到.o文件，得到与位置无关的代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC a.c b.c</span><br></pre></td></tr></table></figure>

<p>-fpic 用于编译阶段，产生的代码没有绝对地址，全部用相对地址，这正好满足了共享库的要求，共享库被加载时地址不是固定的。如果不加-fpic ，那么生成的代码就会与位置有关，当进程使用该.so文件时都需要重定位，且会产生成该文件的副本，每个副本都不同，不同点取决于该文件代码段与数据段所映射内存的位置</p>
</li>
<li><p>gcc得到动态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译mian程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app2 -I ./include/ -L ./lib/ -l calc</span><br></pre></td></tr></table></figure>



<p>运行时加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系；系统加载可执行代码时，需要知道库的名字和绝对路径，一般用<strong>动态载入器获取绝对路径，然后找到库文件载入内存中</strong></p>
<ol>
<li><p>窗口级别 直接export配置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klchen@vmware:~/WinToUbuntu/lession06/library$ export LD_LIBRARY_PATH=$LD_LIBRAY_PATH:/home/klchen/WinToUbuntu/lession06/library/lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户级别 在用户中配置.bashrc环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRAY_PATH:/home/klchen/WinToUbuntu/lession06/library/lib</span><br><span class="line"></span><br><span class="line">. .bashrc或者source .bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统级别 在etc&#x2F;profile中export</p>
</li>
</ol>
<ul>
<li>还有&#x2F;etc&#x2F;ld.so.cache文件列表添加的方式</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。</p>
<p>◼Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<ul>
<li>make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，VisualC++的nmake，Linux下GNU的make。</li>
</ul>
<h4 id="makefile文件书写规则"><a href="#makefile文件书写规则" class="headerlink" title="makefile文件书写规则"></a>makefile文件书写规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span> </span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> <span class="comment">#clean操作在make不会被执行，需要手动make clean</span></span><br><span class="line"> <span class="comment">#表示clean是一个为目标，不会生成文件</span></span><br><span class="line"> .PHONY:clean</span><br><span class="line"> clean:</span><br><span class="line"> 		rm <span class="variable">$(objs)</span> -f</span><br></pre></td></tr></table></figure>

<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>​	调试工具，是许多类Unix系统中的标准开发环境</p>
<ul>
<li><p>主要功能：断点调试，监控，改BUG</p>
</li>
<li><p>准备工作 在生成可执行文件时添加</p>
<ol>
<li>-O关掉优化选项</li>
<li>-g打开调试选项：可执行文件中加入源代码信息，第几条机器指令对应源代码几行</li>
<li>-Wall打开所有warning</li>
</ol>
</li>
<li><p>gdb基本操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应该要保证可执行文件和源文件都在</span></span><br><span class="line">gdb 目标程序</span><br></pre></td></tr></table></figure>

</li>
<li><p>断点操作</p>
<p><strong>退出gdb后断点全部失效</strong></p>
</li>
<li><p>调试命令 </p>
<p>bt打印堆栈</p>
</li>
</ul>
<h3 id="Linux系统的IO函数"><a href="#Linux系统的IO函数" class="headerlink" title="Linux系统的IO函数"></a>Linux系统的IO函数</h3><p> 标准C库IO函数带有缓冲区，有FILE*fp文件指针，减少写磁盘次数；但是Linux系统自带的IO没有缓冲区</p>
<ul>
<li><p>在网络通信时候用linux系统自带的IO；</p>
</li>
<li><p>在磁盘读写用标准C库IO；</p>
</li>
<li><p>FILE类型 文件描述符</p>
</li>
<li><p>库函数说明查找</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Linux库函数</span></span><br><span class="line">man 2 xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标准C库</span></span><br><span class="line">man 3 xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h5><ul>
<li><p>用man操作打开函数的说明文档，可以查找头文件，看IO</p>
<p>man 1是普通的shell命令比如ls，<br> man 2是系统调用比如open，write说明，<br>    man 3是函数说明，一些库函数</p>
</li>
</ul>
<h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>​       int open(const char *pathname, int flags);的说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">打开文件操作</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 打开一个已经存在的文件</span><br><span class="line">   <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line">       参数：</span><br><span class="line"></span><br><span class="line">      - pathname：要打开的文件路径</span><br><span class="line">        - flags：对文件的操作权限设置还有其他的设置</span><br><span class="line">              - flO_RDONLY,  O_WRONLY,  O_RDWR  这三个设置是互斥的</span><br><span class="line">      - 返回值：返回一个新的文件描述符，如果调用失败，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;作用：打印errno对应的错误描述</span><br><span class="line">       s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span><br><span class="line">       创建一个新的文件</span><br><span class="line">   <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="comment">/*man 1是普通的shell命令比如ls，</span></span><br><span class="line"><span class="comment">    man 2是系统调用比如open，write说明，</span></span><br><span class="line"><span class="comment">    man 3是函数说明，一些库函数。        </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;的说明参数：</span><br><span class="line">    - pathname：要创建的文件的路径</span><br><span class="line">    - flags：对文件的操作权限和其他的设置</span><br><span class="line">        - 必选项：O_RDONLY,  O_WRONLY, O_RDWR  这三个之间是互斥的，就是权限的设置只读、只写、读写</span><br><span class="line">        - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">    - mode：八进制的数，表示创建出的新的文件的操作权限，比如：<span class="number">0775</span></span><br><span class="line">    最终的权限是：mode &amp; ~umask</span><br><span class="line">    <span class="number">0777</span>   -&gt;   <span class="number">111111111</span></span><br><span class="line">&amp;   <span class="number">0775</span>   -&gt;   <span class="number">111111101</span></span><br><span class="line">----------------------------</span><br><span class="line">                <span class="number">111111101</span></span><br><span class="line">按位与：<span class="number">0</span>和任何数都为<span class="number">0</span></span><br><span class="line">umask的作用就是抹去某些权限，也可以自己</span><br><span class="line"></span><br><span class="line">flags参数是一个<span class="type">int</span>类型的数据，占<span class="number">4</span>个字节，<span class="number">32</span>位。</span><br><span class="line">flags <span class="number">32</span>个位，每一位就是一个标志位。</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>,O_RDONLY|O_CREAT,<span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="line">        - buf：需要读取数据存放的地方，数组的地址（传出参数）</span><br><span class="line">        - count：指定的数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：</span><br><span class="line">            &gt;<span class="number">0</span>: 返回实际的读取到的字节数</span><br><span class="line">            =<span class="number">0</span>：文件已经读取完了</span><br><span class="line">        - 失败：<span class="number">-1</span> ，并且设置errno</span><br></pre></td></tr></table></figure>

<h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="line">        - buf：要往磁盘写入的数据，数据</span><br><span class="line">        - count：要写的数据的实际的大小</span><br><span class="line">          write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    返回值：</span><br><span class="line">        成功：实际写入的字节数</span><br><span class="line">        失败：返回<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure>

<p>例子：读写复制文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//open打开资源文件</span></span><br><span class="line">    <span class="type">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建拷贝文件</span></span><br><span class="line">    <span class="type">int</span> destfd = open(<span class="string">&quot;copy.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(destfd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//频繁的读写操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        write(destfd,buf,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(srcfd);</span><br><span class="line">    close(destfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lseek移动文件指针偏移"><a href="#lseek移动文件指针偏移" class="headerlink" title="lseek移动文件指针偏移"></a>lseek移动文件指针偏移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    标准C库的函数</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    Linux系统函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span><br><span class="line">        - offset：偏移量</span><br><span class="line">        - whence:</span><br><span class="line">            SEEK_SET</span><br><span class="line">                设置文件指针的偏移量</span><br><span class="line">            SEEK_CUR</span><br><span class="line">                设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line">            SEEK_END</span><br><span class="line">                设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">    返回值：返回文件指针的位置</span><br><span class="line">    作用：</span><br><span class="line">    <span class="number">1.</span>移动文件指针到文件头</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>获取当前文件指针的位置</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span>获取文件长度</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span>拓展文件的长度，当前文件<span class="number">10b</span>, <span class="number">110b</span>, 增加了<span class="number">100</span>个字节</span><br><span class="line">    lseek(fd, <span class="number">100</span>, SEEK_END)</span><br><span class="line">    注意：需要写一次数据</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><ul>
<li>终端操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat xxx</span><br></pre></td></tr></table></figure>

<h5 id="stat函数-lstat函数获取文件信息"><a href="#stat函数-lstat函数获取文件信息" class="headerlink" title="stat函数 lstat函数获取文件信息"></a>stat函数 lstat函数获取文件信息</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：操作的文件的路径</span><br><span class="line">        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;获取软链接的文件信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：操作的文件的路径</span><br><span class="line">        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure>


<p>例子：用stat实现ls -l</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟ls-l指令</span></span><br><span class="line"><span class="comment">//-rw-rw-r-- 1 klchen klchen 0 2月  18 14:01 a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过stat函数获取用户传入文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret=stat(argv[<span class="number">1</span>],&amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件类型和文件权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (st.st_mode &amp; __S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> __S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> __S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> __S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断文件访问权限</span></span><br><span class="line">    perms[<span class="number">1</span>]= st.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>]= st.st_mode &amp; S_IWUSR ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>]= st.st_mode &amp; S_IXUSR ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    perms[<span class="number">4</span>]= st.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>]= st.st_mode &amp; S_IWGRP ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>]= st.st_mode &amp; S_IXGRP ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    perms[<span class="number">7</span>]= st.st_mode &amp; S_IROTH ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>]= st.st_mode &amp; S_IWOTH ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>]= st.st_mode &amp; S_IXOTH ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬链接数</span></span><br><span class="line">    <span class="type">int</span> linkNum =st.st_nlink;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所有者</span></span><br><span class="line">    <span class="type">char</span> *fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所在组</span></span><br><span class="line">    <span class="type">char</span> *fileGrp=getgrgid(st.st_uid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> fileSize =st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取修改时间</span></span><br><span class="line">    <span class="type">char</span> *time = ctime(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime,time,<span class="built_in">strlen</span>(time) <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>,perms,linkNum,fileUser,fileGrp,fileSize,mtime,argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h4><h5 id="access判断文件权限或文件是否存在"><a href="#access判断文件权限或文件是否存在" class="headerlink" title="access判断文件权限或文件是否存在"></a>access判断文件权限或文件是否存在</h5><pre><code>#include &lt;unistd.h&gt;
int access(const char *pathname, int mode);
    作用：判断某个文件是否有某个权限，或者判断文件是否存在
    参数：
        - pathname: 判断的文件路径
        - mode:
            R_OK: 判断是否有读权限
            W_OK: 判断是否有写权限
            X_OK: 判断是否有执行权限
            F_OK: 判断文件是否存在
    返回值：成功返回0， 失败返回-1
</code></pre>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在！！!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="chmod函数修改文件权限"><a href="#chmod函数修改文件权限" class="headerlink" title="chmod函数修改文件权限"></a>chmod函数修改文件权限</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="truncate修改文件尺寸"><a href="#truncate修改文件尺寸" class="headerlink" title="truncate修改文件尺寸"></a>truncate修改文件尺寸</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h4><h5 id="mkdir函数创建目录"><a href="#mkdir函数创建目录" class="headerlink" title="mkdir函数创建目录"></a>mkdir函数创建目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="chdir修改进程工作目录"><a href="#chdir修改进程工作目录" class="headerlink" title="chdir修改进程工作目录"></a>chdir修改进程工作目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br></pre></td></tr></table></figure>

<h5 id="getcwd获取当前目录"><a href="#getcwd获取当前目录" class="headerlink" title="getcwd获取当前目录"></a>getcwd获取当前目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h4><h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h5 id="readdir"><a href="#readdir" class="headerlink" title="readdir()"></a>readdir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class">//返回值 <span class="title">dirent</span>结构体的具体 元素 如图</span></span><br></pre></td></tr></table></figure>


<h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir()"></a>closedir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;<span class="comment">//此处 参数 关闭的是文件描述符</span></span><br></pre></td></tr></table></figure>

<h6 id="应用-统计某个目录下文件数量"><a href="#应用-统计某个目录下文件数量" class="headerlink" title="应用-统计某个目录下文件数量"></a>应用-统计某个目录下文件数量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFilenum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取某目录下所有文件个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否输入了文件名</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=getFilenum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平台文件的个数是 %d\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFilenum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>&#123;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    DIR *dir=opendir(path);</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="comment">//记录普通文件数</span></span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((ptr=readdir(dir))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略掉. 和..</span></span><br><span class="line">        <span class="type">char</span>* dname=ptr-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dname,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是目录递归</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            <span class="comment">//目录，需要继续读取目录</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="comment">//生成地址名称，字符串合并函数</span></span><br><span class="line">            <span class="built_in">sprintf</span>(newpath,<span class="string">&quot;%s/%s&quot;</span>,path,dname);</span><br><span class="line">            total+=getFilenum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">            <span class="comment">//普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件描述符操作函数"><a href="#文件描述符操作函数" class="headerlink" title="文件描述符操作函数"></a>文件描述符操作函数</h4><p>一个进程中有一个文件描述符表</p>
<h5 id="dup-文件描述符-复制-浅拷贝"><a href="#dup-文件描述符-复制-浅拷贝" class="headerlink" title="dup()文件描述符 复制 - 浅拷贝"></a>dup()文件描述符 复制 - 浅拷贝</h5><pre><code>#include &lt;unistd.h&gt;
int dup(int oldfd);
    作用：复制一个新的文件描述符
    fd=3, int fd1 = dup(fd),
    fd指向的是a.txt, fd1也是指向a.txt
    从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符
</code></pre>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dup2-文件描述符-重定向"><a href="#dup2-文件描述符-重定向" class="headerlink" title="dup2()文件描述符 重定向"></a>dup2()文件描述符 重定向</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">    作用：重定向文件描述符,让newfd也来指向oldfd</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fcntl-函数-控制文件描述符"><a href="#fcntl-函数-控制文件描述符" class="headerlink" title="fcntl()函数 控制文件描述符"></a>fcntl()函数 控制文件描述符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。<span class="comment">//这个flag都可以|上O_NONBLOCK</span></span><br><span class="line">            <span class="comment">//设置fd非阻塞的方法，一般是fcntl+F_GETFL得到flag，|上O_NONBLOCK，然后fcntl+F_SETFL设置falg</span></span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改！！！！！</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            NONBLOK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。 导致当前进程线程被挂起-阻塞</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="comment">// 首先要获取文件描述符状态flag</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改完flag后替换进去</span></span><br><span class="line">    flag |= O_APPEND;   <span class="comment">// flag = flag | O_APPEND 此处用按位或来追加flag状态</span></span><br><span class="line">    <span class="type">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Linux多进程编程"><a href="#2-Linux多进程编程" class="headerlink" title="2. Linux多进程编程"></a>2. Linux多进程编程</h2><h3 id="2-1进程状态转换-终端指令"><a href="#2-1进程状态转换-终端指令" class="headerlink" title="2.1进程状态转换  -终端指令"></a>2.1进程状态转换  -终端指令</h3><ul>
<li><p>Linux中PBC的结构体task_struct</p>
</li>
<li><p>进程参数查看 ulimit -a </p>
</li>
<li><p>查看进程<br>ps aux &#x2F; ajx<br>a：显示终端上的所有进程，包括其他用户的进程<br>u：显示进程的详细信息<br>x：显示没有控制终端的进程<br>j：列出与作业控制相关的信息</p>
</li>
<li><p>STAT参数意义：<br>D 不可中断 Uninterruptible（usually IO）<br>R 正在运行，或在队列中的进程<br>S(大写) 处于休眠状态<br>T 停止或被追踪<br>Z 僵尸进程<br>W 进入内存交换（从内核2.6开始无效）<br>X 死掉的进程<br>&lt; 高优先级<br>N 低优先级<br>s 包含子进程</p>
<p>+ 位于前台的进程组</p>
</li>
<li><p>然后，实时显示进程动态<br>top<br>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令<br>执行后，可以按以下按键对显示的结果进行排序：<br>⚫ M 根据内存使用量排序<br>⚫ P 根据 CPU 占有率排序<br>⚫ T 根据进程运行时间长短排序<br>⚫ U 根据用户名来筛选进程<br>⚫ K 输入指定的 PID 杀死进程</p>
</li>
<li><p>杀死进程<br>kill [-signal] pid<br>kill –l 列出所有信号<br>kill –SIGKILL 进程ID<br>kill -9 进程ID<br>killall name 根据进程名杀死进程</p>
</li>
<li><p>进程号和进程组相关函数：<br>⚫ pid_t getpid(void);<br>⚫ pid_t getppid(void);  &#x2F;&#x2F;父进程的pid<br>⚫ pid_t getpgid(pid_t pid);</p>
</li>
</ul>
<h3 id="2-2进程创建"><a href="#2-2进程创建" class="headerlink" title="2.2进程创建"></a>2.2进程创建</h3><h5 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h5><ul>
<li><p>创建子进程</p>
<p>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);<br>函数的作用：用于创建子进程。<br>返回值：<br>    fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。<br>    在父进程中返回创建的子进程的ID,<br>    在子进程中返回0<br>    如何区分父进程和子进程：通过fork的返回值。<br>    在父进程中返回-1，表示创建子进程失败，并且设置errno<br><br>父子进程之间的关系：<br>区别：<br>    1.fork()函数的返回值不同<br>        父进程中: &gt;0 返回的子进程的ID<br>        子进程中: &#x3D;0<br>    2.pcb中的一些数据<br>        当前的进程的id pid<br>        当前的进程的父进程的id ppid<br>        信号集<br><br>共同点：<br>    某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作<br>        - 用户区的数据<br>        - 文件描述符表<br><br>父子进程对变量是不是共享的？<br>    - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。<br>    - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。<br> 实际上，更准确来说，Linux 的 fork() 使用是通过<strong>写时拷贝 (copy- on-write)</strong> 实现。<br>写时拷贝是一种可以推迟甚至避免拷贝数据的技术。<br>内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。<br>只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。<br>也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。<br>注意：fork之后父子进程共享文件，<br>fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p>
</li>
<li><p>查看例子</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    <span class="comment">//判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">//如果大于0，返回的创建的是子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process,pid:%d,ppid:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num:%d\n&quot;</span>,num);</span><br><span class="line">        num+=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num +=10:%d\n&quot;</span>,num);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process,pid:%d,ppid:%d&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num:%d\n&quot;</span>,num);</span><br><span class="line">        num+=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num +=10:%d\n&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i:%d,pid:%d\n&quot;</span>,i,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>父进程和子进程执行的代码块分别是以下图：</li>
<li><ol>
<li>子进程只执行以下的自己进程部分</li>
</ol>
</li>
<li><ol start="2">
<li>父子进程代码段一样，但是按照pid来运行；</li>
</ol>
</li>
<li><ol start="3">
<li>写操作之后，进程资源之间互不影响，共同部分运行的是各自的资源</li>
</ol>
</li>
</ul>
<h5 id="gdb调试父子进程"><a href="#gdb调试父子进程" class="headerlink" title="gdb调试父子进程"></a>gdb调试父子进程</h5><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
<ul>
<li>设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child]</li>
<li>设置调试模式：set detach-on-fork [on | off]<br>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。</li>
<li>查看调试的进程：info inferiors<br>切换当前调试的进程为id进程：inferior id<br>使进程脱离 GDB 调试：detach inferiors id</li>
</ul>
<h5 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h5><p>◼ exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>◼ exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p>
<p>注意：</p>
<ol>
<li><p>内核区的id等不会改变，但是用户取的数据都被替换</p>
</li>
<li><p>有p或者v后缀，一般filename直接写文件名，因为p会指定到环境变量查，v指定到数组envp[]中路径依次查找，没找到返回-1</p>
</li>
<li><p>一般fork新进程后，替换子进程数据</p>
</li>
</ol>
<ul>
<li>函数族</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族</span><br><span class="line">◼ int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">◼ int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">◼ int execle(const char *path, const char *arg, .../*, (char *) NULL, char *</span><br><span class="line">const envp[] */);</span><br><span class="line">◼ int execv(const char *path, char *const argv[]);</span><br><span class="line">◼ int execvp(const char *file, char *const argv[]);</span><br><span class="line">◼ int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line">◼ int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">l(list) 参数地址列表，以空指针结尾</span><br><span class="line">v(vector) 存有各参数地址的指针数组的地址</span><br><span class="line">p(path) 按 PATH 环境变量指定的目录搜索可执行文件</span><br><span class="line">e(environment) 存有环境变量字符串地址的指针数组的地址</span><br></pre></td></tr></table></figure>

<ul>
<li><p>execl()</p>
<pre><code>#include &lt;unistd.h&gt;
</code></pre>
<p>   int execl(const char *path, const char *arg, …);<br>   - 参数：<br>       - path:需要指定的执行的文件的路径或者名称<br>           a.out &#x2F;home&#x2F;nowcoder&#x2F;a.out 推荐使用绝对路径<br>           .&#x2F;a.out hello world<br>       - arg:是执行可执行文件所需要的参数列表<br>       第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称<br>       从第二个参数开始往后，就是程序执行所需要的的参数列表。<br>       参数最后需要以NULL结束（哨兵）</p>
<ul>
<li>返回值：<br>只有当调用失败，才会有返回值，返回-1，并且设置errno<br>如果调用成功，没有返回值。</li>
</ul>
</li>
<li><p>execlp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... )</span>;</span><br><span class="line">    - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">    - 参数：</span><br><span class="line">        - file:需要执行的可执行文件的文件名</span><br><span class="line">            a.out</span><br><span class="line">            ps</span><br><span class="line">- arg:是执行可执行文件所需要的参数列表</span><br><span class="line">        第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">        从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">        参数最后需要以<span class="literal">NULL</span>结束（哨兵）</span><br><span class="line"></span><br><span class="line">- 返回值：</span><br><span class="line">    只有当调用失败，才会有返回值，返回<span class="number">-1</span>，并且设置errno</span><br><span class="line">    如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>execv</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line">argv是需要的参数的一个字符串数组</span><br><span class="line"><span class="type">char</span> * argv[] = &#123;<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/ps&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">char</span> * envp[] = &#123;<span class="string">&quot;/home/nowcoder&quot;</span>, <span class="string">&quot;/home/bbb&quot;</span>, <span class="string">&quot;/home/aaa&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-进程退出"><a href="#2-3-进程退出" class="headerlink" title="2.3 进程退出"></a>2.3 进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*标准库</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment">  Linux系统（没有缓冲区，退出过不刷新缓冲区，直接退出，可能导致缓冲区的数据还没有拿出来）</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0);</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>◼ 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。<br>◼ 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init<br>进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束<br>了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。<br>◼ 因此孤儿进程并不会有什么危害</p>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，<strong>内核区的 PCB</strong> 没有办法自己释放掉，需要<strong>父进程</strong>去释放。<br>◼ 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。<br>◼ 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
<h5 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h5><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。<br>◼ 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<h6 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h6><ul>
<li><pre><code class="c">#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t wait(int *wstatus);
    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。
    参数：int *wstatus
        进程退出时的状态信息，传入的是一个int类型的地址，传出参数。
        //wstatus指针传入到宏里面可得到 退出的具体信息
        //如果不需要查看直接 wait(NULL)
    返回值：
        - 成功：返回被回收的子进程的id
        - 失败：-1 (所有的子进程都结束，调用函数失败)

调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）
如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">◼ wait() 和 waitpid() 函数的功能一样，区别在于：</span><br><span class="line">**wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。**</span><br><span class="line">◼ 注意：一次wait或waitpid调用**只能清理一个子进程**，清理多个子进程应使用循环：while()</span><br><span class="line"></span><br><span class="line">* 退出信息相关宏函数查询</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  ◼ WIFEXITED(status) 非0，进程正常退出</span><br><span class="line">  ◼ WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</span><br><span class="line">  ◼ WIFSIGNALED(status) 非0，进程异常终止</span><br><span class="line">  ◼ WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</span><br><span class="line">  ◼ WIFSTOPPED(status) 非0，进程处于暂停状态</span><br><span class="line">  ◼ WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</span><br><span class="line">  ◼ WIFCONTINUED(status) 非0，进程暂停后已经继续运行</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">  例子;</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/wait.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">  </span><br><span class="line">      pid_t pid;</span><br><span class="line">      //创建5个子进程 </span><br><span class="line">      for(int i=0;i!=5;++i)&#123;</span><br><span class="line">          pid = fork();</span><br><span class="line">          if(pid == 0)&#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(pid &gt; 0)&#123;</span><br><span class="line">          //父进程</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              printf(&quot;父进程: %d\n&quot;,getpid());</span><br><span class="line">              int st;</span><br><span class="line">              int ret = wait(&amp;st);</span><br><span class="line">              if(ret == -1)&#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              if(WIFEXITED(st))&#123;</span><br><span class="line">                  //是不是正常退出</span><br><span class="line">                  printf(&quot;退出状态码: %d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">              &#125;</span><br><span class="line">              if(WIFSIGNALED(st))&#123;</span><br><span class="line">                  //是不是被异常终止</span><br><span class="line">                  printf(&quot;被哪个信号干掉: %d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">              &#125;</span><br><span class="line">              printf(&quot;child die,pid = %d\n&quot;,WTERMSIG(st));</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid == 0)&#123;</span><br><span class="line">          //子进程</span><br><span class="line">          printf(&quot;子进程: %d\n&quot;,getpid());</span><br><span class="line">          exit(0);</span><br><span class="line">          sleep(1);        </span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">###### waitpid()函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; 0 : 某个子进程的pid</span><br><span class="line">                pid = 0 : 回收当前进程组的所有子进程    </span><br><span class="line">                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - 参数：int *wstatus</span><br><span class="line">                     进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                0 : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line"> //这三个会返回值可以判断当前进程的子进程回收情况，可以以此来设计，很多子进程时，回收处理函数</span><br><span class="line">                &gt; 0 : 返回子进程的id</span><br><span class="line">                = 0 : options=WNOHANG, 表示还有子进程活着 </span><br><span class="line">                = -1 ：错误，或者没有子进程了</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 例子(设置非阻塞)：</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/wait.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">  </span><br><span class="line">      pid_t pid;</span><br><span class="line">      //创建5个子进程</span><br><span class="line">      for(int i=0;i!=5;++i)&#123;</span><br><span class="line">          pid = fork();</span><br><span class="line">          if(pid == 0)&#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(pid &gt; 0)&#123;</span><br><span class="line">          //父进程</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              printf(&quot;父进程: %d\n&quot;,getpid());</span><br><span class="line">              sleep(1);</span><br><span class="line">              </span><br><span class="line">              int st;</span><br><span class="line">              //int ret = waitpid(-1,&amp;st,0);</span><br><span class="line">              int ret = waitpid(-1,&amp;st,WNOHANG);</span><br><span class="line">              </span><br><span class="line">              if(ret == -1)&#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;else if(ret == 0)&#123;</span><br><span class="line">                  //子进程还有在运行的</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;else if(ret &gt; 0)&#123;</span><br><span class="line">                  if(WIFEXITED(st))&#123;</span><br><span class="line">                      printf(&quot;退出的状态码：%d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">                  &#125;</span><br><span class="line">                  if(WIFSIGNALED(st))&#123;</span><br><span class="line">                      printf(&quot;被哪个信号干掉：%d&quot;,WTERMSIG(st));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              printf(&quot;child die,pid = %d\n&quot;,WTERMSIG(st));</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid == 0)&#123;</span><br><span class="line">          //子进程</span><br><span class="line">          while (1)</span><br><span class="line">          &#123;</span><br><span class="line">              printf(&quot;子进程: %d\n&quot;,getpid());</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">          exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">### 2.4进程间通信IPC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管道在使用完毕后应该被关闭，这是为了防止出现资源泄漏的情况。如果没有关闭管道，在程序运行过程中会一直占用系统资源，而且可能导致其他进程无法使用同名管道。同时，如果管道没有被及时关闭，在程序意外退出时也可能导致数据丢失或者磁盘空间占用问题。因此，在使用完毕后，最好及时关闭管道。</span><br><span class="line"></span><br><span class="line">* TCP/IP方式： mysql -h127.0.0.1 -uroot -P3306 -p</span><br><span class="line">* windowOS 的一台主机：命名管道和共享内存</span><br><span class="line">* 类Unix的一台主机：套接字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* （匿名）管道，Unix系统最古老的通信方式，所有Unix系统都支持</span><br><span class="line">* 统计目录中文件数量的命令： ls | wc -l</span><br><span class="line">  实际上就是创建管道 把写入端导出读取端</span><br><span class="line"></span><br><span class="line">##### 管道特点</span><br><span class="line"></span><br><span class="line">1. 管道其实是内核在内存中维护的缓冲区，缓冲能力有限，不同操作系统大小不同；</span><br><span class="line">2. 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但是不存储数据，可以按照操作文件的方式操作管道。</span><br><span class="line">3. 一个管道是一个字节流，使用管道不存在消息和消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块是多少（每次都按照自己能力读取）</span><br><span class="line">4. 通过管道传递是顺序的。</span><br><span class="line">5. 管道中传递数据方向是单向的，一端写入，一端读取，也就是半双工。</span><br><span class="line">6. 从管道中读取数据是一次性操作，数据一旦被读走了，就从管道抛弃了，(队列实现)释放空间以便写入更多的数据，在管道中无法使用lseek()随机访问数据</span><br><span class="line">7. 管道只能在具有公共祖先的进程（父子进程，兄弟进程，具有亲缘关系）之间使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 管道原理：子进程forkc()出来之后，可以共享文件描述符，可以操作建立管道</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 管道数据结构：环形队列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 匿名管道传输pipe()函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int pipe(int pipefd[2]);</span><br><span class="line">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">            pipefd[0] 对应的是管道的读端</span><br><span class="line">            pipefd[1] 对应的是管道的写端</span><br><span class="line">        返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line"></span><br><span class="line">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 例子-父子间管道通信</span><br><span class="line">* 匿名管道一般不会实现双向读写，因为没有了sleep()，本进程会抢读管道，一般就是一个读，一个写，并且关闭另一个操作，俺理解为互斥</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //在fork()之前创建管道</span><br><span class="line">    int pipefd[2];</span><br><span class="line">    int ret=pipe(pipefd);</span><br><span class="line">    if(ret==-1)&#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if(pid&gt;0)&#123;</span><br><span class="line">        //父进程先读取，然后写</span><br><span class="line">        printf(&quot;父进程&quot;);</span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            //先读</span><br><span class="line">            //sizeof给出操作数的存储地址空间</span><br><span class="line">            int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">            printf(&quot;parent recv: %s ,pid : %d\n&quot;,buf,getpid());</span><br><span class="line"></span><br><span class="line">            //向管道写入数据</span><br><span class="line">            char* str=&quot;hello,this is parent process&quot;;</span><br><span class="line">            write(pipefd[1],str,strlen(str));   </span><br><span class="line">            sleep(1);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(pid ==0)&#123;</span><br><span class="line">        //子进程先写，然后读</span><br><span class="line">        //管道默认阻塞，sleep(10); 如果没有数据，读取端就等着</span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        printf(&quot;子进程&quot;);</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            //先写</span><br><span class="line">            char* str=&quot;hello,this is child process&quot;;</span><br><span class="line">            //strlen()函数给出字符串的长度</span><br><span class="line">            write(pipefd[1],str,strlen(str));   </span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">            //读取数据</span><br><span class="line">            int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">            printf(&quot;child recv: %s ,pid : %d\n&quot;,buf,getpid());</span><br><span class="line">            //清除一下</span><br><span class="line">            bzero(buff,1024);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 互斥读写操作的代码如下</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">      //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  #include &lt;string.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">      //在fork()之前创建管道</span><br><span class="line">      int pipefd[2];</span><br><span class="line">      int ret=pipe(pipefd);</span><br><span class="line">      if(ret==-1)&#123;</span><br><span class="line">          perror(&quot;pipe&quot;);</span><br><span class="line">          exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      //创建子进程</span><br><span class="line">      pid_t pid = fork();</span><br><span class="line">      if(pid&gt;0)&#123;</span><br><span class="line">          //父进程读取</span><br><span class="line">          printf(&quot;父进程\n&quot;);</span><br><span class="line">  </span><br><span class="line">          //关闭写端</span><br><span class="line">          close(pipefd[1]);</span><br><span class="line">  </span><br><span class="line">          char buf[1024]=&#123;0&#125;;</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">              printf(&quot;parent recv: %s ,pid : %d\n&quot;,buf,getpid());           </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid ==0)&#123;</span><br><span class="line">          //子进程写端</span><br><span class="line">          printf(&quot;子进程\n&quot;);</span><br><span class="line">  </span><br><span class="line">          //关闭读端</span><br><span class="line">          close(pipefd[0]);</span><br><span class="line">  </span><br><span class="line">          while(1)&#123;</span><br><span class="line">              char* str=&quot;hello,this is child process&quot;;</span><br><span class="line">              //strlen()函数给出字符串的长度</span><br><span class="line">              write(pipefd[1],str,strlen(str));   </span><br><span class="line">              sleep(1);                  </span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">* 获取管道大小</span><br><span class="line"></span><br><span class="line">* // 1. 函数获取管道的大小</span><br><span class="line">  long size = fpathconf(pipefd[0], _PC_PIPE_BUF);</span><br><span class="line">  // 2. 终端获取管道信息</span><br><span class="line">  ulimit -a</span><br><span class="line"></span><br><span class="line">##### ps aux | grep xxx 操作实现 -父子进程通信案例</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //创建管道</span><br><span class="line">    int fd[2];</span><br><span class="line">    int ret=pipe(fd);</span><br><span class="line">    if(ret==-1)&#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;  </span><br><span class="line">    //创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if(pid &gt; 0)&#123;</span><br><span class="line">    //父进程，读取管道信息输出到列表</span><br><span class="line">        close(fd[1]);</span><br><span class="line">        </span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        int len=-1;</span><br><span class="line">        //空间设置 -1 留一个字符串的结束符位置</span><br><span class="line">        while((len=read(fd[0],buf,sizeof(buf)-1))&gt;0)&#123;</span><br><span class="line">            //过滤数据输出</span><br><span class="line">            printf(&quot;%s&quot;,buf);</span><br><span class="line">            //清空buf内容</span><br><span class="line">            memset(buf,0,1024);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(NULL);</span><br><span class="line"></span><br><span class="line">    &#125;else if(pid == 0)&#123;</span><br><span class="line">    //子进程，把输出stdout_fileno的内容写入管道</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        // 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span><br><span class="line">        dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">        //替换到aux的内容</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        //如果没退出，报系统错误</span><br><span class="line">        perror(&quot;execlp&quot;);</span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">##### 管道读写的特点</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端</span><br><span class="line">读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</span><br><span class="line"></span><br><span class="line">2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程</span><br><span class="line">也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line"></span><br><span class="line">3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程</span><br><span class="line">向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line"></span><br><span class="line">4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程</span><br><span class="line">也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">    读管道：</span><br><span class="line">        管道中有数据，read返回实际读到的字节数。</span><br><span class="line">        管道中无数据：</span><br><span class="line">            写端被全部关闭，read返回0（相当于读到文件的末尾）</span><br><span class="line">            写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">    写管道：</span><br><span class="line">        管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">        管道读端没有全部关闭：</span><br><span class="line">            管道已满，write阻塞</span><br><span class="line">            管道没有满，write将数据写入，并返回实际写入的字节数</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 设置非阻塞 - 此时设置为管道读端继续read，由于没有写入，read()返回-1</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">        int flags = fcntl(pipefd[0], F_GETFL);  // 获取原来的flag</span><br><span class="line">        flags |= O_NONBLOCK;            // 修改flag的值</span><br><span class="line">        fcntl(pipefd[0], F_SETFL, flags);   // 设置新的flag</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 有名管道</span><br><span class="line"></span><br><span class="line">◼ 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提 出了有名管道（FIFO），也叫命名管道、FIFO文件。 </span><br><span class="line"></span><br><span class="line">有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此 通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 ◼ </span><br><span class="line"></span><br><span class="line">一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的 I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一 个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的 名称也由此而来：先入先出。</span><br><span class="line"></span><br><span class="line">##### 与匿名管道区别：</span><br><span class="line"></span><br><span class="line">有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： </span><br><span class="line"></span><br><span class="line">1. FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 2. 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</span><br><span class="line"></span><br><span class="line">2. 通过命令创建有名管道 mkfifo 名字</span><br><span class="line"></span><br><span class="line">3. 通过函数创建有名管道 </span><br><span class="line">   int mkfifo(const char *pathname, mode_t mode); </span><br><span class="line"></span><br><span class="line">   ~~~c</span><br><span class="line">   创建fifo文件</span><br><span class="line">       1.通过命令： mkfifo 名字</span><br><span class="line">       2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">   </span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       #include &lt;sys/stat.h&gt;</span><br><span class="line">       int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">           参数：</span><br><span class="line">               - pathname: 管道名称的路径</span><br><span class="line">               - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                       是一个八进制的数</span><br><span class="line">           返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line">   ~~~</span><br><span class="line"></span><br><span class="line">4. 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 **open** 打开它，常见的文件 I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 </span><br><span class="line"></span><br><span class="line">5. FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是 从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</span><br><span class="line"></span><br><span class="line">##### 有名管道注意事项</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    有名管道的注意事项：</span><br><span class="line">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">    读管道：</span><br><span class="line">        管道中有数据，read返回实际读到的字节数</span><br><span class="line">        管道中无数据：</span><br><span class="line">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="line">            写端没有全部被关闭，read阻塞等待</span><br><span class="line">    </span><br><span class="line">    写管道：</span><br><span class="line">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">        管道读端没有全部关闭：</span><br><span class="line">            管道已经满了，write会阻塞</span><br><span class="line">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 同一路径下 有名管道创建并用于读写的例子</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">write.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    // 1.判断文件是否存在</span><br><span class="line">    int ret = access(&quot;fifo1&quot;, F_OK);</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">        printf(&quot;管道不存在，创建管道\n&quot;);</span><br><span class="line">        //2.创建管道文件</span><br><span class="line">        ret = mkfifo(&quot;fifo1&quot;, 0664);</span><br><span class="line"></span><br><span class="line">        if(ret == -1) &#123;</span><br><span class="line">            perror(&quot;mkfifo&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //以只写的方式打开管道</span><br><span class="line">    int fd=open(&quot;fifo1&quot;,O_WRONLY);</span><br><span class="line">    if(fd==-1)&#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写入数据</span><br><span class="line">    for (int i = 0; i &lt; 100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[1024];</span><br><span class="line">        //sprintf将字符串写入buf中</span><br><span class="line">        sprintf(buf,&quot;hello,%d\n&quot;,i);</span><br><span class="line">        printf(&quot;write data: %s\n&quot;,buf);</span><br><span class="line">        write(fd,buf,strlen(buf));</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">read.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">     //1. 打开管道文件</span><br><span class="line">     int fd = open(&quot;fifo1&quot;,O_RDONLY);</span><br><span class="line">     if(fd == -1)&#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //读数据</span><br><span class="line">     while(1)&#123;</span><br><span class="line">        char buf[1024] = &#123;0&#125;;</span><br><span class="line">        int len = read(fd,buf,sizeof(buf));</span><br><span class="line">        if(len == 0)&#123;</span><br><span class="line">            printf(&quot;写端断开连接了。\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;recv buf :%s\n&quot;,buf);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="2-5-内存映射"><a href="#2-5-内存映射" class="headerlink" title="2.5 内存映射"></a>2.5 内存映射</h3><p>Memory-mapped I&#x2F;O 是将磁盘文件的数据映射到内存，用户通过修改内存就可以修改磁盘文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">    - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="type">void</span> *addr: <span class="literal">NULL</span>, 由内核指定</span><br><span class="line">        - length : 要映射的数据的长度，这个值不能为<span class="number">0</span>。建议使用文件的长度。</span><br><span class="line">                获取文件的长度：stat lseek</span><br><span class="line">        - prot : 对申请的内存映射区的操作权限</span><br><span class="line">            -PROT_EXEC ：可执行的权限</span><br><span class="line">            -PROT_READ ：读权限</span><br><span class="line">            -PROT_WRITE ：写权限</span><br><span class="line">            -PROT_NONE ：没有权限</span><br><span class="line">            要操作映射内存，必须要有读的权限。</span><br><span class="line">            PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">        - flags :</span><br><span class="line">            - MAP_SHARED : <span class="comment">//映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span></span><br><span class="line">            - MAP_PRIVATE ：<span class="comment">//不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）,可以用内存映射来存输入，之后用于写入</span></span><br><span class="line">        - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">            - 通过open得到，open的是一个磁盘文件</span><br><span class="line">            - 注意：文件的大小不能为<span class="number">0</span>，open指定的权限不能和prot参数有冲突，也就是不小于需要的权限。</span><br><span class="line">                prot: PROT_READ                open:只读/读写 </span><br><span class="line">                prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">        - offset：偏移量，一般不用。必须指定的是<span class="number">4</span>k的整数倍，<span class="number">0</span>表示不偏移。</span><br><span class="line">    - 返回值：返回创建的内存的首地址</span><br><span class="line">        失败返回MAP_FAILED，(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line">    - 功能：释放内存映射</span><br><span class="line">    - 参数：</span><br><span class="line">        - addr : 要释放的内存的首地址</span><br><span class="line">        - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样</span><br></pre></td></tr></table></figure>

<h5 id="使用内存映射实现进程间通信："><a href="#使用内存映射实现进程间通信：" class="headerlink" title="使用内存映射实现进程间通信："></a>使用内存映射实现进程间通信：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">使用内存映射实现进程间通信：</span><br><span class="line">1.有关系的进程（父子进程）</span><br><span class="line">    - 还没有子进程的时候</span><br><span class="line">        - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">    - 有了内存映射区以后，创建子进程</span><br><span class="line">    - 父子进程共享创建的内存映射区（类似于匿名管道）</span><br><span class="line"></span><br><span class="line">2.没有关系的进程间通信</span><br><span class="line">    - 准备一个大小不是0的磁盘文件</span><br><span class="line">    - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 使用内存映射区通信（也就是映射同一块文件）		</span><br><span class="line"></span><br><span class="line">注意：内存映射区通信，是非阻塞。</span><br></pre></td></tr></table></figure>

<h6 id="关系类进程通信"><a href="#关系类进程通信" class="headerlink" title="关系类进程通信"></a>关系类进程通信</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="comment">//创建内存映射区    </span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程，写入，父进程接受</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程读取</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,(<span class="type">char</span>*)ptr);<span class="comment">//相当于 把指针指向的内存地址的内容，写到buf中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写入</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;我是儿子，你好&quot;</span>);<span class="comment">//相当于往指针指向内存的位置写入这个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr,size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="非关系类进程通信"><a href="#非关系类进程通信" class="headerlink" title="非关系类进程通信"></a>非关系类进程通信</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">write.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程写入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建内存映射区    </span></span><br><span class="line">        <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;好哥们 你好\n&quot;</span>);       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭内存映射区</span></span><br><span class="line">        munmap(ptr,size);        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">read.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程读取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建内存映射区    </span></span><br><span class="line">        <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,(<span class="type">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s&quot;</span>,buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭内存映射区</span></span><br><span class="line">        munmap(ptr,size);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h5><ol>
<li><p>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<br>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p>
</li>
<li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<br>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p>
</li>
<li><p>如果文件偏移量为1000会怎样?<br>偏移量必须是4K的整数倍，返回MAP_FAILED</p>
</li>
<li><p>mmap什么情况下会调用失败?<br>- 第二个参数：length &#x3D; 0<br>    - 第三个参数：prot<br>    - 只指定了写权限<br>    - prot PROT_READ | PROT_WRITE<br>      第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY</p>
</li>
<li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?<br>- 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>    - 可以对新的文件进行扩展<br>    - lseek()<br>    - truncate()</p>
</li>
<li><p>mmap后关闭文件描述符，对mmap映射有没有影响？<br>int fd &#x3D; open(“XXX”);<br>mmap(,,,,fd,0);<br>close(fd);<br>映射区还存在，创建映射区的fd被关闭，没有任何影响。</p>
</li>
<li><p>对ptr越界操作会怎样？<br>void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p>
</li>
</ol>
<p>​       void *memcpy(void *dest, const void *src, size_t n);</p>
<h4 id="使用内存映射实现文件的拷贝"><a href="#使用内存映射实现文件的拷贝" class="headerlink" title="使用内存映射实现文件的拷贝"></a>使用内存映射实现文件的拷贝</h4><ul>
<li>使用内存映射实现文件拷贝的功能<br>思路：<br>1.对原始的文件进行内存映射<br>2.创建一个新文件（拓展该文件）<br>3.把新文件的数据映射到内存中<br>4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中<br>5.释放资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新文件（拓展该文件）</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> * ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存拷贝 memcpy内存拷贝函数 在man 3 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名内存映射"><a href="#匿名内存映射" class="headerlink" title="匿名内存映射"></a>匿名内存映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名映射：不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//此处添加ANONYMOUS，表示映射没有任何文件支持，也就是匿名内存映射不需要任何文件支持，所以下一个文件描述符参数作为-1</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *) ptr, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-信号"><a href="#2-6-信号" class="headerlink" title="2.6 信号"></a>2.6 信号</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>概述 : 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
</li>
<li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p>
<ol>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C<br>通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给<br>相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的<br>内存区域。</li>
<li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU<br>时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ol>
</li>
<li><p>使用信号的两个主要目的是：</p>
<ol>
<li>让进程知道已经发生了一个特定的事情。</li>
<li>强迫进程执行 它自己代码中的信号处理程序。</li>
</ol>
</li>
<li><p>信号的特点：</p>
<ol>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ol>
</li>
<li><pre><code class="shell">1. 查看系统定义的信号列表：kill –l
前 31 个信号为常规信号，其余为实时信号

2. ◼ 查看信号的详细信息：man 7 signal
◼ 信号的 5 中默认处理动作
 Term 终止进程
 Ign 当前进程忽略掉这个信号
 Core 终止进程，并生成一个Core文件(Core文件包含了一些关于异常的信息)
 Stop 暂停当前进程
 Cont 继续执行当前被暂停的进程

3. 信号的几种状态：产生、未决、递达
4. SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  * 这里注意kill 9不能杀死僵尸进程</span><br><span class="line">  * 可以用kill -l查看信号对应的编号</span><br><span class="line"></span><br><span class="line">##### kill() raise() abort()</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">    - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">    - 参数：</span><br><span class="line">        - pid ：</span><br><span class="line">            &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">            = 0 : 将信号发送给当前的进程组</span><br><span class="line">            = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">            &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="line">        - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">    kill(getppid(), 9);</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">    </span><br><span class="line">int raise(int sig);</span><br><span class="line">    - 功能：给当前进程或者线程发送信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - sig : 要发送的信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功 0</span><br><span class="line">        - 失败 非0</span><br><span class="line">    kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">void abort(void);</span><br><span class="line">    - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">    类似于: kill(getpid(), SIGABRT);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0) &#123;</span><br><span class="line">        // 子进程</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            printf(&quot;child process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if(pid &gt; 0) &#123;</span><br><span class="line">        // 父进程</span><br><span class="line">        printf(&quot;parent process\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;kill child process now\n&quot;);//这里传的是子进程pid</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### alarm() </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">    - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="line">            函数会给当前的进程发送一个信号：SIGALARM，（查表，会终止进程）</span><br><span class="line">    - 参数：</span><br><span class="line">        seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">                取消一个定时器，通过alarm(0)。</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 之前没有定时器，返回0</span><br><span class="line">        - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">- SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">    alarm(10);  -&gt; 返回0</span><br><span class="line">    过了1秒</span><br><span class="line">    alarm(5);   -&gt; 返回9</span><br><span class="line"></span><br><span class="line">alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 例子</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">//查看1秒计算机能数多少个数？</span><br><span class="line">/*</span><br><span class="line">    实际时间 = 内核时间 + 用户时间 + 消耗时间</span><br><span class="line">    进行文件的IO操作比较消耗时间</span><br><span class="line"></span><br><span class="line">    定时器，与进程的状态无关，alarm都会计时</span><br><span class="line">*/</span><br><span class="line">int main()&#123;</span><br><span class="line">    alarm(1);</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##### setitimer()</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    #include &lt;sys/time.h&gt;</span><br><span class="line">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="line">                        struct itimerval *old_value);</span><br><span class="line">   - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">        - which : 定时器以什么时间计时</span><br><span class="line">          ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="line">          ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">          ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line"></span><br><span class="line">        - new_value: 设置定时器的属性</span><br><span class="line">        </span><br><span class="line">            struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">            struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">            struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct timeval &#123;        // 时间的结构体</span><br><span class="line">                time_t      tv_sec;     //  秒数     </span><br><span class="line">                suseconds_t tv_usec;    //  微秒    </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        过10秒后，每个2秒定时一次</span><br><span class="line">       </span><br><span class="line">        - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">    </span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 0</span><br><span class="line">        失败 -1 并设置错误号</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##### signal 捕捉函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    typedef void (*sighandler_t)(int);</span><br><span class="line">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">        - 功能：设置某个信号的捕捉行为</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum: 要捕捉的信号</span><br><span class="line">            - handler: 捕捉到信号要如何处理</span><br><span class="line">                - SIG_IGN ： 忽略信号</span><br><span class="line">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">                回调函数：</span><br><span class="line">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">            失败，返回SIG_ERR，设置错误号</span><br><span class="line">            </span><br><span class="line">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 例子： 用setitimer配合signal捕捉</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">//设置回调函数</span><br><span class="line">void myAlarm(int num)&#123;</span><br><span class="line">    //这里可以查表得到信号14是SIGALRM</span><br><span class="line">    printf(&quot;捕捉到了信号编号是: %d\n&quot;,num);</span><br><span class="line">    printf(&quot;xxxxxxxxxxxx\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">  // 注册信号捕捉</span><br><span class="line">    // signal(SIGALRM, SIG_IGN);</span><br><span class="line">    // signal(SIGALRM, SIG_DFL);</span><br><span class="line">    // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span><br><span class="line">    signal(SIGALRM,myAlarm);</span><br><span class="line"></span><br><span class="line">    //设置间隔时间</span><br><span class="line">    struct itimerval new_value;</span><br><span class="line">    //时间变量必须要初始化</span><br><span class="line">    new_value.it_interval.tv_sec = 2;</span><br><span class="line">    new_value.it_interval.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    //延迟时间,到3s后开始计时</span><br><span class="line">    new_value.it_value.tv_sec = 3;</span><br><span class="line">    new_value.it_value.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">     //是非阻塞的   </span><br><span class="line">    int ret = setitimer(ITIMER_REAL,&amp;new_value,NULL);</span><br><span class="line">    printf(&quot;开始计时\n&quot;);</span><br><span class="line">    if(ret == -1)&#123;</span><br><span class="line">        perror(&quot;setitimer&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">	//保存程序不关闭 阻塞</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 2.7信号集</span><br><span class="line"></span><br><span class="line">* 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</span><br><span class="line">* 在 PCB 中有两个非常重要的信号集。一个称之为 “**阻塞信号集**”（**信号掩码（也就是阻塞信号集）**可以设置，比如empty和add） ，另一个称之为“**未决信号集**” （只读）。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。</span><br><span class="line">* 信号的 “未决” 是一种**状态**，指的是从**信号的产生到信号被处理前**的这一段时间。</span><br><span class="line">* 信号的 “阻塞” 是一个**开关动作**，指的是**阻止信号被处理**，但不是阻止信号产生。</span><br><span class="line">* 信号的**阻塞就是让系统暂时保留信号留待以后发送**。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</span><br><span class="line">* 下图，进程的虚拟地址空间，包括用户区和内核区，内核区中有PCB进程控制块，PCB中有未决信号集和阻塞信号集 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~shell</span><br><span class="line">1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</span><br><span class="line"></span><br><span class="line">2.信号产生但是没有被处理 （未决）</span><br><span class="line">    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</span><br><span class="line">    - SIGINT信号状态被存储在第二个标志位上</span><br><span class="line">        - 这个标志位的值为0， 说明信号不是未决状态</span><br><span class="line">        - 这个标志位的值为1， 说明信号处于未决状态</span><br><span class="line">    </span><br><span class="line">3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</span><br><span class="line">    - 阻塞信号集默认不阻塞任何的信号</span><br><span class="line">    - 如果想要阻塞某些信号需要用户调用系统的API</span><br><span class="line"></span><br><span class="line">4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</span><br><span class="line">    - 如果没有阻塞，这个信号就被处理</span><br><span class="line">    - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">以下信号集相关的函数都是对     自定义的信号集!!     进行操作。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">    - 功能：清空信号集中的数据,将信号集中的所有的标志位置为<span class="number">0</span></span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">    - 功能：将信号集中的所有的标志位置为<span class="number">1</span></span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为<span class="number">1</span>，表示阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为<span class="number">0</span>，表示不阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置不阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：判断某个信号是否阻塞</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：需要操作的信号集</span><br><span class="line">        - signum：需要判断的那个信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">1</span> ： signum被阻塞</span><br><span class="line">        <span class="number">0</span> ： signum不阻塞</span><br><span class="line">        <span class="number">-1</span> ： 失败</span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空信号集的内容 初始化的时候常用</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="type">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sigprocmask-修改内核阻塞信号集"><a href="#sigprocmask-修改内核阻塞信号集" class="headerlink" title="sigprocmask() 修改内核阻塞信号集"></a>sigprocmask() 修改内核阻塞信号集</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">    - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    - 参数：</span><br><span class="line">        - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">            SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变;</span><br><span class="line">                假设内核中默认的阻塞信号集是mask， mask | <span class="built_in">set</span> <span class="comment">//(因为1代表阻塞，所以用或)</span></span><br><span class="line">            SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞;</span><br><span class="line">                mask &amp;= ~<span class="built_in">set</span> <span class="comment">//(先取反 再与）</span></span><br><span class="line">             <span class="comment">//这里要记住 | 运算的取消是 &amp;=~</span></span><br><span class="line">            SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line">        </span><br><span class="line">        - <span class="built_in">set</span> ：已经初始化好的用户自定义的信号集</span><br><span class="line">        - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="literal">NULL</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：<span class="number">-1</span></span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line">    - 功能：获取内核中的未决信号集</span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，保存的是内核中的未决信号集中的信息。</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span></span><br><span class="line"><span class="comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置信号集，设置2 ，3号信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//把2,3号信号添加到set</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改内核中阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//获取当前未决的信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历前32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pendingset,i) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pendingset,i) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//解除阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction()信号捕捉函数"></a>sigaction()信号捕捉函数</h5><ul>
<li>最好用sigaction,而不是signal，因为标准可能不太一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">            - act ：捕捉到信号之后的处理动作</span><br><span class="line">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递<span class="literal">NULL</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功 <span class="number">0</span></span><br><span class="line">            失败 <span class="number">-1</span></span><br><span class="line"><span class="comment">/*sigaction的回调函数int类型参数，就是信号类型的宏定义；</span></span><br><span class="line"><span class="comment">	这样可以用管道搭配epoll来读传入的信号：</span></span><br><span class="line"><span class="comment">		1.用sig的回调函数向fd[1]写，传到fd[0]读端 </span></span><br><span class="line"><span class="comment">		2.然后把fd[0]加入epoll实例，就可以IO多路复用，得到突然传入的sig，并且用Switch判断sig的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">        <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">        <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="comment">// 不常用</span></span><br><span class="line">        <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">        <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。回调函数执行完之后，会转换到系统的阻塞信号集。这里一般需要把该临时阻塞信号集清空sigemptyset()</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">        <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">        <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">        <span class="type">int</span>        sa_flags;</span><br><span class="line">        <span class="comment">// 被废弃掉了</span></span><br><span class="line">        <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉特性：</span></span><br><span class="line"><span class="number">1.</span> 信号捕捉过程中会使用临时的阻塞信号集，处理完后，切换恢复到内核的阻塞信号集</span><br><span class="line"><span class="number">2.</span> 在回调sa_handler函数的期间，默认会屏蔽该函数的调用，执行完之后，才能继续处理</span><br><span class="line"><span class="number">3.</span> 信号集只是标志位，不能支持排队</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);  <span class="comment">// 清空临时阻塞信号集</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SIGCHLD信号-回收子进程"><a href="#SIGCHLD信号-回收子进程" class="headerlink" title="SIGCHLD信号 - 回收子进程"></a>SIGCHLD信号 - 回收子进程</h5><ul>
<li><p>SIGCHLD信号产生的条件</p>
<ol>
<li>子进程终止时</li>
<li>子进程接收到 SIGSTOP 信号停止时</li>
<li>子进程处在停止态，接受到SIGCONT后唤醒时</li>
</ol>
<p>以上三种条件都会给父进程发送 SIGCHLD 信号，<strong>父进程默认会忽略该信号</strong></p>
</li>
</ul>
<h6 id="SIGCHLD-实现回收子进程-比较常用配合waitpid来批量回收子进程"><a href="#SIGCHLD-实现回收子进程-比较常用配合waitpid来批量回收子进程" class="headerlink" title="SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程"></a>SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程</h6><ul>
<li>不阻塞父进程；提前捕捉，防止全死完了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   使用SIGCHLD信号解决僵尸进程的问题。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子进程的Callback function</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,num);</span><br><span class="line">    <span class="comment">//回收子进程PCB</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//wait调用一次只能回收一个，如果多个子进程同时死了，例如4个，那么肯定会发送4次信号，但是有可能有些信号会被忽略掉，所以要循环把所有的死了的子进程都回收掉用waitpid()配合循环。</span></span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//回收了一个子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;回收死亡的子进程：%d\n&quot;</span>,ret);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//rer == 0还有子进程活着,等他们死</span></span><br><span class="line">            <span class="comment">//ret &lt; 0没有活着的子进程了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="comment">/*1. 这里理解好阻塞:阻塞是接受了不处理。</span></span><br><span class="line"><span class="comment">      2. 为什么先阻塞SIGCHLD就可以保证父进程能处理所有僵尸进程？设置了SIGCHLD在阻塞信号集中阻塞的1，你们只要是	          只要曾经收到过SIGCHLD，未决就会保持1；等待之后父进程sigaction去处理，sigcation处理完之后置0；这里父进          程去处理的时候，只要未决是1，也就是不用考虑有多少个已经死了，只要知道有僵尸子进程，就可以用while循环加上          waitpid全部回收完成；</span></span><br><span class="line"><span class="comment">      	补充：因为对SIGCHILD信号的默认处理是将其忽略（此时捕捉信号函数还没有注册），如果没有阻塞，直接忽略掉，那			父进程就不知道之前发生了什么事情。</span></span><br><span class="line"><span class="comment">      3.《Linux/UNIX系统编程手册》指出为了保障可移植性，应用应在创建任何子进程之前就设置信号捕捉函数。【牛客			789400243号】提出了这个观点，应该在fork之前就注册信号捕捉的。其实就是对应了书上这句话。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一些子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程在不阻塞情况下，回收子进程PCB</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//设置捕捉子进程死亡的SIGCHLD</span></span><br><span class="line">		</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了不阻塞父进程自己的事情，在此处打开</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//父进程自己的事情</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid: %d\n&quot;</span>,getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid: %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8共享内存"><a href="#2-8共享内存" class="headerlink" title="2.8共享内存"></a>2.8共享内存</h3><ol>
<li>共享内存允许<strong>两个或者多个进程共享物理内存的同一块区域</strong>（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制<strong>无需内核介入</strong>（较少介入）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li>
<li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的<strong>速度更快</strong>。</li>
</ol>
<h5 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h5><ol>
<li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的<strong>共享内存标识符</strong>。</li>
<li>使用 shmat() 来<strong>附上</strong>共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个<strong>指向进程的虚拟地址空间中该共享内存段的起点的指针</strong>。</li>
<li>调用 shmdt() 来<strong>分离</strong>共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li>
<li>调用 shmctl() 来<strong>删除</strong>共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</li>
</ol>
<h5 id="共享内存函数"><a href="#共享内存函数" class="headerlink" title="共享内存函数"></a>共享内存函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁 <span class="comment">//因为有多个进程指向，类似于智能指针，全部标记销毁就销毁</span></span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节<span class="number">8</span>个位</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">read_shm.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个进程</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>,<span class="number">4096</span>,IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share memery id:%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="comment">//2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//3. 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">//4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.删除共享内存</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">write_shm.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个进程</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>,<span class="number">4096</span>,IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share memery id:%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="comment">//2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.删除共享内存</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享内存操作命令"><a href="#共享内存操作命令" class="headerlink" title="共享内存操作命令"></a>共享内存操作命令</h5><ol>
<li>ipcs 用法<br> ipcs -a &#x2F;&#x2F; 打印当前系统中<strong>所有的进程间</strong>通信方式的信息<br> ipcs -m &#x2F;&#x2F; 打印出<strong>使用共享内存</strong>进行进程间通信的信息<br> ipcs -q &#x2F;&#x2F; 打印出<strong>使用消息队列</strong>进行进程间通信的信息<br> ipcs -s &#x2F;&#x2F; 打印出<strong>使用信号进行进程间通信</strong>的信息</li>
<li>ipcrm 用法<br> ipcrm -M shmkey    &#x2F;&#x2F; 移除用shmkey创建的共享内存段<br> ipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段<br> ipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列<br> ipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列<br> ipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号<br> ipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号</li>
</ol>
<h5 id="基础问题："><a href="#基础问题：" class="headerlink" title="基础问题："></a>基础问题：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">问题1：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br><span class="line"></span><br><span class="line">问题2：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为0的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为0的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br><span class="line"></span><br><span class="line">问题3：共享内存和内存映射的区别</span><br><span class="line">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="line">    2.共享内存效果更高</span><br><span class="line">    3.内存</span><br><span class="line">        所有的进程操作的是同一块共享内存。</span><br><span class="line">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="line">    4.数据安全</span><br><span class="line">        - 进程突然退出</span><br><span class="line">            共享内存还存在</span><br><span class="line">            内存映射区消失</span><br><span class="line">        - 运行进程的电脑死机，宕机了</span><br><span class="line">            数据存在在共享内存中，没有了</span><br><span class="line">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="line"></span><br><span class="line">    5.生命周期</span><br><span class="line">        - 内存映射区：进程退出，内存映射区销毁</span><br><span class="line">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span><br><span class="line">            如果一个进程退出，会自动和共享内存进行取消关联。</span><br></pre></td></tr></table></figure>

<h3 id="2-9守护进程"><a href="#2-9守护进程" class="headerlink" title="2.9守护进程"></a>2.9守护进程</h3><h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><p> 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的<strong>控制终端（Controlling Terminal）</strong>，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。</p>
<p>默认情况下（没有重定向），每个进程的<strong>标准输入、标准输出和标准错误输出都指向控制终端</strong>，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
<p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</p>
<h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><p>进程组和会话在进程之间形成了一种两级层次关系：<strong>进程组是一组相关进程的集合，会话是一组相关进程组的集合</strong>。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p>
<p>进程组由一个或多个共享<strong>同一进程组标识符（PGID）</strong>的进程组成。一个进程组拥有一个进程组<strong>首进程</strong>，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。</p>
<p>进程组拥有一个生命周期，其开始时间为<strong>首进程创建组的时刻</strong>，结束时间为<strong>最后一个</strong><br><strong>成员进程退出组的时刻</strong>。一个进程可能会因为终止而退出进程组，也可能会因为加入<br>了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p>
<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><p>◼ 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会<br>话 ID。新进程会继承其父进程的会话 ID（<strong>SID</strong>）。</p>
<p>◼ 一个会话中的所有进程<strong>共享单个控制终端</strong>。控制终端会在会话首进程首次打开一个终<br>端设备时被建立。一个终端最多可能会成为<strong>一个</strong>会话的控制终端。</p>
<p>◼ 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为<br>后台进程组。只有<strong>前台进程组中的进程才能从控制终端中读取输入</strong>。当用户在控制终<br>端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p>
<p>◼ 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p>
<ul>
<li>进程组、会话操作函数</li>
</ul>
<p>◼ pid_t getpgrp(void);<br>◼ pid_t getpgid(pid_t pid);<br>◼ int setpgid(pid_t pid, pid_t pgid);<br>◼ pid_t getsid(pid_t pid);<br>◼ pid_t setsid(void);</p>
<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>◼ 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是<br>Linux 中的<strong>后台服务进程</strong>。它是一个生存期较长的进程，通常独立于控制终端并且周<br>期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p>
<p>◼ 守护进程具备下列特征：</p>
<ol>
<li>生命周期很长，守护进程会在系统启动的时候被<strong>创建并一直运行直至系统被关闭</strong>。</li>
<li>它在后台运行并且<strong>不拥有控制终端</strong>。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li>
</ol>
<ul>
<li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</li>
</ul>
<h6 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h6><p>◼ 执行一个 fork()，之后父进程退出，子进程继续执行。（1. 防止父进程死亡后出现shell提示符；2.防止该进程成为组进程的首进程）</p>
<p>◼ 子进程调用 setsid() 开启一个新会话。</p>
<p>◼ 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。<br>◼ 修改进程的当前工作目录，通常会改为根目录（&#x2F;）。<br>◼ 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>◼ 在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2()<br>使所有这些描述符指向这个设备。<br>◼ 核心业务逻辑</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个守护进程，每隔两秒获取系统时间，并且把这个时间写入到磁盘文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="comment">//捕捉到定时信号之后，获取系统时间，写入磁盘文件</span></span><br><span class="line">    <span class="type">time_t</span> tm =time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">// //直接打印,但是文件描述符 1 2 3都已经重定向了，所以打印不到终端</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf,&quot;%d-%d-%d,%d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon,loc-&gt;tm_mday,</span></span><br><span class="line">    <span class="comment">// loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化时间，写入磁盘文件中</span></span><br><span class="line">    <span class="type">char</span>* str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR|O_CREAT|O_APPEND,<span class="number">0664</span>);</span><br><span class="line">    write(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//守护进程创建步骤</span></span><br><span class="line">    <span class="comment">//1.创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.子进程开启新会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置掩码 信号掩码（也就是阻塞信号集）</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改进程的当前工作目录（注意权限）</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/klchen/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.关闭、重定向文件描述符(让标准输入、输出、错误，也就是0 1 2重定向到那个设备)</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕捉定时信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myFun;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec =<span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec =<span class="number">0</span>; </span><br><span class="line">    setitimer(ITIMER_REAL,&amp;val,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持进程不关闭</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Linux多线程开发"><a href="#3-Linux多线程开发" class="headerlink" title="3.Linux多线程开发"></a>3.Linux多线程开发</h2><h3 id="3-1线程概述"><a href="#3-1线程概述" class="headerlink" title="3.1线程概述"></a>3.1线程概述</h3><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机<br>制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p>
<ul>
<li><p><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p>
</li>
<li><p>线程是<strong>轻量级的进程</strong>（<strong>LWP</strong>：Light Weight Process），在 Linux 环境下线程的本<br>质仍是进程。</p>
</li>
<li><p>查看指定进程的 LWP 号：ps –Lf pid</p>
</li>
<li><p>共享资源<br> 进程 ID 和父进程 ID<br> 进程组 ID 和会话 ID<br> 用户 ID 和 用户组 ID<br> 文件描述符表<br> 信号处置<br> 文件系统的相关信息：文件权限掩码<br>（umask）、当前工作目录<br> 虚拟地址空间（除栈、.text）&#x2F;&#x2F;这两个会被划分</p>
</li>
<li><p>非共享资源<br> 线程 ID<br> 信号掩码<br> 线程特有数据<br> error 变量<br> 实时调度策略和优先级<br> 栈，本地变量和函数的调用链接信息</p>
</li>
<li><p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
</li>
</ul>
<h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><ol>
<li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</li>
<li>调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。</li>
<li>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</li>
<li>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。</li>
</ol>
<h3 id="3-2线程操作"><a href="#3-2线程操作" class="headerlink" title="3.2线程操作"></a>3.2线程操作</h3><h5 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span><br><span class="line">称之为子线程。</span><br><span class="line">程序中默认只有一个进程，fork()函数调用，<span class="number">2</span>个进程</span><br><span class="line">程序中默认只有一个线程，pthread_create()函数调用，<span class="number">2</span>个线程。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">    - 功能：创建一个子线程</span><br><span class="line">    - 参数：</span><br><span class="line">        - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span><br><span class="line">        - attr : 设置线程的属性，一般使用默认值，<span class="literal">NULL</span></span><br><span class="line">        - start_routine : <span class="comment">//函数指针，这个函数是子线程需要处理的逻辑代码,注意函数返回值void*,俺的理解是调用函数指针后，还是需要返回值告诉主线程创建子线程及子线程工作的成功与否，与前面的sigaction信号触发后的回调函数不一样，那个不需要返回执行正确与否</span></span><br><span class="line">        - arg : 给第三个参数使用，传参</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号。这个错误号和之前errno不太一样。</span><br><span class="line">        获取错误号的信息：  <span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>例子-gcc pthread_create.c -o pthread_create -lpthread</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意线程不是标准库 ，需要指定第三方库名称 -l pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 子线程创建的callback Fuction, 子线程需要处理的逻辑代码，传入参数指定为任意类型指针 2. 此处返回的是void*类型 返回任意类型指针 </span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg: %d\n&quot;</span>,*((<span class="type">int</span>*)arg));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main()函数都在主线程中执行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试callback的传入参数</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个子线程,测试回调函数及其参数</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,(<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *error = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s&quot;</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">    功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span><br><span class="line">    参数：</span><br><span class="line">        retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。(类似于<span class="keyword">return</span> (<span class="type">void</span>*)&amp;value;)</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    功能：获取当前的线程的线程ID</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">    功能：比较两个线程ID是否相等</span><br><span class="line">    不同的操作系统，<span class="type">pthread_t</span>类型的实现不一样，有的是无符号的长整型，有的</span><br><span class="line">    是使用结构体去实现的。</span><br></pre></td></tr></table></figure>

<ul>
<li>例子-线程退出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//相当于pthread_exit(NULL);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//mian thread已经退出，之后代码不会运行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="连接已终止的线程-线程回收"><a href="#连接已终止的线程-线程回收" class="headerlink" title="连接已终止的线程 - 线程回收"></a>连接已终止的线程 - 线程回收</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line">    - 功能：和一个已经终止的线程进行连接</span><br><span class="line">            回收子线程的资源</span><br><span class="line">            这个函数是阻塞函数，调用一次只能回收一个子线程</span><br><span class="line">            一般在主线程中使用</span><br><span class="line">    - 参数：</span><br><span class="line">        - thread：需要回收的子线程的ID</span><br><span class="line">        - retval: 接收子线程退出时的返回值</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">0</span> : 成功</span><br><span class="line">        非<span class="number">0</span> : 失败，返回的错误号</span><br></pre></td></tr></table></figure>

<ul>
<li>例子-回收子线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">//退出并且设置返回值</span></span><br><span class="line">    pthread_exit((<span class="type">void</span>*)&amp;num);<span class="comment">//相当于 return (void*)&amp;num              </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> * error1 = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s&quot;</span>,error1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程的事情</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i != <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld,main thread tid:%ld&quot;</span>,tid,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主进程调用pthread_exit()回收子线程的资源</span></span><br><span class="line">    <span class="type">int</span> *thread_return;</span><br><span class="line">    <span class="comment">//二级指针，因为传出参数是指针，需要用二级指针指向他</span></span><br><span class="line">    ret = pthread_join(tid,(<span class="type">void</span>**)&amp;thread_return);</span><br><span class="line">    <span class="keyword">if</span> (ret !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *error2 = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>,error2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data: %d\n&quot;</span>,*thread_return);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程回收成功!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span><br><span class="line">      <span class="number">1.</span>不能多次分离，会产生不可预料的行为。</span><br><span class="line">      <span class="number">2.</span>不能去连接一个已经分离的线程，会报错。</span><br><span class="line">    - 参数：需要分离的线程的ID</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号</span><br></pre></td></tr></table></figure>

<ul>
<li>例子：线程分离</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分离后，对分离的子线程进行连接 ,连接不上了哦 pthread_join()</span></span><br><span class="line">    <span class="comment">// ret = pthread_join(tid, NULL);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) &#123;</span></span><br><span class="line">    <span class="comment">//     char * errstr = strerror(ret);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;error3 : %s\n&quot;, errstr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：取消线程（让线程终止）</span><br><span class="line">        取消某个线程，可以终止某个线程的运行，</span><br><span class="line">        但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</span><br><span class="line">        取消点cancellaction point：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//printf是一个取消点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    - 初始化线程属性变量</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    - 释放线程属性的资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line">    - 获取线程分离的状态属性</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">    - 设置线程分离的状态属性</span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建线程属性变量</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">//初始化attr</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性变量为分离</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//创建的时候添加参数attr，设置分离</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,&amp;attr,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *errst = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1:%s\n&quot;</span>,errst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出线程id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld,main thread id: %ld\n&quot;</span>,tid,pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放线程资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3线程同步"><a href="#3-3线程同步" class="headerlink" title="3.3线程同步"></a>3.3线程同步</h3><ul>
<li><p>线程同步</p>
<ol>
<li>线程的主要优势在于，能够通过<strong>全局变量来共享信息</strong>。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
<li><strong>临界区</strong>是指访问某一<strong>共享资源的代码片段</strong>，并且这段代码的执行应为<strong>原子操作</strong>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</li>
<li><strong>线程同步</strong>：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li>
</ol>
</li>
<li><p>互斥量</p>
</li>
</ul>
<p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共<br>享资源的原子访问。</p>
<ol>
<li>互斥量有两种状态：已锁定（locked）和未锁（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法 。</li>
<li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问</li>
<li>同一资源时将采用如下协议 ：<br>⚫ 针对共享资源锁定互斥量<br>⚫ 访问共享资源<br>⚫ 对互斥量解锁</li>
</ol>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">互斥量的类型 <span class="type">pthread_mutex_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">    - 初始化互斥量</span><br><span class="line">    - 参数 ：</span><br><span class="line">        - mutex ： 需要初始化的互斥量变量</span><br><span class="line">        - attr ： 互斥量相关的属性，<span class="literal">NULL</span></span><br><span class="line">    - <span class="keyword">restrict</span> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。</span><br><span class="line">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex = xxx;</span><br><span class="line">        <span class="type">pthread_mutex_t</span> * mutex1 = mutex;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 释放互斥量的资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 解锁</span><br></pre></td></tr></table></figure>

<ul>
<li>例子 - 用三个线程并发卖票，保证同步互斥</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建全局的互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> ticket = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//子线程 共享函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sellticket</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"><span class="comment">//卖票</span></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第 %d 张票\n&quot;</span>,pthread_self(),ticket--);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//注意加锁之后要保证能够解锁，特别注意break,exit()这些直接退出的</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">6000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收子线程资源，阻塞</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放互斥资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        <span class="comment">//主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p> 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互<br>斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。<br>◼ <strong>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象</strong>，<br>若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<ul>
<li><p>死锁的几种场景：</p>
<ol>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>多线程多锁，抢占锁资源</li>
</ol>
</li>
<li><p>演示死锁</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1, mutex2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">workA</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="comment">//首先，在 workA 中使用 pthread_mutex_lock(&amp;mutex1) 对线程A进行加锁，但是由于 cpu 执行的速度很快，导致在 workB 中，还没有使用 pthread_mutex_lock(&amp;mutex2) 对线程B进行加锁，workA就继续向下执行，因为资源 B 并没有被线程 B 加锁，所以在 workA 中的 pthread_mutex_lock(&amp;mutex2) 并未处于阻塞状态</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果B已经锁住了，那这里A就阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workA....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">workB</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这个因为A已经锁了，B阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workB....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, workA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, workB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>读写锁<br>◼ 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的<strong>绝对排它性</strong>，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。<br>◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。<br>为了满足当前能够<strong>允许多个读出，但只允许一个写入的需求</strong>，线程提供了读写锁来实现。</p>
<ul>
<li>读写锁的特点：<ol>
<li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li>
<li>如果有其它线程写数据，则其它线程都不允许读、写操作。</li>
<li>写是独占的，写的优先级高。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 <span class="type">pthread_rwlock_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line">案例：<span class="number">8</span>个线程操作同一个全局变量。</span><br><span class="line"><span class="number">3</span>个线程不定时写这个全局变量，<span class="number">5</span>个线程不定时的读这个全局变量</span><br></pre></td></tr></table></figure>

<ul>
<li>例子 - 读写锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8个线程操作一个全局变量，3个写，5个读</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> num =<span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//写区锁</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write,tid: %ld,num: %d\n&quot;</span>,pthread_self(),num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//读区锁</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程创建</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>],rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i],<span class="literal">NULL</span>,writeNum,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i],<span class="literal">NULL</span>,readNum,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(wtid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(rtid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁，主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥结构-粗略版本的生产消费者模型，可能会导致已放弃 (核心已转储)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//队列方式读取，实际上是back指针，插入的时候用头插法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者 不断添加节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode -&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode -&gt;num = rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d,tid: %ld\n&quot;</span>,newNode-&gt;num,pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 获取节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">custmer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//同一块临界区，设置为都互斥</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node,num: %d,tid: %ld\n&quot;</span>,tmp-&gt;num,pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没了，快做\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//5个生产者线程，5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>],ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i],<span class="literal">NULL</span>,custmer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(ptid[i]);</span><br><span class="line">        pthread_detach(ctid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出主线程，释放锁</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整的生产者消费者模型代码 - 固定缓冲区大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">int</span> *buf;</span><br><span class="line"><span class="type">int</span> bufSize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> bufPtr;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="comment">//三个信号量</span></span><br><span class="line"><span class="type">sem_t</span> full, empty, mutex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (bufPtr &lt; bufSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//信号量模型</span></span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        buf[++bufPtr] = bufPtr;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//信号量模型</span></span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        count = (count + <span class="number">1</span>) % __INT32_MAX__;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid[%ld], count[%d], data[%d]\n&quot;</span>, pthread_self(), count, buf[bufPtr--]);</span><br><span class="line"> </span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化三个信号量</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, bufSize);</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化读写指针、缓冲区</span></span><br><span class="line">    bufPtr = <span class="number">-1</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    buf = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * bufSize);</span><br><span class="line">    <span class="comment">//创建6个线程，一个作生产者，5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ppid, cpids[<span class="number">5</span>];</span><br><span class="line">    pthread_create(&amp;ppid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;cpids[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//detach分离，线程自动回收资源</span></span><br><span class="line">    pthread_detach(ppid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(cpids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程结束</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>某个条件满足之后开启或者解除阻塞;</p>
<ul>
<li>《Liunx&#x2F;UNIX系统编程手册》第531页有句话，条件变量并不保存状态信息，只是传递应用程序状态信息的一种通讯机制。发送信号时若无任何线程在等待该条件变量，这个也就会不了了之。线程如在此后等待该条件变量，只有当再次收到此变量的下一信号时，方可解除阻塞状态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">条件变量的类型 <span class="type">pthread_cond_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">    - 等待，调用了该函数，线程会阻塞。<span class="comment">//1.这个函数调用阻塞的时候，会对互斥锁mutex解锁；当收到signal或者broadcasr的时候，取消阻塞，这个时候会重新加上锁mutex</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">    - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    - <span class="comment">//唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    - 唤醒<span class="comment">//所有的等待的线程</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子：资源不足的时候，条件变量wait等待生产者，生产者生产后，条件变量signal通知生产者</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="comment">//创建条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//队列方式读取，实际上是back指针，插入的时候用头插法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者 不断添加节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode -&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode -&gt;num = rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d,tid: %ld\n&quot;</span>,newNode-&gt;num,pthread_self());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生产一个，就同志消费者，唤醒一个等待的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 获取节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">custmer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//同一块临界区，设置为都互斥</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node,num: %d,tid: %ld\n&quot;</span>,tmp-&gt;num,pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*没有数据，需要等待</span></span><br><span class="line"><span class="comment">            当函数调用阻塞的时候，对互斥锁进行解锁，</span></span><br><span class="line"><span class="comment">            当不阻塞的时候，继续向下执行，会重新加锁</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没了，快做\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="comment">//usleep(100);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//5个生产者线程，5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>],ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i],<span class="literal">NULL</span>,custmer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(ptid[i]);</span><br><span class="line">        pthread_detach(ctid[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">信号量的类型 <span class="type">sem_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">    - 初始化信号量</span><br><span class="line">    - 参数： </span><br><span class="line">        - sem : 信号量变量的地址</span><br><span class="line">        - pshared : <span class="number">0</span> 用在线程间 ，非<span class="number">0</span> 用在进程间</span><br><span class="line">        - value : 信号量中的值</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 释放资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 对信号量加锁，调用一次对信号量的值<span class="number">-1</span>，如果值为<span class="number">0</span>，就阻塞</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 对信号量解锁，调用一次对信号量的值+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line">init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    sem_wait(&amp;psem);</span><br><span class="line">    sem_post(&amp;csem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer() &#123;</span><br><span class="line">    sem_wait(&amp;csem);</span><br><span class="line">    sem_post(&amp;psem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>例子 - 用信号量实现生产者消费者</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">customer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Linux网络编程"><a href="#4-Linux网络编程" class="headerlink" title="4.Linux网络编程"></a>4.Linux网络编程</h2><h3 id="4-1网络基础"><a href="#4-1网络基础" class="headerlink" title="4.1网络基础"></a>4.1网络基础</h3><p>看pdf</p>
<h3 id="4-2-socket通信基础"><a href="#4-2-socket通信基础" class="headerlink" title="4.2 socket通信基础"></a>4.2 socket通信基础</h3><h5 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介</h5><p>所谓 socket（套接字），就是对<strong>网络中不同主机上的应用进程之间进行双向通信的端点的抽象</strong>。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p>
<p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制</strong>。</p>
<p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为<strong>内核借助缓冲区形成的伪文件</strong>。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于<strong>本地</strong>进程间通信，而套接字多应用于<strong>网络进程间</strong>数据的传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 套接字通信分两部分：</span></span><br><span class="line">- 服务器端：被动接受连接，一般不会主动发起连接</span><br><span class="line">- 客户端：主动向服务器发起连接</span><br><span class="line"> </span><br><span class="line">socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。</span><br></pre></td></tr></table></figure>

<h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>现代 CPU 的<strong>累加器</strong>一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在<strong>内存中排列的顺序</strong>将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于<strong>字节、字等的存储机制</strong>有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如<br>果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。</p>
<ul>
<li><strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数</strong><br><strong>据当然就无需谈顺序的问题了)。</strong></li>
<li>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整<br>数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地<br>址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地<br>址处。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用union查找字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>)&amp;&amp;(test.bytes[<span class="number">1</span>] == <span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>)&amp;&amp;(test.bytes[<span class="number">1</span>] == <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h5><ul>
<li><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。<br>解决问题的方法是：<br>    发送端总是把要发送的数据转换成<strong>大端字节序数据后再发送</strong>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p>
</li>
<li><p><strong>网络字节顺序</strong>是 TCP&#x2F;IP 中规定好的一种数据表示格式，它<strong>与具体的 CPU 类型、操作系统等无关</strong>，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。<br>BSD Socket提供了封装好的转换接口，方便程序员使用。</p>
<ol>
<li>从主机字节序到网络字节序的转换函数：htons、htonl；</li>
<li>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network  网络字节序</span><br><span class="line">s - <span class="type">short</span>  <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">l  - <span class="type">long</span>  <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口 因为端口本身是unsigned short类型</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"><span class="comment">// 转IP	因为端口本身是unsigned int类型</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// 网络字节序 - 主机字节序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//htons 两个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//htonl 一般转化ip 四个字节</span></span><br><span class="line">    <span class="type">char</span>  buf[<span class="number">4</span>] = &#123;<span class="number">196</span>,<span class="number">168</span>,<span class="number">1.100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)buf;</span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span>*)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h4><p>客户端和服务器通信，需要IP Port ….，所以封装好了一个socket地址。</p>
<p>&#x2F;&#x2F; socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。</p>
<h5 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h5><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span>     sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议<br>族（protocol family，也称 domain）和对应的地址族入下所示</li>
</ol>
<ul>
<li>宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。</li>
</ul>
<ol start="2">
<li>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</li>
</ol>
<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line"><span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<h5 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h5><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr <em>*退化成了（void *）**的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再</em>*强制类型转化为所需的地址类型**。</p>
<p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>//这个用较多</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span> <span class="comment">//这个用较多</span></span><br><span class="line">  <span class="type">in_port_t</span> sin_port;     <span class="comment">/* Port number. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* Internet address. */</span>  <span class="comment">//这个用较多</span></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line">       <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">socklen_t</span> 是sockaddr_in的长度类型</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin6_family;</span><br><span class="line">  <span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">  <span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">  <span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所有<strong>专用</strong> socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要<strong>转化为通用</strong> socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</li>
</ul>
<h3 id="4-3-IP地址转换"><a href="#4-3-IP地址转换" class="headerlink" title="4.3 IP地址转换"></a>4.3 IP地址转换</h3><p>字符串ip-整数 ，主机-网络字节序的转换</p>
<p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用<strong>点分十进制字符串</strong>表示 IPv4 地址，以及用<strong>十六进制字符串</strong>表示 IPv6 地址。但编程中我们需要先把它们<strong>转化为整数（二进制数）方能使用</strong>。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p>
<ul>
<li>旧接口- 以下函数比较久，且只使用于IPv4，而且是不可重用的函数，比如第三个因为直接用了那个结构体变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下函数比较久，且只使用于IPv4，而且是不可重用的函数，比如第三个因为直接用了那个结构体变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//转换成整数</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="comment">//转换成整数，保存在结构体in_addr中，成功返回1，失败返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"><span class="comment">//网络字节序的证书转换成点分十进制的字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>新接口-下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET  AF_INET6</span><br><span class="line">  src:需要转换的点分十进制的IP字符串</span><br><span class="line">  dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET  AF_INET6</span><br><span class="line">  src: 要转换的ip的整数的地址</span><br><span class="line">  dst: 转换成IP地址字符串保存的地方</span><br><span class="line">  size：第三个参数的大小<span class="comment">//（数组的大小）</span></span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure>

<ul>
<li>IP地址转换例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建点分十进制ip地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.163.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ipv4字符串转化网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET,buf,&amp;num);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络字节序的整数转化为IPv4字符串</span></span><br><span class="line">        <span class="comment">//15个字符加上一个字符串结束符</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这里获取后，使用str和ip其实是一样	</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = inet_ntop(AF_INET,&amp;num,ip,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str:%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s\n&quot;</span>,ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ip == str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="4-4TCP通信流程"><a href="#4-4TCP通信流程" class="headerlink" title="4.4TCP通信流程"></a>4.4TCP通信流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 和 UDP -&gt; 传输层的协议</span></span><br><span class="line">UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠</span><br><span class="line">TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输</span><br><span class="line"> </span><br><span class="line">              UDP   TCP</span><br><span class="line">是否创建连接 无连接 ||面向连接</span><br><span class="line">是否可靠  不可靠 ||可靠的</span><br><span class="line">连接的对象个数   一对一、一对多、多对一、多对多 ||支持一对一</span><br><span class="line">传输的方式 面向数据报  ||面向字节流</span><br><span class="line">首部开销 <span class="number">8</span>个字节 ||最少<span class="number">20</span>个字节</span><br><span class="line">适用场景 实时应用（视频会议，直播）  ||可靠性高的应用（文件传输）</span><br></pre></td></tr></table></figure>


<h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">  - 监听：监听有客户端的连接</span><br><span class="line">  - 套接字：这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">  - 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字</span><br><span class="line">（fd）</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line"> - 接收数据</span><br><span class="line"> - 发送数据</span><br><span class="line"><span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于通信的套接字（fd）</span><br><span class="line"><span class="number">2.</span> 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line"><span class="number">3.</span> 连接成功了，客户端可以直接和服务器通信</span><br><span class="line">  - 接收数据</span><br><span class="line">  - 发送数据</span><br><span class="line"><span class="number">4.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure>

<h3 id="4-4套接字函数"><a href="#4-4套接字函数" class="headerlink" title="4.4套接字函数"></a>4.4套接字函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">- 功能：创建一个套接字	</span><br><span class="line">  - 参数：</span><br><span class="line">    - domain: 协议族</span><br><span class="line">       AF_INET : ipv4</span><br><span class="line">       AF_INET6 : ipv6</span><br><span class="line">       AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">      SOCK_STREAM : 流式协议<span class="comment">//TC一般 用这个</span></span><br><span class="line">      SOCK_DGRAM : 报式协议<span class="comment">//UDP等</span></span><br><span class="line">    - protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">      - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">      - SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">    - 返回值：</span><br><span class="line">      - 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">      - 失败：<span class="number">-1</span>    </span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命名</span></span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定 <span class="comment">//也就是讲文件描述符告诉连接方</span></span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">      - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">      - addrlen : 第二个参数结构体占的内存大小</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// cat /proc/sys/net/core/somaxconn可以查看，本机是4096</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">  - 参数：</span><br><span class="line">    - sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">    - backlog : 未连接的和已经连接的和的最大值， <span class="comment">//一般给个 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 用于监听的文件描述符</span><br><span class="line">      - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">      - addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">  - 返回值：</span><br><span class="line">      - 成功 ：用于通信的文件描述符</span><br><span class="line">      - <span class="number">-1</span> ： 失败</span><br><span class="line">       </span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 用于通信的文件描述符</span><br><span class="line">      - addr : 客户端要连接的服务器的地址信息</span><br><span class="line">      - addrlen : 第二个参数的内存大小</span><br><span class="line">  - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-TCP通信并发实现"><a href="#4-5-TCP通信并发实现" class="headerlink" title="4.5 TCP通信并发实现"></a>4.5 TCP通信并发实现</h3><h5 id="TCP通信-单连"><a href="#TCP通信-单连" class="headerlink" title="TCP通信 单连"></a>TCP通信 单连</h5><ol>
<li>服务器端设置端口999；客户端的端口是随机分配的，只要去连接服务器端的999就行</li>
<li>服务器端要去连的IP是任意的；客户端要去连接的IP是服务器端的192.168.31.128</li>
</ol>
<h6 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务器端两个文件描述符</span></span><br><span class="line"><span class="comment">1. 监听文件描述符lfd，相当于创建socket分配了，只不过后续要绑定到struct sockaddr_in saddr结构体（ip，port）上；</span></span><br><span class="line"><span class="comment">2.连接文件描述符cfd,在accept之后分配，只不过针对当前客户端的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit(0):正常运行程序并退出程序; exit(1):非正常运行导致退出程序,exit（-1）：非正常运行导致退出程序，与1类似；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span> </span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//方法一：设置ip，保持网络字节序；这儿注意一下结构体嵌套，最后存的变量</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET,&quot;192.168.31.128&quot;,saddr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="comment">//方法二：直接写in_addr_t类型的变量算了；INADDR_ANY是linux下的任博 </span></span><br><span class="line">    	<span class="comment">//设置ip号</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4，接受客户端连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出客户端数据</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">    inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">//获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">    <span class="comment">//5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//服务器接受客户端数据</span></span><br><span class="line">        <span class="comment">//cfd是客户端socket发过来的文件描述符</span></span><br><span class="line">        <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受了num个字节   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受完了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">    <span class="type">char</span>* data = <span class="string">&quot;连上了，我是服务器端&quot;</span>;</span><br><span class="line">        write(cfd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.断开关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端用自己socket生成的fd写读，并且把fd发给服务器端，服务器端用针对该客户端的cfd		</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *data = <span class="string">&quot;这是客户端&quot;</span>;</span><br><span class="line">        write(fd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="小作业-读取输入并且回射"><a href="#小作业-读取输入并且回射" class="headerlink" title="小作业-读取输入并且回射"></a>小作业-读取输入并且回射</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit(0):正常运行程序并退出程序; exit(1):非正常运行导致退出程序,exit（-1）：非正常运行导致退出程序，与1类似；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//方法一：设置ip，保持网络字节序；这儿注意一下结构体嵌套，最后存的变量</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET,&quot;192.168.31.128&quot;,saddr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="comment">//方法二：直接写in_addr_t类型的变量算了；INADDR_ANY是linux下的任博</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9988</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4，接受客户端连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出客户端数据</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">    inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">//获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">    <span class="comment">//5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//服务器接受客户端数据</span></span><br><span class="line">        <span class="comment">//cfd是客户端socket发过来的文件描述符</span></span><br><span class="line">        <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受了num个字节   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受完了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">    <span class="comment">//char* data = &quot;连上了，我是服务器端&quot;;</span></span><br><span class="line">        <span class="comment">// char data[1024];</span></span><br><span class="line">        <span class="comment">// scanf(&quot;%s&quot;,data);</span></span><br><span class="line">        <span class="comment">// printf(&quot;请输入\n&quot;);</span></span><br><span class="line">        write(cfd,recvBuf,<span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.断开关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9988</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//申请内存并且清空</span></span><br><span class="line">        <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,data);</span><br><span class="line">        write(fd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是<strong>客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等</strong>。</p>
<p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p>
<p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手<br>来关闭一个连接。<br>三次握手的目的是保证双方互相之间建立了连接。<br>三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手</p>
<h6 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h6><ul>
<li>16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或<br>应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号</li>
<li>32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输<br>方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个<br>TCP 报文段中，<strong>序号值被系统初始化为某个随机值 ISN</strong>（Initial Sequence Number，初始序号<br>值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上<br>该报文段所携带数据的第一个字节在整个字节流中的<strong>偏移</strong>。例如，某个 TCP 报文段传送的数据是字<br>节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从<br>B 到 A）的 TCP 报文段的序号值也具有相同的含义</li>
<li>32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是<br>收到的 <strong>TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度</strong> 。假设主机 A 和主机 B 进行<br>TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段<br>的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。</li>
<li>6 位标志位包含如下几项：<ol>
<li>URG 标志，表示紧急指针（urgent pointer）是否有效。</li>
<li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</li>
<li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾<br>出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</li>
<li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。</li>
<li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。</li>
<li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文<br>段。</li>
</ol>
</li>
<li>16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是<strong>接收</strong><br><strong>通告窗口</strong>（Receiver Window，RWND）。它告诉对方<strong>本端的 TCP 接收缓冲区还能容纳多少</strong><br><strong>字节的数据</strong>，这样对方就可以控制发送数据的速度</li>
<li>16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验<br>TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。<br>这也是 TCP 可靠传输的一个重要保障</li>
<li>16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一<br>个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏<br>移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<h6 id="三次握手连接过程"><a href="#三次握手连接过程" class="headerlink" title="三次握手连接过程"></a>三次握手连接过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：</span><br><span class="line">  <span class="number">1.</span>客户端将SYN标志位置为<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>生成一个随机的<span class="number">32</span>位的序号seq=J ， 这个序号后边第三次握手的时候是可以携带数据（数据的大小）</span><br><span class="line">第二次握手：</span><br><span class="line">  <span class="number">1.</span>服务器端接收客户端的连接： ACK=<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>服务器会回发一个确认序号： ack=客户端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br><span class="line">  <span class="number">3.</span>服务器端会向客户端发起连接请求： SYN=<span class="number">1</span></span><br><span class="line">  <span class="number">4.</span>服务器会生成一个随机序号：seq = K</span><br><span class="line">第三次握手：</span><br><span class="line">  <span class="number">1.</span>客户单应答服务器的连接请求：ACK=<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>客户端回复收到了服务器端的数据：ack=服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br></pre></td></tr></table></figure>

<h5 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h5><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的<br>拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中<strong>间节点阻塞掉包</strong>，<br>谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种<br>技术，即<strong>容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包</strong><br><strong>（称窗口尺寸）。</strong><br>TCP 中采用滑动窗口来进行传输控制，<strong>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于</strong><br><strong>接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0<br>时，发送方一般不能再发送数据报。</p>
<ul>
<li>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构</li>
</ul>
<p>窗口理解为缓冲区的大小<br>滑动窗口的大小会随着发送数据和接收数据而变化。<br>通信的双方都有发送缓冲区和接收数据的缓冲区<br>服务器：<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）<br>客户端<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发送方的缓冲区：</span><br><span class="line">  白色格子：空闲的空间</span><br><span class="line">  灰色格子：数据已经被发送出去了，但是还没有被接收</span><br><span class="line">  紫色格子：还没有发送出去的数据</span><br><span class="line">接收方的缓冲区：</span><br><span class="line">  白色格子：空闲的空间</span><br><span class="line">  紫色格子：已经接收到的数据</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span></span><br><span class="line"><span class="meta"># win: 滑动窗口</span></span><br><span class="line"><span class="number">1.</span> 客户端向服务器发起连接，客户单的滑动窗口是<span class="number">4096</span>，一次发送的最大数据量是<span class="number">1460</span></span><br><span class="line"><span class="number">2.</span> 服务器接收连接情况，告诉客户端服务器的窗口大小是<span class="number">6144</span>，一次发送的最大数据量是<span class="number">1024</span></span><br><span class="line"><span class="number">3.</span> 第三次握手</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span><span class="number">-9</span> 客户端连续给服务器发送了<span class="number">6</span>k的数据，每次发送<span class="number">1</span>k</span><br><span class="line"><span class="number">5.</span> 第<span class="number">10</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">2</span>k,窗</span><br><span class="line">口大小是<span class="number">2</span>k</span><br><span class="line"><span class="number">6.</span> 第<span class="number">11</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">4</span>k,窗</span><br><span class="line">口大小是<span class="number">4</span>k</span><br><span class="line"><span class="number">7.</span> 第<span class="number">12</span>次，客户端给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">8.</span> 第<span class="number">13</span>次，客户端主动请求和服务器断开连接，并且给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">9.</span> 第<span class="number">14</span>次，服务器回复ACK <span class="number">8194</span>, a:同意断开连接的请求 b:告诉客户端已经接受到方才发的<span class="number">2</span>k的数据</span><br><span class="line">c:滑动窗口<span class="number">2</span>k</span><br><span class="line"><span class="number">10.</span>第<span class="number">15</span>、<span class="number">16</span>次，通知客户端滑动窗口的大小</span><br><span class="line"><span class="number">11.</span>第<span class="number">17</span>次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</span><br><span class="line"><span class="number">12.</span>第<span class="number">18</span>次，第四次挥手，客户端同意了服务器端的断开请求</span><br></pre></td></tr></table></figure>



<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。</p>
<h5 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。</span><br><span class="line"> </span><br><span class="line">思路：</span><br><span class="line">  <span class="number">1.</span> 一个父进程，多个子进程</span><br><span class="line">  <span class="number">2.</span>父进程负责等待并接受客户端的连接</span><br><span class="line">  <span class="number">3.</span>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信</span><br></pre></td></tr></table></figure>

<h6 id="server-process"><a href="#server-process" class="headerlink" title="server_process"></a>server_process</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycleChild</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//子进程回收完</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//回收该子进程完成</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d被回收了\n&quot;</span>,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用SIGCHLD回收子进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recycleChild;</span><br><span class="line">    <span class="comment">//注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不停处理新客户端的链接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每连接上一个客户端，创建一个子进程处理</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程    </span></span><br><span class="line">            <span class="comment">//获取客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">            inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">            <span class="comment">//获取端口</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//不停读写</span></span><br><span class="line">            <span class="comment">//服务器读取客户端数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//接受了num个字节   </span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//接受完了</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">                write(cfd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子进程退出，等待回收 多进程别忘了回收子进程资源！！！！</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="client"><a href="#client" class="headerlink" title="client"></a>client</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf,<span class="string">&quot;recvBuf: %d\n&quot;</span>,i++);</span><br><span class="line">        <span class="comment">//输入 把\0也写入</span></span><br><span class="line">        write(fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多线程实现并发服务器-类似于线程池"><a href="#多线程实现并发服务器-类似于线程池" class="headerlink" title="多线程实现并发服务器 - 类似于线程池"></a>多线程实现并发服务器 - 类似于线程池</h5><h6 id="server-process-1"><a href="#server-process-1" class="headerlink" title="server_process"></a>server_process</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传到选定子线程的数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程通信</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line">    <span class="comment">//不停读写</span></span><br><span class="line">        <span class="comment">//服务器读取客户端数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> num = read(pinfo-&gt;fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//接受了num个字节   </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//接受完了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">            write(pinfo-&gt;fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子线程退出，记得分离！！！！！</span></span><br><span class="line">        close(pinfo-&gt;fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.连接</span></span><br><span class="line">        <span class="comment">//初始化数据</span></span><br><span class="line">        <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos)/<span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="comment">//清空数据       The  bzero()  function erases the data in the n bytes of the memory starting at the location pointed to by s, by writing zeros (bytes containing &#x27;\0&#x27;) to that area.</span></span><br><span class="line">            bzero(&amp;sockinfos[i],<span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">            <span class="comment">//设置初始值</span></span><br><span class="line">            sockinfos[i].fd=<span class="number">-1</span>;</span><br><span class="line">            sockinfos[i].tid=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从线程数组中找到可用的子线程，进行连接通信</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].tid == <span class="number">-1</span>)&#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有空闲线程,等会，重新找</span></span><br><span class="line">            <span class="keyword">if</span>(i == max <span class="number">-1</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr,&amp;cliaddr,len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建子进程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid,<span class="literal">NULL</span>,working,pinfo);</span><br><span class="line">        <span class="comment">//子线程分离</span></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="client-和前面一样"><a href="#client-和前面一样" class="headerlink" title="client - 和前面一样"></a>client - 和前面一样</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf,<span class="string">&quot;recvBuf: %d\n&quot;</span>,i++);</span><br><span class="line">        <span class="comment">//输入 把\0也写入</span></span><br><span class="line">        write(fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h5><ul>
<li>上图红线是发送方，虚线是接收方</li>
</ul>
<p>2MSL（Maximum Segment Lifetime）<br>主动断开连接的一方, 最后进入一个 TIME_WAIT状态, 这个状态会持续: 2msl</p>
<ul>
<li>msl: 官方建议: 2分钟, 实际是30s</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方</span><br><span class="line">必须处于TIME_WAIT 状态并持续 <span class="number">2</span>MSL 时间。</span><br><span class="line">这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。</span><br><span class="line">主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，</span><br><span class="line">被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。<span class="comment">//事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。</span></span><br><span class="line">    <span class="comment">//为什么不需要第五次挥手？如果被动关闭方没有接受到ACK，肯定对继续传送FIN，这时候主动方就知道第四次的ACK没穿送到位</span></span><br></pre></td></tr></table></figure>

<ul>
<li>半关闭</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2</span><br><span class="line">状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发</span><br><span class="line">送的数据，但是 A 已经不能再向 B 发送数据。<span class="comment">//为什么四次：第二次和第三次需要分开 ！服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从程序的角度，可以使用 API 来控制实现<strong>半连接状态</strong>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区别于close()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">   该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发</span><br><span class="line">出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以</span><br><span class="line">SHUT_WR。</span><br></pre></td></tr></table></figure>

<p>使用 close 中止一个连接，但它只是<strong>减少描述符的引用计数</strong>，并不直接关闭连接，只有当描述符的引用<br>计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也可选择中止一个方<br>向的连接，只中止读或只中止写。<br>注意:</p>
<ol>
<li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用<br>进程都调用了 close，套接字将被释放。</li>
<li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。<br>但如果一个进程 close(sfd) 将不会影响到其它进程。</li>
</ol>
<h5 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h5><ul>
<li><p>在不调用端口复用的时候， 如果服务器端处于time_wait状态，就会占用当前端口号，直到释放掉。</p>
<p>比如，如果重启服务器的话，就会显示地址已经使用，导致不能重启</p>
</li>
<li><p>端口复用最常用的用途是:</p>
<ol>
<li>防止服务器重启时之前绑定的端口还未释放</li>
<li>程序突然退出而系统<strong>没有释放端口</strong></li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> </span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - sockfd : 要操作的文件描述符</span><br><span class="line">        - level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">        - optname : 选项的名称</span><br><span class="line">            - SO_REUSEADDR</span><br><span class="line">            - SO_REUSEPORT</span><br><span class="line">        - optval : 端口复用的值（整形）</span><br><span class="line">            - <span class="number">1</span> : 可以复用</span><br><span class="line">            - <span class="number">0</span> : 不可以复用</span><br><span class="line">        - optlen : optval参数的大小</span><br><span class="line">端口复用，设置的时机是在服务器绑定bind端口之前。</span><br><span class="line">setsockopt();</span><br><span class="line">bind();</span><br></pre></td></tr></table></figure>

<ul>
<li>查看网络相关信息的命令<br>netstat<br> 参数：-a 所有的socket<br>   -p 显示正在使用socket的程序的名称<br>   -n 直接使用IP地址，而不通过域名服务器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int optval = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accpet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client&#x27;s ip is %s, and port is %d\n&quot;</span>, cliIp, cliPort );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小写转大写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            recvBuf[i] = <span class="built_in">toupper</span>(recvBuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大写字符串发给客户端</span></span><br><span class="line">        ret = send(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-IO多路复用"><a href="#4-6-IO多路复用" class="headerlink" title="4.6  IO多路复用"></a>4.6  IO多路复用</h3><ul>
<li>I&#x2F;O 多路复用使得<strong>程序能同时监听多个文件描述符</strong>，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的<br>系统调用主要有 select、poll 和 epoll</li>
</ul>
<h5 id="IO多路复用概述"><a href="#IO多路复用概述" class="headerlink" title="IO多路复用概述"></a>IO多路复用概述</h5><p>又叫IO多路转接，IO指的是针对内存</p>
<ul>
<li><p>BIO模型（线进程和客户端一一对应 accept、read会阻塞）的缺点：</p>
<ol>
<li><p>线程或者进程会消耗资源；</p>
</li>
<li><p>线程或者进程的调度消耗CPU资源；</p>
</li>
<li><p>根本问题：BOLCKING阻塞</p>
</li>
</ol>
</li>
<li><p>非阻塞，忙轮询的模型：</p>
<ol>
<li><p>提高了程序的执行效率；</p>
</li>
<li><p>但是轮询需要占用更多的CPU和系统资源</p>
</li>
</ol>
</li>
<li><p>NIO模型：</p>
<ol>
<li>需要不停调用，read就要调用n次</li>
</ol>
</li>
<li><p>IO多路转接技术：<br>委托内核，比较快，而且直接可以知道哪些有数据，不需要全部read一遍（select需要）</p>
<ol>
<li>select只会告诉你有几个文件描述符，有数据到达</li>
<li>epoll很勤快，她不仅会告诉你有几个快递到了，还会告诉你是哪个快递公司的快递</li>
</ol>
</li>
</ul>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><blockquote>
<p>主旨思想：</p>
<ol>
<li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O<br>  操作时，该函数才返回。<br>  a.这个函数是阻塞<br>  b.函数对文件描述符的检测的操作是由内核完成的</li>
<li>在返回时，它会告诉进程有多少（哪些）描述符要进行I&#x2F;O操作。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128   1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">//需要检测的文件描述符，传入内核，然后通过传入传出参数得到	</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">     fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">   - nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span><span class="comment">//也就是检测位+1，因为数组从0开始</span></span><br><span class="line">      - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">        - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">      - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">        - <span class="comment">//委托内核检测写缓冲区是不是还可以写数据（不满的就可以写） 一般不检测</span></span><br><span class="line">	 - exceptfds : 检测发生异常的文件描述符的集合 <span class="comment">//一般用不到</span></span><br><span class="line">      - ti meout : 设置的超时时间 <span class="comment">//检测的最大时间，因为不能一直阻塞，除非设置NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">       		<span class="type">long</span>   tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">       		<span class="type">long</span>   tv_usec;     <span class="comment">/* microseconds */</span></span><br><span class="line">    	 &#125;;</span><br><span class="line">		- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化<span class="comment">//永久阻塞</span></span><br><span class="line">        - tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">       	- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">         </span><br><span class="line">   - 返回值 :</span><br><span class="line">	  - &gt;<span class="number">1</span> : 失败</span><br><span class="line">      - &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>对应 3 4 100 101的fd：<ol>
<li>先定义reads 1024bit（0-1023），然后监听 3 4 100 101的fd放到reads中</li>
<li>用select把reads读到内核中，并且检测，检测到有数据的置位1，没数据置位0，（比如只有3 4 有数据）</li>
<li>然后从内核态拷贝到用户态（用户态遍历之后知道3 4 有数据），然后对有数据的进行通信</li>
</ol>
</li>
</ul>
<h6 id="select实现多路转接"><a href="#select实现多路转接" class="headerlink" title="select实现多路转接"></a>select实现多路转接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    listen(lfd,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多路转接模型</span></span><br><span class="line">        <span class="comment">//创建fd_set集合，存放需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset,tmp;<span class="comment">//底层表示1024个文件描述符</span></span><br><span class="line">        <span class="comment">//清空rdset</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">        <span class="comment">//添加lfd</span></span><br><span class="line">    FD_SET(lfd,&amp;rdset);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        tmp = rdset;</span><br><span class="line">        <span class="comment">//调用系统函数，让内核帮检测哪个有数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>,&amp;tmp,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有数据变化</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明有文件描述符对应的缓冲区数据有ret个发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd,&amp;tmp))&#123;</span><br><span class="line">                <span class="comment">//表示有新的客户端连接进来</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//新的文件描述符加入到集合中 </span></span><br><span class="line">                FD_SET(cfd,&amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//内核判断集合中有数据的文件描述符后，依次读取数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd+<span class="number">1</span>;i &lt;= maxfd;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i,&amp;tmp))&#123;</span><br><span class="line">                    <span class="comment">//说明这个文件描述符对应的客户端发来数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(i,&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        FD_CLR(i,&amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                        write(i,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul>
<li><p>select() 的缺点：<br>1.每次调用select，都需要把fd集合从用户态<strong>拷贝</strong>到内核态，这个开销在fd很多时会很大<br>2.同时每次调用select都需要在内核<strong>遍历传递进来的所有fd</strong>，这个开销在fd很多时也很大<br>3.select<strong>支持的文件描述符数量太小</strong>了，默认是1024<br>4.<strong>fds集合不能重用</strong>，每次都需要重置</p>
</li>
<li><p>poll解决了缺点3 4</p>
</li>
<li><p>poll接口说明</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span>  fd;     <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line"><span class="type">short</span> events;   <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line"><span class="type">short</span> revents;   <span class="comment">/* 文件描述符实际发生的事件 */</span>              <span class="comment">//调用poll的时候会传出</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">    - <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">    - timeout : 阻塞时长</span><br><span class="line">      <span class="number">0</span> : 不阻塞</span><br><span class="line">      <span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">      &gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">  - 返回值：</span><br><span class="line">    <span class="number">-1</span> : 失败</span><br><span class="line">    &gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>


<h6 id="poll实现多路转接"><a href="#poll实现多路转接" class="headerlink" title="poll实现多路转接"></a>poll实现多路转接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul>
<li>直接在内核操作，内核用rbtree比较快，事件驱动，红黑树节点上注册有回调函数，事件到来后执行回调函数</li>
<li>去掉拷贝到内核的开销，并且能告知哪些文件描述符发送改变，而不只是个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检</span></span><br><span class="line">测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向</span><br><span class="line">链表）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">-1</span> : 失败</span><br><span class="line">        &gt; <span class="number">0</span> : 文件描述符<span class="comment">//操作epoll实例的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">	常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">            - epfd : epoll实例对应的文件描述符</span><br><span class="line">            - op : 要进行什么操作</span><br><span class="line">                EPOLL_CTL_ADD:  添加 <span class="comment">//记得提前设置一个epoll_event结构</span></span><br><span class="line">                EPOLL_CTL_MOD:  修改</span><br><span class="line">                EPOLL_CTL_DEL:  删除 <span class="comment">//删除处理，第四的个参数为NULL</span></span><br><span class="line">            - fd : 要检测的文件描述符</span><br><span class="line">            - event : 检测文件描述符什么事情</span><br><span class="line"><span class="comment">// 检测函数                </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - events : 传出参数，保存了发送了变化的文件描述符的信息 <span class="comment">//之后遍历读取处理</span></span><br><span class="line">        - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">        - timeout : 阻塞时间</span><br><span class="line">            - <span class="number">0</span> : 不阻塞</span><br><span class="line">            - <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">            - &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">                </span><br><span class="line">    - 返回值：</span><br><span class="line">         - 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">         - 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h6 id="epoll实现多路转接"><a href="#epoll实现多路转接" class="headerlink" title="epoll实现多路转接"></a>epoll实现多路转接</h6><p>建立epoll实例，添加EPOLLIN，用epoll_wait返回所有事件，可以得到所有事件；<br>然后按照事件类型逐个处理，把新连接进来的客户端添加到epoll实例中监听，把处理好的事件从epoll实例中去掉；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd,epevs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd =epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)&#123;</span><br><span class="line">                <span class="comment">//监听的文件描述符有数据到达，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="comment">//添加到需要监听的部分 可以重用之前的epoll_event数据结构</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;epev);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//过滤写事件，也就是说对于不同时间要单独处理</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从epoll实例中删除掉</span></span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,curfd,<span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                    write(curfd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);    </span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Epoll的工作模式"><a href="#Epoll的工作模式" class="headerlink" title="Epoll的工作模式"></a>Epoll的工作模式</h5><ul>
<li>LT 模式 （水平触发）<br>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br> 读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>   a.用户不读数据，数据一直在缓冲区，epoll 会一直通知<br>   b.用户只读了一部分数据，epoll会通知<br>   c.缓冲区的数据读完了，不通知</li>
</ul>
<blockquote>
<p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这<br>种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操<br>作。如果你不作任何操作，内核还是会继续通知你的。</p>
</blockquote>
<ul>
<li><p>ET 模式（边沿触发）</p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br> 读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>   a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了<br>   b.用户只读了一部分数据，epoll不通知<br>   c.缓冲区的数据读完了，不通知</p>
</li>
</ul>
<blockquote>
<p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述<br>符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，<br>并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述<br>符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成<br>未就绪），内核不会发送更多的通知（only once）。<br>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll<br>工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写<br>操作把处理多个文件描述符的任务饿死。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    - EPOLLET	<span class="comment">//边沿触发 用的时候|上前面的检测事件</span></span><br></pre></td></tr></table></figure>

<h6 id="水平触发-默认"><a href="#水平触发-默认" class="headerlink" title="水平触发 - 默认"></a>水平触发 - 默认</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd,epevs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd =epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)&#123;</span><br><span class="line">                <span class="comment">//监听的文件描述符有数据到达，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="comment">//添加到需要监听的部分 可以重用之前的epoll_event数据结构</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;epev);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//过滤写事件，也就是说对于不同时间要单独处理</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从epoll实例中删除掉</span></span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,curfd,<span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                    write(curfd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);    </span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        <span class="comment">//fgets获取stdin的输入，阻塞</span></span><br><span class="line">        fgets(sendBuf,<span class="keyword">sizeof</span>(sendBuf),<span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="comment">//usleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="边沿触发-EPOLLET"><a href="#边沿触发-EPOLLET" class="headerlink" title="边沿触发 - EPOLLET"></a>边沿触发 - EPOLLET</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-7-UDP通信"><a href="#4-7-UDP通信" class="headerlink" title="4.7  UDP通信"></a>4.7  UDP通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">        - 参数：</span><br><span class="line">            - sockfd : 通信的fd</span><br><span class="line">            - buf : 要发送的数据</span><br><span class="line">            - len : 发送数据的长度</span><br><span class="line">            - flags : <span class="number">0</span></span><br><span class="line">            - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">            - addrlen : 地址的内存大小</span><br><span class="line">                </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">        - 参数：</span><br><span class="line">            - sockfd : 通信的fd</span><br><span class="line">            - buf : 接收数据的数组</span><br><span class="line">            - len : 数组的大小</span><br><span class="line">            - flags : <span class="number">0</span></span><br><span class="line">            - src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span> <span class="comment">//传出参数 不需要最后两个参数都可以指定NULL</span></span><br><span class="line">            - addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure>

<h5 id="UDP实现流程"><a href="#UDP实现流程" class="headerlink" title="UDP实现流程"></a>UDP实现流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        recvfrom(fd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP: %s,Port: %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ipbuf,<span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>,recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        sendto(fd,recvbuf,<span class="built_in">strlen</span>(recvbuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf,<span class="string">&quot;hello,i am client %d\n&quot;</span>,num++);</span><br><span class="line">        sendto(fd,sendBuf,<span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        recvfrom(fd,sendBuf,<span class="keyword">sizeof</span>(sendBuf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>,sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>广播和多播都用UDP</li>
</ul>
<h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广<br>播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。<br>a.只能在局域网中使用。<br>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> </span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">    - sockfd : 文件描述符</span><br><span class="line">    - level : SOL_SOCKET</span><br><span class="line">    - optname : SO_BROADCAST</span><br><span class="line">    - optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播<span class="comment">//1</span></span><br><span class="line">    - optlen : optval的大小</span><br><span class="line"><span class="comment">//使用的时候创建广播地址的套接字IP地址设置为广播地址，也就是最后一位255</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置广播属性</span></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd,SOL_SOCKET,SO_BROADCAST,&amp;op,<span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建广播地址  因为这里服务端是主动给别人发送数据了，不需要手动绑定一个端口了，但是底层肯定还会分配一个端口给他的。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="comment">//广播地址</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.255&quot;</span>,&amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.通信</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> sendbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendbuf,<span class="string">&quot;hello,client...%d\n&quot;</span>,num++);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        sendto(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据: %d\n&quot;</span>,num);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.客户端绑定本地接受的ip和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    cliaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">int</span> ret = bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        recvfrom(fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h5><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。<br>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方<br>案。多播数据报只应该由对它感兴趣的接口接收，也就是说由<strong>运行相应多播会话应用系统的主机上</strong><br><strong>的接口接收</strong>。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网<br>使用。<br>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据</p>
<ul>
<li>组播地址：<br>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从  224.0.0.0 到 239.255.255.255 ，<br>并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">	- level : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> //</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    // 客户端加入到多播组：</span></span><br><span class="line"><span class="class">    - <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">    - optname : IP_ADD_MEMBERSHIP</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* IP multicast address of group.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">// 组播的IP地址</span></span><br><span class="line">    <span class="comment">/* Local IP address of interface.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>多播通信示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 初始化多播地址 从表中选一个多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="comment">// 2.客户端绑定IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-本地套接字"><a href="#4-8-本地套接字" class="headerlink" title="4.8 本地套接字"></a>4.8 本地套接字</h3><ul>
<li>本地套接字的作用：本地的进程间通信<br>有关系的进程间的通信<br>没有关系的进程间的通信<br>本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 本地套接字通信的流程 - tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件:  sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">    <span class="type">char</span> sun_path[UNIX_PATH_MAX];   <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="number">1.</span> 创建监听的套接字</span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span> <span class="comment">//对local socket的数据结构</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 监听</span><br><span class="line">    listen(lfd, <span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span> 等待并接受连接请求</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">6.</span> 关闭连接</span><br><span class="line">    close();</span><br><span class="line"><span class="comment">// 客户端的流程</span></span><br><span class="line"><span class="number">1.</span> 创建通信的套接字</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的IP 端口</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 连接服务器</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">5.</span> 关闭连接</span><br><span class="line">    close();</span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-WebServer项目"><a href="#5-WebServer项目" class="headerlink" title="5.WebServer项目"></a>5.WebServer项目</h2><h3 id="5-1-阻塞非阻塞、同步异步"><a href="#5-1-阻塞非阻塞、同步异步" class="headerlink" title="5.1 阻塞非阻塞、同步异步"></a>5.1 阻塞非阻塞、同步异步</h3><ul>
<li>典型的一次IO的两个阶段是什么？数据就绪 和 数据读写</li>
</ul>
<ol>
<li>数据就绪：根据系统IO操作（现在只考虑网络IO）的就绪状态<br>阻塞<br>非阻塞</li>
<li>数据读写：根据应用程序和内核的交互方式<br>同步<br>异步</li>
</ol>
<ul>
<li>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO</li>
</ul>
<blockquote>
<p> 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为<br> 阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。<br> 同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是<br> 由请求方A<strong>自己来完成</strong>的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时<br> （或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以<br> 处理其它逻辑了，当<strong>B监听到事件处理</strong>完成后，会用事先约定好的通知方式，通知A处理结果。</p>
</blockquote>
<p> 同步阻塞 	同步非阻塞	异步阻塞	异步非阻塞</p>
<h3 id="5-2-Unix-x2F-Linux上的五种IO模型"><a href="#5-2-Unix-x2F-Linux上的五种IO模型" class="headerlink" title="5.2 Unix&#x2F;Linux上的五种IO模型"></a>5.2 Unix&#x2F;Linux上的五种IO模型</h3><h5 id="a-阻塞-blocking"><a href="#a-阻塞-blocking" class="headerlink" title="a.阻塞 blocking"></a>a.阻塞 blocking</h5><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必<br>须等这个函数返回才能进行下一步动作</p>
<ol>
<li>有等待 阻塞 2. 有数据拷贝 同步</li>
</ol>
<h5 id="b-非阻塞-non-blocking（NIO）"><a href="#b-非阻塞-non-blocking（NIO）" class="headerlink" title="b.非阻塞 non-blocking（NIO）"></a>b.非阻塞 non-blocking（NIO）</h5><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调<br>用总是<strong>立即返回</strong>，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两<br>种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 <strong>EAGAIN</strong>。</p>
<h5 id="c-IO复用（IO-multiplexing）"><a href="#c-IO复用（IO-multiplexing）" class="headerlink" title="c.IO复用（IO multiplexing）"></a>c.IO复用（IO multiplexing）</h5><p>Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是<br>这些函数可以<strong>同时(非)阻塞地处理多个IO操作</strong>。而且可以同时对多个读操作、写操作的IO函数进行<strong>检测</strong>。直到有数<br>据可读或可写时，才真正调用IO操作函数。&#x2F;&#x2F;主要不是处理高并发，而是同时处理多个IO的优点</p>
<h5 id="d-信号驱动（signal-driven）"><a href="#d-信号驱动（signal-driven）" class="headerlink" title="d.信号驱动（signal-driven）"></a>d.信号驱动（signal-driven）</h5><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进<br>程收到SIGIO 信号，然后处理 IO 事件 </p>
<p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需<br>要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率 </p>
<p>&#x2F;&#x2F;从内核空间拷贝到用户空间还是需要拷贝，也就是同步操作，不常用</p>
<h5 id="e-异步（asynchronous）"><a href="#e-异步（asynchronous）" class="headerlink" title="e.异步（asynchronous）"></a>e.异步（asynchronous）</h5><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方<br>式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> aio_fildes;       <span class="comment">/* File desriptor.  */</span></span><br><span class="line">  <span class="type">int</span> aio_lio_opcode;       <span class="comment">/* Operation to be performed.  */</span></span><br><span class="line">  <span class="type">int</span> aio_reqprio;      <span class="comment">/* Request priority offset.  */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">void</span> *aio_buf;   <span class="comment">/* Location of buffer.  */</span></span><br><span class="line">  <span class="type">size_t</span> aio_nbytes;        <span class="comment">/* Length of transfer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value.  */</span></span><br><span class="line">  <span class="comment">/* Internal members.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line">  <span class="type">int</span> __abs_prio;</span><br><span class="line">  <span class="type">int</span> __policy;</span><br><span class="line">  <span class="type">int</span> __error_code;</span><br><span class="line">  <span class="type">__ssize_t</span> __return_value;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">  <span class="type">__off_t</span> aio_offset;       <span class="comment">/* File offset.  */</span></span><br><span class="line">  <span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">__off64_t</span> aio_offset;     <span class="comment">/* File offset.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-Web-Server网页服务器"><a href="#5-3-Web-Server网页服务器" class="headerlink" title="5.3 Web Server网页服务器"></a>5.3 Web Server网页服务器</h3><h5 id="网页服务器简介"><a href="#网页服务器简介" class="headerlink" title="网页服务器简介"></a>网页服务器简介</h5><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主<br>要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自<br>客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返<br>回一个 Error 信息。</p>
<p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则<br>先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请<br>求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针<br>对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在<br>TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的<br>头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p>
<blockquote>
<p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（<strong>默认端口为80,HTTPS是443</strong>）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，<strong>HTTP可以在任何互联网协议上，或其他网络上实现</strong>。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 <strong>TCP 作为其传输层</strong>。<br>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
</blockquote>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客<br>户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方<br>法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版<br>本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求&#x2F;响应的步骤：</p>
<ol>
<li>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接<br>字连接。例如，<a target="_blank" rel="noopener" href="http://www.baidu.com.(url)/">http://www.baidu.com。（URL）</a></li>
<li>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求<br>头部、空行和请求数据 4 部分组成。</li>
<li>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个<br>响应由状态行、响应头部、空行和响应数据 4 部分组成。</li>
<li>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连<br>接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li>
<li>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应<br>头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据<br>HTML 的语法对其进行格式化，并在浏览器窗口中显示。</li>
</ol>
<ul>
<li>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</li>
</ul>
<ol>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li>
<li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</li>
<li>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三<br>次握手的第三个报文的数据发送给服务器;</li>
<li>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</li>
<li>释放 TCP 连接;</li>
<li>浏览器将该 HTML 文本并显示内容。</li>
</ol>
<p>HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客<br>户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端<br>在没有接收到请求之前不会发送响应</p>
<h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; </span><br><span class="line">BIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752; </span><br><span class="line">BDORZ=FFFB88E999055A3F8A630C64834BD6D0; </span><br><span class="line">__yjs_duid=1_d05d52b14af4a339210722080a668ec21614320694782; BD_HOME=1; </span><br><span class="line">H_PS_PSSID=33514_33257_33273_31660_33570_26350; </span><br><span class="line">BA_HECTOR=8h2001alag0lag85nk1g3hcm60q</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=</span><br></pre></td></tr></table></figure>

<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Bdpagetype</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Bdqid</span><span class="punctuation">: </span>0xf3c9743300024ee4</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>private</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=utf-8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 26 Feb 2021 08:44:35 GMT</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Fri, 26 Feb 2021 08:44:35 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BDSVRTM=13; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BD_HOME=1; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>H_PS_PSSID=33514_33257_33273_31660_33570_26350; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=172800</span><br><span class="line"><span class="attribute">Traceid</span><span class="punctuation">: </span>1614329075128412289017566699583927635684</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span><span class="punctuation">: </span>IE=Edge,chrome=1</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br></pre></td></tr></table></figure>

<h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h5><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态<br>的短语，彼此由空格分隔。<br>状态代码的第一个数字代表当前响应的类型：<br>1xx消息——请求已被服务器接收，继续处理<br>2xx成功——请求已成功被服务器接收、理解、并接受<br>3xx重定向——需要后续操作才能完成这一请求<br>4xx请求错误——请求含有词法错误或者无法被执行<br>5xx服务器错误——服务器在处理某个正确请求时发生错误<br>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍<br>然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p>
<p>更多状态码：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin</a></p>
<h4 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h4><p>服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor<br>和 Proactor，同步 I&#x2F;O 模型通常用于实现 Reactor 模式，异步 I&#x2F;O 模型通常用于实现 Proactor 模式。</p>
<h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><p>要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作<br>线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做<br>任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>
<ul>
<li>使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是</li>
</ul>
<ol>
<li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li>
<li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li>
<li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll<br>内核事件表中注册该 socket 上的写就绪事件。</li>
<li>当主线程调用 epoll_wait 等待 socket 可写。</li>
<li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li>
</ol>
<h5 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h5><p>Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻<br>辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p>
<ol>
<li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，<br>以及读操作完成时如何通知应用程序（这里以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据<br>已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求<br>后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以<br>及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据<br>已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li>
</ol>
<h5 id="模拟-Proactor-模式"><a href="#模拟-Proactor-模式" class="headerlink" title="模拟 Proactor 模式"></a>模拟 Proactor 模式</h5><p>使用同步 I&#x2F;O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向<br>工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下<br>来要做的只是对读写的结果进行逻辑处理。<br>使用同步 I&#x2F;O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p>
<ol>
<li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li>
<li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li>
<li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更<br>多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事<br>件表中注册 socket 上的写就绪事件。</li>
<li>主线程调用 epoll_wait 等待 socket 可写。</li>
<li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li>
</ol>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 <strong>CPU 数量差不多</strong>。线程池中的所<br>有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子<br>线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主<br>线程选择哪个子线程来为新任务服务，则有多种方式：</p>
<ul>
<li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流<br>选取）算法，但更优秀、更智能的算法将使任务在各个<strong>工作线程中更均匀地分配</strong>，从而减轻服务器<br>的整体压力。</li>
<li>主线程和所有子线程通过一个共享的工作队列来同步，<strong>子线程都睡眠在该工作队列上</strong>。当有新的任<br>务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线<br>程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在<br>工作队列上</li>
</ul>
<blockquote>
<p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量<br>N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来<br>说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集<br>型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一<br>般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导<br>致资源浪费。</p>
</blockquote>
<ul>
<li><p>设置线程池目的：</p>
<p>空间换时间，浪费服务器的硬件资源，换取运行效率。</p>
<ol>
<li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li>
<li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中<br>获取，无需动态分配。</li>
<li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源</li>
</ol>
</li>
</ul>
<h4 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h4><p>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个<br>问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该<br>socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于<br>是就出现了两个线程同时操作一个 socket 的局面。<strong>一个socket连接在任一时刻都只被一个线程处理</strong>，可<br>以使用 epoll 的 EPOLLONESHOT 事件实现。<br>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异<br>常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事<br>件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思<br>考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个<br>socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进<br>而让其他工作线程有机会继续处理这个 socket。</p>
<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。<br>有的应用层协议头部包含数据包类型字段，每种类型可以<strong>映射为逻辑单元的一种执行状态</strong>，服务器可以<br>根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE( Package _pack ) </span><br><span class="line">&#123;</span><br><span class="line">    PackageType _type = _pack.GetType();</span><br><span class="line">    <span class="keyword">switch</span>( _type )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            process_package_A( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            process_package_B( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。<br>状态之间的转移是需要状态机内部驱动，如下代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE() </span><br><span class="line">&#123;</span><br><span class="line">    State cur_State = type_A;</span><br><span class="line">        <span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">    &#123;</span><br><span class="line">        Package _pack = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span>( cur_State )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_package_state_A( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_package_state_B( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状<br>态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过<br>getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据<br>包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一<br>趟循环时，它将执行新的状态对应的逻辑。</li>
</ul>
<h4 id="服务器压力测试"><a href="#服务器压力测试" class="headerlink" title="服务器压力测试"></a>服务器压力测试</h4><p>Webbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发</p>
<ul>
<li>测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。</li>
<li>展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量。</li>
</ul>
<p>基本原理：Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的<br>结果通过pipe 告诉父进程，父进程做最终的统计结果。</p>
<h2 id="Ubuntu一些小操作"><a href="#Ubuntu一些小操作" class="headerlink" title="Ubuntu一些小操作"></a>Ubuntu一些小操作</h2><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><h4 id="文本文件上传"><a href="#文本文件上传" class="headerlink" title="文本文件上传"></a>文本文件上传</h4><p>​	文本文件的换行符</p>
<p>Windows : \r\n</p>
<p>Linux : \n</p>
<p>可以在 Notepad ++ 里观察到此区别</p>
<p>视图 | 显示符号 | 显示行尾符</p>
<h4 id="修改格式"><a href="#修改格式" class="headerlink" title="修改格式"></a>修改格式</h4><p>换行符的转换：</p>
<p>编辑 | 文档格式转换 | 转换为 UNIX格式</p>
<p>注意：只有在编辑 SHELL 脚本时，才需要转换</p>
<p>其他格式的文件一般都不需要转换，如*.xml, *.java</p>
<p><strong>演示</strong>：Shell脚本的编辑 。。</p>
<ol>
<li><p>用 Notepad++打开编辑 mytest.sh</p>
</li>
<li><p>转成 Unix格式 \n</p>
</li>
<li><p>上传至Linux</p>
</li>
<li><p>chmod +x mytest.sh</p>
</li>
<li><p>运行 .&#x2F;mytest.sh</p>
</li>
</ol>
<h3 id="命令类"><a href="#命令类" class="headerlink" title="命令类"></a>命令类</h3><h5 id="1-归档"><a href="#1-归档" class="headerlink" title="1. 归档"></a>1. 归档</h5><p>tar , 即 tape archive 档案打包</p>
<p>创建档案包</p>
<p>tar  -cvf  example.tar  example</p>
<p>其中，</p>
<p>  c ,  表示 create 创建档案</p>
<p>  v , 表示 verbose 显示详情</p>
<p>  f ,  表示 file</p>
<p>也可以多个目录打包 tar -cvf xxx.tar file1 file2 file3 </p>
<p>还原档案包</p>
<p>tar  -xvf  example.tar</p>
<p>tar  -xvf  example.tar  -C  outdir</p>
<p>其中，-C 参数指定目标目录，默认解到当前目录下</p>
<h5 id="2-压缩解压"><a href="#2-压缩解压" class="headerlink" title="2. 压缩解压"></a>2. 压缩解压</h5><p>先前的tar格式并没有压缩，体积较大</p>
<p>并档并压缩</p>
<p>tar  -zcvf  example.tar.gz  example</p>
<p>解压缩</p>
<p>tar  -zxvf  example.tar.gz</p>
<p>tar  -zxvf  example.tar.gz  -C  outdir</p>
<p>通常我们所见的，都是 *.tar.gz 这种格式</p>
<h5 id="7z"><a href="#7z" class="headerlink" title="7z"></a>7z</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install p7zip-full</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">7z a -t7z -r filename.7z ./*</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">7z x filename.7z -r -o./* </span><br></pre></td></tr></table></figure>

<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>定义环境变量</p>
<p>export OUTDIR&#x3D;&#x2F;opt&#x2F;</p>
<p>显示环境变量</p>
<p>echo ${OUTDIR}</p>
<p>查看所有环境变量</p>
<p>printenv</p>
<h5 id="查看当前进程"><a href="#查看当前进程" class="headerlink" title="查看当前进程"></a>查看当前进程</h5><p>进程id：echo $$</p>
<p>终端设备：tty</p>
<h6 id="找函数"><a href="#找函数" class="headerlink" title="找函数"></a>找函数</h6><p>man 2 xxx</p>
<p>或者 man xxx +tab键</p>
<h5 id="查看网络相关信息的命令"><a href="#查看网络相关信息的命令" class="headerlink" title="查看网络相关信息的命令"></a>查看网络相关信息的命令</h5><p>netstat<br> 参数：-a 所有的socket<br>   -p 显示正在使用socket的程序的名称<br>   -n 直接使用IP地址，而不通过域名服务器</p>
<p> netstat -anp|grep xxxx<br>查看端口号占用信息</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><h4 id="利用Core文件查看异常的信息"><a href="#利用Core文件查看异常的信息" class="headerlink" title="利用Core文件查看异常的信息"></a>利用Core文件查看异常的信息</h4><ol>
<li>用ulimit -a查看Core文件允许产生的大小，一般是0；然后改为一定值 ulimit -c 1024</li>
<li>然后用-g调试编译.c文件</li>
<li>然后调试改文件，输入core-file core就能看到</li>
<li>这里系统版本不同，生成不出来Core文件</li>
</ol>
<p>bt打印堆栈</p>
<h4 id="Linux下的时间设置"><a href="#Linux下的时间设置" class="headerlink" title="Linux下的时间设置"></a>Linux下的时间设置</h4><p>时钟时间 ＝ 阻塞时间 ＋ 就绪时间 ＋运行时间；</p>
<p>其中：运行时间&#x3D;用户CPU时间（用户的进程获得了CPU资源以后，在用户态执行的时间。）+系统CPU时间（用户进程获得了CPU资源以后，在内核态的执行时间。）；</p>
<ul>
<li>因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务</li>
</ul>
<h5 id="前后台进程"><a href="#前后台进程" class="headerlink" title="前后台进程"></a>前后台进程</h5><p>默认前台进程，阻塞</p>
<p>加上&amp;改为后台进程，改为非阻塞 ，但是注意要去查看，并且kill -9：<code>./sigprocmask&amp;</code></p>
<h5 id="段错误究竟是怎么发生的？段错误的复现为什么这么难？"><a href="#段错误究竟是怎么发生的？段错误的复现为什么这么难？" class="headerlink" title="段错误究竟是怎么发生的？段错误的复现为什么这么难？"></a>段错误究竟是怎么发生的？段错误的复现为什么这么难？</h5><p>段错误是个迷，有的人碰到过几次，有的人怎么也碰不到，这是由于神秘莫测的调度算法导致的。【潇潇_暮雨】小伙伴提出了，这是调用了不可重入的函数。《Linux&#x2F;UNIX系统编程手册》第21.1.2节 对可重入函数进行了详细的解释，有兴趣的可以去翻一下。</p>
<p>可重入函数的意思是：函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。通俗点讲，就是存在一个函数，A线程执行一半，B线程抢过CPU又来调用该函数，执行到1&#x2F;4倍A线程抢回执行权。在这样不断来回执行中，不出问题的，就是可重入函数。多线程中每个线程都有自己的堆栈，所以如果函数中只用到局部变量肯定是可重入的，没问题的。但是更新了全局变量或静态数据结构的函数可能是不可重入的。假设某线程正在为一个链表结构添加一个新的链表项，而另外一个线程也视图更新同一链表。由于中间涉及多个指针，一旦另一线程中断这些步骤并修改了相同指针，结果就会产生混乱。但是并不是一定会出现，一定是A线程刚好在修改指针，另外一线程又去修改才会出现。这就是为什么该问题复现难度较高的原因。</p>
<p>作者在文中指出，将静态数据结构用于内部记账的函数也是不可重入的。其中最明显的例子就是stdio函数库成员（printf()、scanf()等），它们会为缓冲区I&#x2F;O更新内部数据结构。所以，如果在捕捉信号处理函数中调用了printf()，而主程序又在调用printf()或其他stdio函数期间遭到了捕捉信号处理函数的中断，那么有时就会看到奇怪的输出，设置导致程序崩溃。虽然printf()不是异步信号安全函数，但却频频出现在各种示例中，是因为在展示对捕捉信号处理函数的调用，以及显示函数中相关变量的内容时，printf()都不失为一种简单而又便捷的方式。真正的应用程序应当避免使用该类函数。</p>
<p>printf函数会使用到一块缓冲区，这块缓冲区是使用malloc或类似函数分配的一块静态内存。所以它是不可重入函数</p>
<h4 id="虚拟地址空间层次划分"><a href="#虚拟地址空间层次划分" class="headerlink" title="虚拟地址空间层次划分"></a>虚拟地址空间层次划分</h4><p>从操作系统层级上看，虚拟地址空间主要分为两个部分内核区和用户区。</p>
<p><strong>一、内核区</strong></p>
<ol>
<li>内核空间为内核保留，<strong>不允许应用程序读写该区域的内容</strong>或直接调用内核代码定义的函数</li>
<li><strong>内核总是驻留在内存中</strong>，是操作系统的一部分。</li>
<li>系统中<strong>所有进程</strong>对应的<strong>虚拟地址空间的内核区</strong>都会<strong>映射到同一块物理内存</strong>上（<strong>系统内核只有一个</strong>）</li>
</ol>
<p><strong>二、用户区</strong></p>
<p><strong>每个进程的虚拟地址空间都是从 0 地址开始的</strong>，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G（以 32 位系统的虚拟地址空间为例），里边分为多个区块。</p>
<p>各分区由低地址到高地址依次是：</p>
<ol>
<li><strong>保留区:</strong> 位于虚拟地址空间的最底部，<strong>未赋予物理地址</strong>。任何对它的引用都是非法的，程序中的<strong>空指针（NULL）指向的就是这块内存地址</strong>。</li>
<li><strong>.text段: 代码段也称正文段或文本段</strong>，通常用于存放程序的<strong>执行代码</strong> (即 CPU 执行的<strong>机器指令，二进制</strong>)，代码段一般情况下是<strong>只读</strong>的，这是对执行代码的一种保护机制。</li>
<li><strong>.data段</strong>: <strong>数据段</strong>通常用于存放程序中<strong>已初始化且初值不为 0 的全局变量和静态变量</strong>。数据段属于**静态内存分配 (静态存储区)**，可读可写。</li>
<li><strong>.bss段: 未初始化以及初始为 0 的全局变量和静态变量</strong>，操作系统会将这些<strong>未初始化变量初始化为 0</strong>；</li>
<li><strong>堆(heap)<strong>：用于存放进程运行时</strong>动态分配的内存</strong>。<ul>
<li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li>
<li>堆向高地址扩展 (即 “向上生长”)，是<strong>不连续</strong>的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而<strong>链表从低地址向高地址遍历</strong>。</li>
</ul>
</li>
<li><strong>内存映射区(mmap)：**作为内存映射区**加载磁盘文件**，或者</strong>加载程序运作过程中需要调用的动态库**。</li>
<li><strong>栈(stack):</strong> 存储<strong>函数内部声明的非静态局部变量，函数参数，函数返回地址等信息</strong>，栈内存由<strong>编译器自动分配释放</strong>。<strong>栈</strong>和堆相反地址 <strong>“向下生长”</strong>，分配的<strong>内存是连续</strong>的。</li>
<li><strong>命令行参数</strong>：存储进程执行的时候<strong>传递给 main() 函数的参数，argc，argv []</strong></li>
<li><strong>环境变量</strong>: 存储和进程相关的环境变量，比如：<strong>工作路径</strong>，<strong>进程所有者</strong>等信息</li>
</ol>
<h2 id="C函数记录"><a href="#C函数记录" class="headerlink" title="C函数记录"></a>C函数记录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>；</span><br><span class="line"></span><br><span class="line">第一个参数：（buffer）</span><br><span class="line">这个参数就是接收字符串的字符数组。其大小必须要大于所接收的字符串的大小，否则的话会有空间不够从而导致内存溢出的风险。（这里比较大小时还要考虑到字符串最后的 ‘\0’）</span><br><span class="line"></span><br><span class="line">第二个参数：（format）</span><br><span class="line">这个参数就是要传的字符串了。</span><br><span class="line"></span><br><span class="line">其余参数：</span><br><span class="line">剩下的参数其实算是对第二个参数format的补充，可有可无，视情况而定</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">perror(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">作用：调用系统或者库函数有错的时候，发出错误信息</span><br></pre></td></tr></table></figure>

<pre><code> sizeof 和strlen 有本质上的区别。sizeof 是C 语言的一种单目运算符，如++、–等，并不是函数，sizeof 的优先级为2 级，比/、% 等3 级运算符优先级高，sizeof以字节的形式给出操作数的存储空间的大小。而 strlen 是一个函数，是由 C 语言的标准库提供的。strlen 计算的 是字符串的长度。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format [, argument] … )</span>;</span><br><span class="line">    跟 <span class="built_in">printf</span> 在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出;</span><br><span class="line"><span class="number">1.</span> 可以用<span class="built_in">sprintf</span>来将其他类型转换字符串类想</span><br><span class="line"><span class="number">2.</span> 可以生成字符串，拼接 格式等</span><br><span class="line">     <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello,%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>输入一串格式化的字符串，经过处理后可以将 %s %f %d等占位符替换为对应的数据；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">… 表示函数的参数个数可变，典型的如<span class="built_in">printf</span>()</span><br><span class="line"></span><br><span class="line">第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>  <span class="comment">// 重载了func函数，不重载也行</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">char</span> *res = <span class="literal">NULL</span>; </span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    res = func(format, ap);  </span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> res ;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>        <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;函数与<span class="built_in">sprintf</span>()函数对应，只是在函数调用时，把上面的...对应的一个个变量用va_list调用所替代。在函数调用前ap要通过va_start()宏来动态获取。</span><br><span class="line"><span class="number">2.</span> 结构体va_list用来存参数列表，</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>  //<span class="title">I</span>/<span class="title">O</span> <span class="title">vector</span>，与<span class="title">readv</span>和<span class="title">wirtev</span>操作相关的结构体</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/uio.h&gt;</span><br><span class="line"><span class="comment">/* Structure for scatter/gather I/O. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">     <span class="type">void</span> *iov_base; <span class="comment">/* Pointer to data. */</span></span><br><span class="line">     <span class="type">size_t</span> iov_len; <span class="comment">/* Length of data. */</span></span><br><span class="line">&#125;;</span><br><span class="line">成员iov_base指向一个缓冲区，这个缓冲区是存放readv所接收的数据或是writev将要发送的数据。</span><br><span class="line">成员iov_len确定了接收的最大长度以及实际写入的长度。   </span><br><span class="line">readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）</span><br><span class="line">    </span><br><span class="line">HTTP响应的时候配合writev(),写入响应头和体</span><br><span class="line">    writev(m_sockfd,m_iv,m_iv_count);</span><br></pre></td></tr></table></figure>







</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://forthdifferential.github.io">陈锴烺</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://forthdifferential.github.io/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">https://forthdifferential.github.io/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://forthdifferential.github.io" target="_blank">个人主页</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/imgs/$%7Bfiilename%7D/wangluobiancheng.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">陈锴烺</div><div class="author-info__description">Every man is the master of his own fortune.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/forthdifferential"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/forthdifferential" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:klchen_auto@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><b>---Welcome to my blog---<br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="toc-text">1. Linux系统编程入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC"><span class="toc-text">GCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93"><span class="toc-text">库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">动态库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MakeFile"><span class="toc-text">MakeFile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#makefile%E6%96%87%E4%BB%B6%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-text">makefile文件书写规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB"><span class="toc-text">GDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E5%87%BD%E6%95%B0"><span class="toc-text">Linux系统的IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-text">open函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">创建文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-text">read函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-text">write函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lseek%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB"><span class="toc-text">lseek移动文件指针偏移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stat%E5%87%BD%E6%95%B0"><span class="toc-text">stat函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stat%E5%87%BD%E6%95%B0-lstat%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-text">stat函数 lstat函数获取文件信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">文件属性操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#access%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%88%96%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">access判断文件权限或文件是否存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#chmod%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-text">chmod函数修改文件权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#truncate%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%B0%BA%E5%AF%B8"><span class="toc-text">truncate修改文件尺寸</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">目录操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mkdir%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">mkdir函数创建目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#chdir%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">chdir修改进程工作目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getcwd%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-text">getcwd获取当前目录</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%87%BD%E6%95%B0"><span class="toc-text">目录遍历函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#opendir"><span class="toc-text">opendir()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#readdir"><span class="toc-text">readdir()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#closedir"><span class="toc-text">closedir()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F"><span class="toc-text">应用-统计某个目录下文件数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">文件描述符操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dup-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E5%A4%8D%E5%88%B6-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">dup()文件描述符 复制 - 浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dup2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">dup2()文件描述符 重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fcntl-%E5%87%BD%E6%95%B0-%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">fcntl()函数 控制文件描述符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">2. Linux多进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2-%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4"><span class="toc-text">2.1进程状态转换  -终端指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">2.2进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fork-%E5%87%BD%E6%95%B0"><span class="toc-text">fork()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">gdb调试父子进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-text">exec函数族</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-text">2.3 进程退出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-text">进程回收</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#wait-%E5%87%BD%E6%95%B0"><span class="toc-text">wait()函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-text">2.5 内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">使用内存映射实现进程间通信：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%B1%BB%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">关系类进程通信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E7%B1%BB%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">非关系类进程通信</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">内存映射注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-text">使用内存映射实现文件的拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-text">匿名内存映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.6 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-text">信号集函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigprocmask-%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">sigprocmask() 修改内核阻塞信号集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigaction-%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="toc-text">sigaction()信号捕捉函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7-%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">SIGCHLD信号 - 回收子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SIGCHLD-%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B-%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E9%85%8D%E5%90%88waitpid%E6%9D%A5%E6%89%B9%E9%87%8F%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">2.8共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">共享内存使用步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-text">共享内存函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">共享内存操作命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">基础问题：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">2.9守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF"><span class="toc-text">终端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-text">会话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-text">守护进程创建步骤</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="toc-text">3.Linux多线程开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">线程与进程的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">3.2线程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-text">线程退出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%B7%B2%E7%BB%88%E6%AD%A2%E7%9A%84%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-text">连接已终止的线程 - 线程回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="toc-text">线程分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="toc-text">线程取消</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">线程属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">3.3线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-text">生产者消费者模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">4.Linux网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-text">4.1网络基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">4.2 socket通信基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#socket%E7%AE%80%E4%BB%8B"><span class="toc-text">socket简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">字节序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">字节序转换函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80"><span class="toc-text">socket地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-text">通用socket地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-text">专用socket地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.3 IP地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">4.4TCP通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">TCP通信流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-text">4.4套接字函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-TCP%E9%80%9A%E4%BF%A1%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.5 TCP通信并发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1-%E5%8D%95%E8%BF%9E"><span class="toc-text">TCP通信 单连</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E4%BD%9C%E4%B8%9A-%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5%E5%B9%B6%E4%B8%94%E5%9B%9E%E5%B0%84"><span class="toc-text">小作业-读取输入并且回射</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E5%A4%B4"><span class="toc-text">TCP报文头</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">三次握手连接过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">TCP滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">多进程实现并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#server-process"><span class="toc-text">server_process</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#client"><span class="toc-text">client</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">多线程实现并发服务器 - 类似于线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#server-process-1"><span class="toc-text">server_process</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#client-%E5%92%8C%E5%89%8D%E9%9D%A2%E4%B8%80%E6%A0%B7"><span class="toc-text">client - 和前面一样</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">TCP状态转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-text">端口复用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">4.6  IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">IO多路复用概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-text">select</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#select%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="toc-text">select实现多路转接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#poll%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="toc-text">poll实现多路转接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#epoll%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="toc-text">epoll实现多路转接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Epoll%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">Epoll的工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91-%E9%BB%98%E8%AE%A4"><span class="toc-text">水平触发 - 默认</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91-EPOLLET"><span class="toc-text">边沿触发 - EPOLLET</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-UDP%E9%80%9A%E4%BF%A1"><span class="toc-text">4.7  UDP通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">UDP实现流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-text">广播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%EF%BC%88%E5%A4%9A%E6%92%AD%EF%BC%89"><span class="toc-text">组播（多播）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">4.8 本地套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-WebServer%E9%A1%B9%E7%9B%AE"><span class="toc-text">5.WebServer项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="toc-text">5.1 阻塞非阻塞、同步异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Unix-x2F-Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.2 Unix&#x2F;Linux上的五种IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E9%98%BB%E5%A1%9E-blocking"><span class="toc-text">a.阻塞 blocking</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E9%9D%9E%E9%98%BB%E5%A1%9E-non-blocking%EF%BC%88NIO%EF%BC%89"><span class="toc-text">b.非阻塞 non-blocking（NIO）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-IO%E5%A4%8D%E7%94%A8%EF%BC%88IO-multiplexing%EF%BC%89"><span class="toc-text">c.IO复用（IO multiplexing）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%EF%BC%88signal-driven%EF%BC%89"><span class="toc-text">d.信号驱动（signal-driven）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-%E5%BC%82%E6%AD%A5%EF%BC%88asynchronous%EF%BC%89"><span class="toc-text">e.异步（asynchronous）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Web-Server%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">5.3 Web Server网页服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-text">网页服务器简介</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-text">响应报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">http状态码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">事件处理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">Reactor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Proactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">Proactor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-Proactor-%E6%A8%A1%E5%BC%8F"><span class="toc-text">模拟 Proactor 模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EPOLLONESHOT%E4%BA%8B%E4%BB%B6"><span class="toc-text">EPOLLONESHOT事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">有限状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-text">服务器压力测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ubuntu%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">Ubuntu一些小操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">文本文件上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%A0%BC%E5%BC%8F"><span class="toc-text">修改格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%B1%BB"><span class="toc-text">命令类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BD%92%E6%A1%A3"><span class="toc-text">1. 归档</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B"><span class="toc-text">2. 压缩解压</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7z"><span class="toc-text">7z</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-text">查看当前进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%BE%E5%87%BD%E6%95%B0"><span class="toc-text">找函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">查看网络相关信息的命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-text">小知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Core%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">利用Core文件查看异常的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE"><span class="toc-text">Linux下的时间设置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">前后台进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E9%94%99%E8%AF%AF%E7%A9%B6%E7%AB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F%E6%AE%B5%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%8D%E7%8E%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E9%9A%BE%EF%BC%9F"><span class="toc-text">段错误究竟是怎么发生的？段错误的复现为什么这么难？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86"><span class="toc-text">虚拟地址空间层次划分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95"><span class="toc-text">C函数记录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">可变参数</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - GFS论文阅读"><img src="/imgs/$%7Bfiilename%7D/GFS/image-20230411161308484.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - GFS论文阅读"/></a><div class="content"><a class="title" href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - GFS论文阅读">分布式 - GFS论文阅读</a><time datetime="2023-11-21T11:01:26.674Z" title="发表于 2023-11-21 19:01:26">2023-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - MapReduce论文阅读"><img src="/imgs/$%7Bfiilename%7D/MapReduce/image-20230329113648794.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - MapReduce论文阅读"/></a><div class="content"><a class="title" href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - MapReduce论文阅读">分布式 - MapReduce论文阅读</a><time datetime="2023-11-21T09:01:33.208Z" title="发表于 2023-11-21 17:01:33">2023-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/" title="MySql - MySql必知必会记录"><img src="/imgs/$%7Bfiilename%7D/mysqlbizhibihui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql - MySql必知必会记录"/></a><div class="content"><a class="title" href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/" title="MySql - MySql必知必会记录">MySql - MySql必知必会记录</a><time datetime="2023-11-14T13:39:06.803Z" title="发表于 2023-11-14 21:39:06">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" title="MySql - MySql数据库运行原理"><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/title.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql - MySql数据库运行原理"/></a><div class="content"><a class="title" href="/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" title="MySql - MySql数据库运行原理">MySql - MySql数据库运行原理</a><time datetime="2023-11-14T07:44:37.544Z" title="发表于 2023-11-14 15:44:37">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux - Linux网络编程"><img src="/imgs/$%7Bfiilename%7D/wangluobiancheng.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux - Linux网络编程"/></a><div class="content"><a class="title" href="/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux - Linux网络编程">Linux - Linux网络编程</a><time datetime="2023-11-14T07:12:13.923Z" title="发表于 2023-11-14 15:12:13">2023-11-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 陈锴烺</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>