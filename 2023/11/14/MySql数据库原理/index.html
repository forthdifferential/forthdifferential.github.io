<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySql - MySql数据库运行原理 | 个人主页</title><meta name="author" content="陈锴烺"><meta name="copyright" content="陈锴烺"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQl是怎么运行的 1.初始部分mysqld 可执行文件 服务器程序服务器相关的mysqld mysqld_safe客户端相关mysql mysqladmin 默认InnoDB  外键支持的功能的事务存储引擎 MyISAM      主要的非事务处理存储引擎 Memory      至于内存的表 CS进程间通信方式 TCP&#x2F;IP方式： mysql -h127.0.0.1 -uroot">
<meta property="og:type" content="article">
<meta property="og:title" content="MySql - MySql数据库运行原理">
<meta property="og:url" content="https://forthdifferential.github.io/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="个人主页">
<meta property="og:description" content="MySQl是怎么运行的 1.初始部分mysqld 可执行文件 服务器程序服务器相关的mysqld mysqld_safe客户端相关mysql mysqladmin 默认InnoDB  外键支持的功能的事务存储引擎 MyISAM      主要的非事务处理存储引擎 Memory      至于内存的表 CS进程间通信方式 TCP&#x2F;IP方式： mysql -h127.0.0.1 -uroot">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://forthdifferential.github.io/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/title.png">
<meta property="article:published_time" content="2023-11-14T07:44:37.544Z">
<meta property="article:modified_time" content="2023-11-14T13:20:29.368Z">
<meta property="article:author" content="陈锴烺">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://forthdifferential.github.io/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/title.png"><link rel="shortcut icon" href="/imgs/head.ico"><link rel="canonical" href="https://forthdifferential.github.io/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySql - MySql数据库运行原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-14 21:20:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="个人主页"><span class="site-name">个人主页</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">MySql - MySql数据库运行原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-14T07:44:37.544Z" title="发表于 2023-11-14 15:44:37">2023-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-14T13:20:29.368Z" title="更新于 2023-11-14 21:20:29">2023-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySql - MySql数据库运行原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>MySQl是怎么运行的</p>
<h2 id="1-初始部分"><a href="#1-初始部分" class="headerlink" title="1.初始部分"></a>1.初始部分</h2><p>mysqld 可执行文件 服务器程序<br>服务器相关的mysqld mysqld_safe客户端相关mysql mysqladmin</p>
<p>默认InnoDB  外键支持的功能的事务存储引擎</p>
<p>MyISAM      主要的非事务处理存储引擎</p>
<p>Memory      至于内存的表</p>
<h3 id="CS进程间通信方式"><a href="#CS进程间通信方式" class="headerlink" title="CS进程间通信方式"></a>CS进程间通信方式</h3><ul>
<li>TCP&#x2F;IP方式： mysql -h127.0.0.1 -uroot -P3306 -p</li>
<li>windowOS 的一台主机：命名管道和共享内存</li>
<li>类Unix的一台主机：套接字</li>
</ul>
<h3 id="服务器处理客户端的查询请求流程"><a href="#服务器处理客户端的查询请求流程" class="headerlink" title="服务器处理客户端的查询请求流程"></a>服务器处理客户端的查询请求流程</h3><h4 id="连接管理："><a href="#连接管理：" class="headerlink" title="连接管理："></a>连接管理：</h4><p>S端创建线程处理交互； </p>
<ul>
<li>1.限制连接C端数量；2.断开后线程不销毁，另一个C端连接时分配；3，携带主机各类信息发起连接 ，用SSL通信保证数据传输安全性</li>
</ul>
<h4 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h4><ol>
<li>查询缓存：MySQL8.0删除，因为维护缓存开销</li>
<li>语法解析：编译过程：词法解析 语法解析 语义分析（编译原理）</li>
<li>查询优化：优化语句，提高效率（类似以扁平化）</li>
</ol>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>功能：物理上如何存储、读取、写入、表示记录；</p>
<p>向上提供存储引擎API</p>
<ul>
<li>默认的存储引擎InnoDB，主要还有MyISAM、Memory</li>
</ul>
<h2 id="2-启动选项和系统变量"><a href="#2-启动选项和系统变量" class="headerlink" title="2. 启动选项和系统变量"></a>2. 启动选项和系统变量</h2><h3 id="命令行上使用选项（当次启动生效）"><a href="#命令行上使用选项（当次启动生效）" class="headerlink" title="命令行上使用选项（当次启动生效）"></a>命令行上使用选项（当次启动生效）</h3><ul>
<li><p>在选项名前加上 –前缀</p>
</li>
<li><p>短形式简化启动选项，短选项名与值之间可以没有间隙</p>
</li>
</ul>
<h3 id="配置文件中使用选项（本机修改）"><a href="#配置文件中使用选项（本机修改）" class="headerlink" title="配置文件中使用选项（本机修改）"></a>配置文件中使用选项（本机修改）</h3><h3 id="系统变量-VARIABLES"><a href="#系统变量-VARIABLES" class="headerlink" title="系统变量 VARIABLES"></a>系统变量 VARIABLES</h3><p>作用范围：全局GLOBAL启动选项、会话SESSION;</p>
<p>SET GLOBAL default_storage_engine &#x3D; MyISAM;</p>
<p>SET SESSION default_storage_engine &#x3D; MyISAM;</p>
<ul>
<li>默认的作用范围是SESSION</li>
</ul>
<h3 id="状态变量-STATUS"><a href="#状态变量-STATUS" class="headerlink" title="状态变量 STATUS"></a>状态变量 STATUS</h3><p>SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</p>
<h2 id="3-字符集和比较规则"><a href="#3-字符集和比较规则" class="headerlink" title="3.字符集和比较规则"></a>3.字符集和比较规则</h2><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><ul>
<li><p>ASCII字符集128 1字节；</p>
</li>
<li><p>GB2312&#x2F;GBK字符集 对ASCII字符集采用1字节，否则2字节</p>
</li>
<li><p>Unicode也是一种字符编码方法，容纳全世界所有语言文字的编码方,UCS只是规定如何编码，并没有规定如何传输、保存这个编码。而我们熟悉的<strong>UTF-8 UTF-16 UTF-32是Unicode的具体实现</strong>(怎么存储在计算机)</p>
<p>UTF8变长编码方式，1-4字节，MySQL中utf8为1-3，utf8mb4为1-4字节；</p>
<p><strong>用途</strong>：</p>
<ol>
<li><p>可以用来确定数据的存储空间</p>
</li>
<li><p>编码和解码方式不一致导致乱码；常见的有UTF-8书写的用GBK解码，导致中文乱码</p>
</li>
<li><p>解码后，可以字符集转换；</p>
<ul>
<li>类 Unix系统使用的是 utf8</li>
<li>Windows使用的是 gbk</li>
<li>CS通信采用的系统变量规定</li>
</ul>
<p>character_set_clientS收到后解码方式；<br>character_set_connectionS转换类型；<br> character_set_resultsS返回数据编码方式</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230212171538207.png" alt="image-20230212171538207"></p>
</li>
</ol>
</li>
</ul>
<h4 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h4><p>SHOW COLLATION [LIKE 匹配的模式]</p>
<ul>
<li>服务器级别 数据库基本 表级别 列级别</li>
<li>排序时比较 SELECT * FROM t ORDER BY s;</li>
</ul>
<h2 id="4-InnoDB记录结构"><a href="#4-InnoDB记录结构" class="headerlink" title="4.InnoDB记录结构"></a>4.InnoDB记录结构</h2><p>将数据划分若干页，页作为磁盘和内存交换的基本单位，InnoDB页的大小一般为16KB</p>
<h3 id="四种行格式ROW-FORMAT-："><a href="#四种行格式ROW-FORMAT-：" class="headerlink" title="四种行格式ROW_FORMAT ："></a>四种行格式ROW_FORMAT ：</h3><p>Compact、Redundant、Dynamic、Compressed，之后可能还会再加其他的但是原理相同；</p>
<h3 id="Compact示例"><a href="#Compact示例" class="headerlink" title="Compact示例"></a>Compact示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE record_format_demo (</span><br><span class="line"> -&gt; c1 VARCHAR(10),</span><br><span class="line"> -&gt; c2 VARCHAR(10) NOT NULL,</span><br><span class="line"> -&gt; c3 CHAR(10),</span><br><span class="line"> -&gt; c4 VARCHAR(10)</span><br><span class="line"> -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230212210043291.png" alt="image-20230212210043291"></p>
<h4 id="1-变长字段部分"><a href="#1-变长字段部分" class="headerlink" title="1. 变长字段部分"></a>1. 变长字段部分</h4><p>VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类型等存储字节数据不固定，称为<strong>变长字段</strong>；</p>
<p>变长字段占用包括（真正数据内容+占用字节数），这个占用的字节数就放在这部分中。</p>
<ul>
<li>逆序存放</li>
<li>只存非NULL</li>
<li>按照W*M和L比较，选择1或2字节</li>
<li>高位补0</li>
</ul>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816114943613.png" alt="image-20230816114943613"></p>
<h4 id="2-NULL值列表"><a href="#2-NULL值列表" class="headerlink" title="2. NULL值列表"></a>2. NULL值列表</h4><p>（去掉强制非NULL）二进制位逆序排列，高位补0</p>
<h4 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h4><ul>
<li><p>5固定是5字节，40个二进制位表示</p>
</li>
<li><p>不同的位表示不同的意思（当前记录的位置信息、是否被使用、删除等）</p>
</li>
<li><p>类似表头信息</p>
</li>
</ul>
<h4 id="4-还有一些隐藏列"><a href="#4-还有一些隐藏列" class="headerlink" title="4. 还有一些隐藏列"></a>4. 还有一些隐藏列</h4><ol>
<li><p>InnoDB自动添加transaction_id事务ID、roll_pointer回滚指针</p>
</li>
<li><p>InnoDB默认添加row_id作为主键，但是用户自定义了就不添加</p>
</li>
</ol>
<h4 id="5-真实数据"><a href="#5-真实数据" class="headerlink" title="5. 真实数据"></a>5. 真实数据</h4><p>按照列号顺序存入，字符集相关</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816145752286.png" alt="image-20230816145752286"></p>
<h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816145852582.png" alt="image-20230816145852582"></p>
<ul>
<li><p>把记录中所有列的长度信息都按照逆序存储，按照偏移存储</p>
</li>
<li><p>一种比较简单粗暴的格式，所以现在不常用</p>
</li>
</ul>
<h3 id="行溢出：一条记录占用的最大存储空间超出"><a href="#行溢出：一条记录占用的最大存储空间超出" class="headerlink" title="行溢出：一条记录占用的最大存储空间超出"></a>行溢出：一条记录占用的最大存储空间超出</h3><ul>
<li>溢出页+指针</li>
<li>一个页一般是<strong>16KB</strong> 记录太多或者记录太大， 当前页存不下，多于数据存储到其他页，叫行溢出</li>
<li>要记住一行中国所有列占用的字节长度记起来不超过65535字节</li>
<li>对于占用存储空间非常大的列，在记录真是数据处只会存储该列的一部分数据，把剩余的数据分散存储在其他几个页中，然后记录的真是数据处用20个字节存储指向这些页的地址</li>
<li>MySQL规定一个页中至少存放两行数据</li>
</ul>
<h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>和Compact像，但是处理行溢出的时候，把所有的数据都放在溢出页</p>
<h2 id="5-InnoDB数据页结构"><a href="#5-InnoDB数据页结构" class="headerlink" title="5.InnoDB数据页结构"></a>5.InnoDB数据页结构</h2><p>索引页（数据页）：存放表中记录的那种类型的页</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816152404384.png" alt="image-20230816152404384"></p>
<ul>
<li>数据插入过程就是从Free Space划分空间，写入记录，放到User Records的部分。</li>
<li>当Free Space用完了，就是本页使用完了</li>
</ul>
<h4 id="记录的位置"><a href="#记录的位置" class="headerlink" title="记录的位置"></a>记录的位置</h4><ul>
<li>heap_no表示记录在本页中的位置，但是0 Infimum和 1 Supermum是伪记录，由页给出</li>
<li>用next_record指向下一条记录。所以一个页中的记录用单链表表示连接起来</li>
</ul>
<p>如何查找一个记录：</p>
<ol>
<li>将页中记录分为几个组，<strong>每组的最后一条记录地址偏移量存在Page Directory页目录</strong>（槽）</li>
<li>n_owned表示以此结尾的组的记录数。InnoDB规定最小记录结尾分组只有1条，最大记录结尾分组有1-8条，剩下分组时4-8条之间。</li>
</ol>
<h5 id="添加记录条的过程："><a href="#添加记录条的过程：" class="headerlink" title="添加记录条的过程："></a>添加记录条的过程：</h5><p>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。<br>之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。<br>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在 页目录 中<strong>新增一个 槽</strong> 来记录这个新增分组中最大的那条记录的偏移量。</p>
<h5 id="一个数据页中查找指定主键值的记录过程："><a href="#一个数据页中查找指定主键值的记录过程：" class="headerlink" title="一个数据页中查找指定主键值的记录过程："></a>一个数据页中查找指定主键值的记录过程：</h5><ol>
<li>二分查找所在的槽，找到槽中最小记录</li>
<li>next_record属性遍历槽所在的组中的各个记录</li>
</ol>
<h2 id="6-B-数索引"><a href="#6-B-数索引" class="headerlink" title="6. B+数索引"></a>6. B+数索引</h2><p>前提保证：下一个数据页中记录的主键值必须大于上一个页中用户记录的主键值（页分裂）。</p>
<p>把每个页的最小主键值和页号合在一起，列一个目录，成为索引。这样的页是<strong>索引页</strong>，其中记录是索引record_type &#x3D; 1。索引页信息提取后放大更高级的目录项，依次层级递推，就是一个B+树。一般不超过4层</p>
<h4 id="聚簇索引："><a href="#聚簇索引：" class="headerlink" title="聚簇索引："></a>聚簇索引：</h4><ol>
<li>使用记录的主键值的大小进行记录和页的排序：页内记录组成单向链表；存放用户记录的页也组成双向链表；存放目录项记录的页分为不同层次，在同一层次中的页根据页中目录项记录的主键大小排序组成双向链表。</li>
<li>B+树叶子结点是完整的用户记录</li>
</ol>
<p>InnoDB自动创建的结构，索引即数据</p>
<h4 id="二级索引："><a href="#二级索引：" class="headerlink" title="二级索引："></a>二级索引：</h4><p>根据非主键查找，就需要建立另一棵树，键是查找列，值是主键。</p>
<ol>
<li>同样的方法查找叶子结点的记录，找到主键值</li>
<li>按照主键再索引一遍，找到完整记录（回表）</li>
</ol>
<p>回表是为了减少建第二颗树存完整数据的所占的空间。</p>
<h4 id="联合索引："><a href="#联合索引：" class="headerlink" title="联合索引："></a>联合索引：</h4><p>先把各个记录和页按照 c2 列进行排序；<br>在记录的 c2 列相同的情况下，采用 c3 列进行排序</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li>根页面一直不动，先创建B+树缩影，然后添加记录、多了分页作为索引页，但是根节点不会移动</li>
<li>页节点中记录项记录的唯一性，在目录项记录的内容是主键+索引列+页号，来保证唯一性</li>
<li>一个页面至少存两条记录</li>
</ol>
<h3 id="MyISAM中索引方案"><a href="#MyISAM中索引方案" class="headerlink" title="MyISAM中索引方案"></a>MyISAM中索引方案</h3><ul>
<li>记住MySIAM和InnoDB区别是他把索引和数据分开存储</li>
</ul>
<ol>
<li>数据文件：按照插入的顺序把记录单独存储在一个文件。</li>
<li>B+树，根节点是行号而非完整数据。</li>
</ol>
<ul>
<li>建立的索引，相当于全是二级索引，因为要回表找完整的数据</li>
</ul>
<h3 id="创建和删除索引"><a href="#创建和删除索引" class="headerlink" title="创建和删除索引"></a>创建和删除索引</h3><p>InnoDB和MyISAM会<code>自动</code>为<strong>主键或UNIQUE列</strong>生成B+树索引。</p>
<p>其他需求，声明建立B+树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TALBE 表名 (</span><br><span class="line"> 各种列的信息 ··· , </span><br><span class="line"> [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX idx_c2_c3 (c2, c3)                    //创建联合声明</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE index_demo DROP INDEX idx_c2_c3       //删除索引</span><br></pre></td></tr></table></figure>

<h2 id="7-B-树索引的使用"><a href="#7-B-树索引的使用" class="headerlink" title="7. B+树索引的使用"></a>7. B+树索引的使用</h2><h3 id="索引代价"><a href="#索引代价" class="headerlink" title="索引代价"></a>索引代价</h3><ol>
<li>空间上建树，数据页代价</li>
<li>时间上CRUD需要修改索引，为了维护排序需要移位操作</li>
</ol>
<h3 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h3><p>建立了联合索引后，可以适用以下情况：</p>
<ol>
<li><p>全值匹配</p>
</li>
<li><p>匹配左边的列</p>
</li>
<li><p>列前缀 （英文前缀n个字符</p>
</li>
<li><p>匹配范围值</p>
</li>
<li><p>精确匹配某一列，范围匹配另一列</p>
</li>
<li><p>用于排序，用联合索引必须<strong>按照几个列的顺序</strong>，因为有比较的优先级；但是几个变量选择ASC、DESC混用的情况不能，也就是联合索引的各个排序列的<strong>排序顺序必须一致</strong>；不能用修饰过的表达式（无法比较）</p>
</li>
<li><p>用于分组，要求和排序差不多</p>
</li>
</ol>
<h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>联合索引中，二级索引查找读取主键，因为是顺序IO快，但是按主键聚簇索引是随机IO慢。</p>
<p>如果需要回表的记录数很多，倾向于全表扫描：</p>
<ol>
<li>一般加LIMIT多少就倾向于二级索引+回表</li>
<li>有排序需求也是满足这类讨论</li>
</ol>
<ul>
<li>为了去掉回表的性能损耗，建议<strong>只查索引列</strong>，这样告别了回表，称为<code>覆盖索引</code></li>
</ul>
<h3 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h3><h4 id="1-只为搜索、排序、分组的列创建"><a href="#1-只为搜索、排序、分组的列创建" class="headerlink" title="1. 只为搜索、排序、分组的列创建"></a>1. 只为搜索、排序、分组的列创建</h4><p>只是查询就没必要，只需要为出现在WHERE句子中的列、连接子句中的连接列，或者ORDER BY、GROUP BY子句中列创建索引。</p>
<h4 id="2-列的基数越大于好"><a href="#2-列的基数越大于好" class="headerlink" title="2. 列的基数越大于好"></a>2. 列的基数越大于好</h4><p>基数就是去掉重复数，重复太多不好排序</p>
<h4 id="3-索引列的类型尽量小"><a href="#3-索引列的类型尽量小" class="headerlink" title="3. 索引列的类型尽量小"></a>3. 索引列的类型尽量小</h4><p>类型表示的数据范围小，CPU查询快，存储空间小，页可以放更多的记录</p>
<h4 id="4-索引字符串值的前缀"><a href="#4-索引字符串值的前缀" class="headerlink" title="4.索引字符串值的前缀"></a>4.索引字符串值的前缀</h4><p>只对字符串的前几个字符进行索引，这样节约空间、比较时间、解决排序问题</p>
<h4 id="5-索引列在比较表达式单独出现"><a href="#5-索引列在比较表达式单独出现" class="headerlink" title="5.索引列在比较表达式单独出现"></a>5.索引列在比较表达式单独出现</h4><p>如果是表达式的形式，而不是单独列出现，不能用到索引（引擎没有前处理优化）</p>
<h4 id="6-主键插入顺序"><a href="#6-主键插入顺序" class="headerlink" title="6.主键插入顺序"></a>6.主键插入顺序</h4><p>最好是从小到大插入，如果是随机等，插入过程需要性能损耗</p>
<h4 id="7-不要冗余或者重复索引"><a href="#7-不要冗余或者重复索引" class="headerlink" title="7.不要冗余或者重复索引"></a>7.不要冗余或者重复索引</h4><h4 id="8-尽量使用覆盖索引避免回表"><a href="#8-尽量使用覆盖索引避免回表" class="headerlink" title="8.尽量使用覆盖索引避免回表"></a>8.尽量使用覆盖索引避免回表</h4><h2 id="8-MySQL的数据目录"><a href="#8-MySQL的数据目录" class="headerlink" title="8.MySQL的数据目录"></a>8.MySQL的数据目录</h2><p>InnoDB和MyISAM是把表存在文件系统上的，然后读写页</p>
<h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><p>数据库程序启动的时候在目录下加载文件，在运行时产生的数据存储到目录的文件中。区别于安装目录</p>
<h4 id="数据库在文件中的表示"><a href="#数据库在文件中的表示" class="headerlink" title="数据库在文件中的表示"></a>数据库在文件中的表示</h4><ul>
<li>每个数据库对应数据目录下一个子目录，或者说文件夹，其下还有db.opt文件，包含数据库的各种数学，比如字符集和比较规则</li>
</ul>
<p>InnoDB的索引即数据：其包含的表空间：系统表空间、独立表空间、其他类型的</p>
<blockquote>
<p>对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为 表名.ibd 的实际文件。</p>
</blockquote>
<p>MyISAM分开存储：.MYD是数据 .MYI是索引文件</p>
<h4 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h4><p><strong>视图</strong>是虚拟的表，在其数据库下，也需要存储起来，视图名.frm</p>
<p>数据库进程文件</p>
<p>数据库日志文件：查询日志、错误日志、二进制日志、redo日志</p>
<p>默认&#x2F;自动生成的SSL和RSA证书和秘钥文件</p>
<h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><strong>mysql</strong><br>核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过<br>程中产生的日志信息，一些帮助信息以及时区信息等</p>
<p><strong>information_schema</strong><br>MySQL服务器维护的<strong>所有其他数据库的信息</strong>，比如有哪些表、哪些视图、哪些触发器、哪些列。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。</p>
<p><strong>performance_schema</strong><br>存MySQL服务器<strong>运行过程中的一些状态信息</strong>，算是对MySQL服务器的一个性能监控。<br>包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p>
<p><strong>sys</strong><br>这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</p>
<h2 id="9-InnoDB的表空间-不太熟再看看"><a href="#9-InnoDB的表空间-不太熟再看看" class="headerlink" title="9.InnoDB的表空间 不太熟再看看"></a>9.InnoDB的表空间 不太熟再看看</h2><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><p>ALLOCATED 分配还未使用</p>
<p>INDEX 索引页，数据页</p>
<h3 id="页面通用部分"><a href="#页面通用部分" class="headerlink" title="页面通用部分"></a>页面通用部分</h3><p>FileHeader 包含页号、检验和、类型、next、prev</p>
<p>主体</p>
<p>FileTrailer 校验页面是否完整，保证内存到磁盘刷新时内容一致性</p>
<h3 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h3><p>独立表空间和系统表空间中，64页是一个区，256区是一个组；</p>
<p>每个组的最开始几个页面类型固定，表示一些属性信息；</p>
<h4 id="区、段的概念："><a href="#区、段的概念：" class="headerlink" title="区、段的概念："></a>区、段的概念：</h4><p>因为随机访问内存损耗，且磁盘读取很慢，所以数据量大的时候可以用<strong>区</strong>为分配单位。</p>
<p>叶子结点有独有的区，区的集合称为<strong>段</strong>，非叶子节点也有段。</p>
<p>但是数据量小的表用整个区浪费存储空间，会设置<strong>碎片区</strong>，碎片区直属于表空间</p>
<ul>
<li>首先插入数据，段式从碎片区以页面为单位分配存储空间</li>
<li>段已经占了32个碎片区页面后，单独以完整的为范围分配存储空间</li>
</ul>
<p><strong>目的：提高表插入数据的效率，又不至于数据量少的表浪费空间</strong></p>
<h4 id="区的分类："><a href="#区的分类：" class="headerlink" title="区的分类："></a>区的分类：</h4><p>FREE、 FREE_FRAG、 FULL_FRAG、FSEC（附属于某个段了）：前三个直属于表空间</p>
<ol>
<li><p>表空间由若干区组成，每个区有一个XDES Entry结构，直属于表空间的区对应XDES Entry结构分为FREE、 FREE_FRAG、 FULL_FRAG三个链表；</p>
</li>
<li><p>每个段附属于若干区，每个段中的区对应的XDES Entry结构分为FREE、NOT_FULL、FULL 3个链表。每个链表对应一个List Base Node的结构，和这个机构记录俩表的头、尾节点，以及节点数。来管理这些区。</p>
</li>
</ol>
<p>举例：一个表有两个索引，聚簇和二级索引，那就有4个段，12个上述段相关区的链表，加上3个直属于表空间的三个链表，共15个链表。</p>
<h4 id="段的分类："><a href="#段的分类：" class="headerlink" title="段的分类："></a>段的分类：</h4><p>段是一个逻辑上的概念，由若干零散的页面和一些完整的区组成。</p>
<p>也有一个INODE Entry结构记录段中的属性</p>
<p>也有List Base Node记录三个链表的信息</p>
<h4 id="各类页面的详细情况"><a href="#各类页面的详细情况" class="headerlink" title="各类页面的详细情况"></a>各类页面的详细情况</h4><p>表空间的第一个组的第一个页面FSP_HDR描述了区的信息，也就是包含很多XDES Entry</p>
<p>第二个页面是IBUF_BITMAP信息，记录关于Change Buffer东西</p>
<p>第三个页面是INODE，为了存储 INODE Entry 结构而存在的</p>
<h4 id="Segment-Header"><a href="#Segment-Header" class="headerlink" title="Segment Header"></a>Segment Header</h4><p>把段和INDOE Entry对应起来的方法：在<strong>数据页</strong>的PageHeader中有两个Segment Header结构，记录着叶子结点和非叶子结点的头部信息（两个段），去定位INODE Entry：哪个表空间的哪个页面的哪个偏移量</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230826154746003.png" alt="image-20230826154746003" style="zoom:50%;" />



<h3 id="系统表空间结构"><a href="#系统表空间结构" class="headerlink" title="系统表空间结构"></a>系统表空间结构</h3><p>表空间ID是0，开头有许多记录整个系统属性的页面。</p>
<p>每次向表插入记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。</p>
<p>所以需要些额外的信息，叫做<strong>元数据</strong>，InnoDB定义了一些列的<strong>内部系统表</strong>（数据字典）记录。</p>
<p><strong>基本系统表：</strong></p>
<p>SYS_TABLES 整个InnoDB存储引擎中所有的表的信息<br>SYS_COLUMNS 整个InnoDB存储引擎中所有的列的信息<br>SYS_INDEXES 整个InnoDB存储引擎中所有的索引的信息<br>SYS_FIELDS 整个InnoDB存储引擎中所有的索引对应的列的信息</p>
<ul>
<li><p>有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。</p>
</li>
<li><p>Data Dictionary Header页面是页号为7的SYS类型页面，记录了这4个表的5个索引的根页面信息和一些全局信息</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>区、段、记录区entry的表、记录段entry的表，段到分配区的链表，把数据页和段联系起来的segment header；</p>
<p>记录系统的表，表的索引页Data dictionary header；</p>
<h2 id="10-单表查询的方法"><a href="#10-单表查询的方法" class="headerlink" title="10. 单表查询的方法"></a>10. 单表查询的方法</h2><p>数据库的<strong>查询优化器</strong>的自动查询方式：全表扫描、索引查询。具体类型分为以下</p>
<blockquote>
<p>注：UNIQUE唯一索引可以用于确保表中某一列或列组的数值唯一性约束，以便在查询和筛选数据时提高性能和准确性。当你尝试在已存在的唯一索引中插入重复值时，数据库会返回错误。</p>
</blockquote>
<h3 id="const常数级别"><a href="#const常数级别" class="headerlink" title="const常数级别"></a>const常数级别</h3><p>通过主键或者唯一二级索引列（多列的话，每一列都要与常数等值比较）定位一条记录的方法。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>普通的二级索引列与常数<code>等值</code>比较。</p>
<p>因为可能找到多条对应记录，如果记录少选择索引，而不是全表扫描时</p>
<ul>
<li>NULL值二级索引，NULL可能有多个所以是ref</li>
</ul>
<h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出<br>来</p>
<p>使用二级索引而不是全表扫描的方式执行该查询时，称为ref_or_null</p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>索引列需要匹配某个或某些范围的值，利用<strong>索引</strong>进行<strong>范围匹配</strong></p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 &#x3D; ‘abc’;</p>
<p>key_part1, key_part2, key_part3都是联合索引的索引，列但是key_part2不是联合索引中最左索引列</p>
<p>直接<strong>遍历二级索引记录</strong></p>
<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>全表扫描</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>重温 二级索引+回表：<br><code>一般情况</code>下只能用<strong>单个二级索引执行查询</strong>，茶轩优化器识别多个搜索条件，先判断哪个条件用二级索引行数更少，就用二级索引+回表，再筛选处理其他的条件。</p>
</li>
<li><p>明确range访问方法使用的范围区间<br>有的搜索条件无法使用索引的情况</p>
</li>
<li><p>索引合并</p>
<p>特殊情况可能在一个查询中使用多个二级索引，index merge算法：</p>
<p>1） Intersection交集：多次二级索引，求出的主键求交集，再回表聚簇索引（因为二级索引是顺序搜索，回表是随机搜索开销大）</p>
<p>2）Union并集，适用于OR连接，必须保证二级索引列等值匹配，或者主键范围匹配</p>
<p>3）Sort-Union合并，多次二级索引，然后按主键分别排序，然后合并</p>
</li>
<li><p>注意用联合索引代替Intersection合并比较快</p>
</li>
</ol>
<p><code>剩余的访问方式：</code> 15节补</p>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory</p>
<h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>连接查询时，被驱动表是通过主键或唯一二级索引等值匹配进行访问</p>
<h3 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h3><p>全文索引</p>
<h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h3><p>在某些场景下可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询</p>
<h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery</p>
<h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p>访问子查询中的表时使用的是普通的索引</p>
<h2 id="11-连接（联结）的原理"><a href="#11-连接（联结）的原理" class="headerlink" title="11.连接（联结）的原理"></a>11.连接（联结）的原理</h2><p>单纯连接，连接查询的结果表包含两个表（可以多个表）的记录的笛卡尔积</p>
<h4 id="连接过程："><a href="#连接过程：" class="headerlink" title="连接过程："></a>连接过程：</h4><ol>
<li>涉及单表的条件；常规</li>
<li>涉及两表查询的条件；<ul>
<li>第一个表是驱动表，首先选取与驱动表相关的过滤条件，对驱动表单表查询，只查询一次；</li>
<li>然后第二个表是被驱动表，按照赵上步的结果，对每条记录都在被驱动表查询并筛选匹配的结果，访问多次；</li>
<li>有其他表连接，那么结果集就是新的驱动表，第三个表就成了被驱动表重复上述过程</li>
</ul>
</li>
</ol>
<h4 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h4><ol>
<li>INNER JOIN或WHERE语句，对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接 。</li>
<li>（LEFT 或 RIGHT）OUTER JOIN 对于 外连接 的两个表，<strong>驱动表中的记录</strong>即使在<strong>被驱动表中没有匹配的记录，也仍然需要加入到结果集</strong>， 对于的被驱动表的各字段用NULL表示</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure>

<ul>
<li>推荐内连接用INNER JOIN，外连接用LEFT&#x2F;RIGHT JOIN</li>
<li>内连接的驱动表和被驱动表可以换，外连接不行。</li>
</ul>
<h4 id="嵌套循环连接"><a href="#嵌套循环连接" class="headerlink" title="嵌套循环连接"></a>嵌套循环连接</h4><p>就是上述双表查询的过程</p>
<h4 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h4><p>在连接查询中对被驱动表使用<strong>主键值或者唯一二级索引列的值</strong>进行<strong>等值查找</strong>的查询执行方式称之为： eq_ref 。</p>
<ul>
<li>当然建立索引不一定用，只有二级索引+回表的代价比all代价低才会用</li>
<li>还有不要用select * 这样方式，最好是需要什么列列出来，这样可以用index方式</li>
</ul>
<h4 id="基于块的嵌套循环连接"><a href="#基于块的嵌套循环连接" class="headerlink" title="基于块的嵌套循环连接"></a>基于块的嵌套循环连接</h4><p>申请一块内存，把若干驱动表结果集中记录到join buffer中，被驱动表的记录一次性和其中多条驱动表记录做匹配</p>
<h2 id="12-MySQL基于成本的优化"><a href="#12-MySQL基于成本的优化" class="headerlink" title="12.MySQL基于成本的优化"></a>12.MySQL基于成本的优化</h2><p>MySQL执行查找的成本：</p>
<p>​	1.0的I&#x2F;O成本（读取一个页面），0.2的CPU成本（检测一个记录是否符合搜索条件）</p>
<h3 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h3><h4 id="基于成本计算的优化"><a href="#基于成本计算的优化" class="headerlink" title="基于成本计算的优化"></a>基于成本计算的优化</h4><ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<h4 id="计算all的成本"><a href="#计算all的成本" class="headerlink" title="计算all的成本"></a>计算all的成本</h4><p>Rows 表中的记录条数</p>
<p>Data_length 表占用的存储空间字节数 &#x2F;16&#x2F;1024就是页面数量被（16K一个页面）</p>
<p>1.0的I&#x2F;O成本，0.2的CPU成本&#x3D;1.0 *页面数 + 0.2*记录数</p>
<h4 id="计算索引的成本"><a href="#计算索引的成本" class="headerlink" title="计算索引的成本"></a>计算索引的成本</h4><ol>
<li>二级索引：</li>
</ol>
<p>范围区间数量：顺序IO基本就是1；</p>
<p>得到需要回表的记录数，范围搜索（不是UNIQUE），得到最左页面和最右页面，读取；</p>
<p>所在页面*1.0 + 搜的记录*0.2</p>
<ol start="2">
<li>回表</li>
</ol>
<p>回表后得到完整用户记录：需要完整记录的IO + 读取二级索引记录CPU + 回表聚簇索引CPU</p>
<h3 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h3><p>驱动表查询得到的结果条数：扇出值</p>
<p>condition filtering计算扇出值需要查询优化去猜,实际用了启发式规则：</p>
<ol>
<li>全表扫描的单表查询，猜搜索条件的记录有多少条</li>
<li>索引执行单表扫描，才满足除使用到对应索引的搜索条件外的搜索条件的记录有多少</li>
</ol>
<h4 id="两表连接的成本"><a href="#两表连接的成本" class="headerlink" title="两表连接的成本"></a>两表连接的成本</h4><p>连接查询总成本 &#x3D; 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</p>
<ul>
<li>内连接要考虑哪个作为驱动表，能用到索引 或者 减少驱动表的扇出</li>
</ul>
<h4 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h4><p>减少一些连接方法的考虑</p>
<h2 id="13-InnoDB统计数据如何收集"><a href="#13-InnoDB统计数据如何收集" class="headerlink" title="13. InnoDB统计数据如何收集"></a>13. InnoDB统计数据如何收集</h2><p>之前成本估计的一些统计信息如何收集</p>
<p>永久性的统计数据，非永久性的统计数据（用的少），STATS_PERSISTENT &#x3D; 0|1</p>
<ul>
<li>InnoDB 默认是以<strong>表</strong>为单位来收集和存储统计数据的</li>
</ul>
<h3 id="永久性数据"><a href="#永久性数据" class="headerlink" title="永久性数据"></a>永久性数据</h3><h4 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h4><p>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</p>
<p>|database_name |数据库名|<br>|table_name| 表名|<br>|last_update| 本条记录最后更新时间|<br>|n_rows |表中记录的条数|  <code>页面采样法统计的</code><br>|clustered_index_size |表的聚簇索引占用的页面数量|<br>|sum_of_other_index_sizes |表的其他索引占用的页面数量|</p>
<h4 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h4><p> 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</p>
<p>database_name 数据库名<br>table_name 表名<br>index_name 索引名<br>last_update 本条记录最后更新时间<br>stat_name 统计项的名称<br>stat_value 对应的统计项的值<br>sample_size 为生成统计数据而采样的页面数量<br>stat_description 对应的统计项的描述</p>
<h4 id="自动更新和手动更新表"><a href="#自动更新和手动更新表" class="headerlink" title="自动更新和手动更新表"></a>自动更新和手动更新表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE innodb_table_stats </span><br><span class="line">SET n_rows = 1</span><br><span class="line">WHERE table_name = &#x27;single_table&#x27;;</span><br><span class="line"></span><br><span class="line">FLUSH TABLE single_table;</span><br></pre></td></tr></table></figure>

<h3 id="innodb-stats-method"><a href="#innodb-stats-method" class="headerlink" title="innodb_stats_method"></a>innodb_stats_method</h3><p>nulls_equal ：认为所有 NULL 值都是相等的。这个值也是 innodb_stats_method 的默认值。<br>nulls_unequal ：认为所有 NULL 值都是不相等的。<br>nulls_ignored ：直接把 NULL 值忽略掉。</p>
<h2 id="14-MySQL基于规则的优化"><a href="#14-MySQL基于规则的优化" class="headerlink" title="14. MySQL基于规则的优化"></a>14. MySQL基于规则的优化</h2><p>MySQL自动的语句优化，重写规则相关</p>
<h3 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h3><ol>
<li><p>移除不必要的括号</p>
</li>
<li><p>常量传递</p>
</li>
<li><p>等值传递</p>
</li>
<li><p>移除没用的条件</p>
</li>
<li><p>表达式计算：</p>
<blockquote>
<p>如果某个列不是单独的形式作为表达式的操作数，比如出现在函数等不会化简;</p>
<p>就像之前说的如果不是单独的形式，不能用于索引</p>
</blockquote>
</li>
<li><p>HAVING子句和WHERE子句的合并</p>
<blockquote>
<p>WHERE在数据分组前进行过滤，HAVING在<strong>数据分组后</strong>进行过滤。</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230819155644556.png" alt="image-20230819155644556"></p>
<p>所以当没有SUM、MAX、GROUP BY子句就可以把HAVING和WHERE子句合并</p>
</blockquote>
</li>
<li><p>常量表检测</p>
</li>
</ol>
<h3 id="外连接消除"><a href="#外连接消除" class="headerlink" title="外连接消除"></a>外连接消除</h3><p>指定（或者隐含）被驱动表中的列不为NULl，这种条件称为 <strong>空值拒绝</strong></p>
<p>空值拒绝后内外连接互相转换，查询优化器就可以转换驱动表来优化成本了</p>
<h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询-外层查询</p>
<p>包括：SELCET子句中 、FROM子句中、WHERE ON子句中、 ORDER BY 子句中、GROUP BY 子句中</p>
<ol>
<li>必须小括号</li>
<li>select对于的标量子查询</li>
<li>（NOT） IN ANY SOME ALL查询来说不允许LIMIT语句</li>
<li>去掉一些冗余的表达</li>
</ol>
<h4 id="子查询执行"><a href="#子查询执行" class="headerlink" title="子查询执行"></a>子查询执行</h4><ol>
<li>对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了</li>
</ol>
<p>物化表，作为临时表去重、哈希；转连接</p>
<ul>
<li>半连接 （英文名： semi-join ）。将 s1 表和 s2 表进行半连接的意思就是：对于 s1 表的某条记录来说，我们只关心在 s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留 s1 表的记录</li>
</ul>
<p>如果 IN 子查询符合转换为 semi-join 的条件，查询优化器会优先把该子查询为 semi-join ，然后再考虑下<br>边5种执行半连接的策略中哪个成本最低：<br>Table pullout<br>DuplicateWeedout<br>LooseScan<br>Materialization<br>FirstMatch<br>选择成本最低的那种执行策略来执行子查询。<br>如果 IN 子查询不符合转换为 semi-join 的条件，那么查询优化器会从下边两种策略中找出一种成本更低的<br>方式执行子查询：<br>先将子查询物化之后再执行查询<br>执行 IN to EXISTS 转换。</p>
<h2 id="15-Explain详解"><a href="#15-Explain详解" class="headerlink" title="15.Explain详解"></a>15.Explain详解</h2><p>在具体的查询语句前边加一个 EXPLAIN ：帮助我们查看某个查询语句的具体执行计划，</p>
<p>列名 描述<br>id 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id<br>select_type SELECT 关键字对应的那个查询的类型<br>table 表名<br>partitions 匹配的分区信息<br>type 针对单表的访问方法<br>possible_keys 可能用到的索引<br>key 实际上使用的索引<br>key_len 实际使用到的索引长度<br>ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息<br>rows 预估的需要读取的记录条数<br>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比<br>Extra 一些额外的信息</p>
<h2 id="16-15-Explain详解-下"><a href="#16-15-Explain详解-下" class="headerlink" title="16. 15.Explain详解 下"></a>16. 15.Explain详解 下</h2><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Using index</p>
<p>Using index condition</p>
<p>等。。。用到在看吧</p>
<h3 id="Json格式的执行计划"><a href="#Json格式的执行计划" class="headerlink" title="Json格式的执行计划"></a>Json格式的执行计划</h3><p>在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT&#x3D;JSON</p>
<p> json 格式的执行计划，里边儿包含该计划花费的成本</p>
<h3 id="Extented-EXPLAIN"><a href="#Extented-EXPLAIN" class="headerlink" title="Extented EXPLAIN"></a>Extented EXPLAIN</h3><p>使用 EXPLAIN 语句查看了某个查询的执行计划后，紧接着还可以使用 <strong>SHOW WARNINGS</strong> 语句查看与这个查询的执行计划有关的一些扩展信息</p>
<ul>
<li>Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句</li>
</ul>
<h2 id="17-optimizer-trace表"><a href="#17-optimizer-trace表" class="headerlink" title="17. optimizer trace表"></a>17. optimizer trace表</h2><p>方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量optimizer_trace 决定，默认是关闭的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到</p>
<p><strong>information_schema</strong> 数据库下的 <strong>OPTIMIZER_TRACE</strong> 表中查看完整的优化过程。这个OPTIMIZER_TRACE 表有4个列，分别是：</p>
<ol>
<li>QUERY ：表示我们的查询语句。</li>
<li>TRACE ：表示优化过程的JSON格式文本。</li>
<li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE ：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li>
<li>INSUFFICIENT_PRIVILEGES ：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是1 ，我们暂时不关心这个字段的值。</li>
</ol>
<ul>
<li>演示了调用 optimizer trace表的方式</li>
</ul>
<h2 id="18-调节磁盘和CUP的矛盾-InnoDB的BufferPool"><a href="#18-调节磁盘和CUP的矛盾-InnoDB的BufferPool" class="headerlink" title="18. 调节磁盘和CUP的矛盾-InnoDB的BufferPool"></a>18. 调节磁盘和CUP的矛盾-InnoDB的BufferPool</h2><h3 id="InnoDB的Buffer-Pool"><a href="#InnoDB的Buffer-Pool" class="headerlink" title="InnoDB的Buffer Pool"></a>InnoDB的Buffer Pool</h3><p>Mysql服务器启动时，申请的连续内存。默认128MB</p>
<h3 id="内部组成："><a href="#内部组成：" class="headerlink" title="内部组成："></a>内部组成：</h3><p>控制块 碎片 缓存也</p>
<h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>空闲的缓存块对应的控制块作为节点放到链表中，free链表以供取用</p>
<h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>表空间号+页号是key，查找缓存页，是否存在Buffer Pool中</p>
<h3 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h3><p>修改了一个缓存页的数据，就是<code>脏页</code>，需要等待同步到磁盘上</p>
<p>flush链是存储脏页的，</p>
<h3 id="LRU链表管理"><a href="#LRU链表管理" class="headerlink" title="LRU链表管理"></a>LRU链表管理</h3><p>缓存页需要移除，留下频繁使用的</p>
<p>LRU（Least Recently Pool) 按照最近最少使用的原则淘汰缓存页。访问页的时候，把页放到Buffer Pool的LRU链的头部</p>
<h4 id="1）划分区域的LRU链表"><a href="#1）划分区域的LRU链表" class="headerlink" title="1）划分区域的LRU链表"></a>1）划分区域的LRU链表</h4><p>问题： 1. 预读导致不一定用到 2. 全表扫描读入频率偏低的页</p>
<p>做法： LRU链表分区：热数据young区域，冷数据old区域</p>
<p>当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部。</p>
<h4 id="2）进一步优化"><a href="#2）进一步优化" class="headerlink" title="2）进一步优化"></a>2）进一步优化</h4><p>只有被访问的缓存页位于 young 区域的 1&#x2F;4 的后边，才会被移动到 LRU链表头部等</p>
<h3 id="刷新脏页到磁盘"><a href="#刷新脏页到磁盘" class="headerlink" title="刷新脏页到磁盘"></a>刷新脏页到磁盘</h3><p>专门的线程负责</p>
<ol>
<li>LRU链表冷数据刷新部分页面到磁盘</li>
<li>flash链表刷新部分页面到磁盘</li>
</ol>
<h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h3><p>拆分若干个小的Buffer Pool，多线程并发访问</p>
<h3 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h3><p>chunk为单位想操作系统申请空间。</p>
<p>在运行期间以chunk为单位增加或删除内存空间</p>
<p>innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的</p>
<h3 id="查看Buffer-Pool的状态信息"><a href="#查看Buffer-Pool的状态信息" class="headerlink" title="查看Buffer Pool的状态信息"></a>查看Buffer Pool的状态信息</h3><p>SHOW ENGINE INNODB STATUS</p>
<h2 id="19-事务简介transaction"><a href="#19-事务简介transaction" class="headerlink" title="19. 事务简介transaction"></a>19. 事务简介transaction</h2><p>ACID 原子性 一致性 隔离性Isolation 持久性Durability</p>
<p>需要保证ACID的一个或多个数据库操作称为一个事务</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230824193205375.png" alt="image-20230824193205375" style="zoom:50%;" />

<h3 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h3><ol>
<li>开启用 BEGIN [WORK] 或者 START TRANSACTION + 修饰符（READ ONLY、 READ WRITE、 WITH CONSISTENT SANPSHOT</li>
<li>提交用 COMMIT [WORK]</li>
<li>中止并回归 ROLLBACK[WORK]</li>
</ol>
<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>只有InnoDB和NDB存储引擎支持事务，ROLLBACK必须支持事务才能用</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>autocommit 为 ON</p>
<p>每条语句都算是一个独立的事务，叫做自动提交</p>
<h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>关闭自动提交后，会导致事务隐式提交的语句包括：</p>
<ol>
<li><p>定义或修改数据库对象的数据定义语言DDL，比如说CREAT、ALERT、DROP</p>
</li>
<li><p>隐式使用或修改<strong>mysql数据库</strong>中的表</p>
</li>
<li><p>事务控制或关于锁定的句子： START TRANSACTION、 LOCK TABLES</p>
</li>
<li><p>加载数据的语句： LOAD DATA</p>
</li>
<li><p>关于Mysql复制的一些语句： START SLAVE 、 STOP SLAVE 、 RESET SLAVE 、 CHANGE MASTER TO</p>
</li>
<li><p>其他一些系统语句： </p>
<p>使用 ANALYZE TABLE 、 CACHE INDEX 、 CHECK TABLE 、 FLUSH 、 LOAD INDEX INTO CACHE 、 OPTIMIZE TABLE 、 REPAIR TABLE 、 RESET 等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ol>
<h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>SAVEPOINT 保存点名称;</p>
<p>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</p>
<p>RELEASE SAVEPOINT 保存点名称;</p>
<h2 id="21-redo-log（上）"><a href="#21-redo-log（上）" class="headerlink" title="21. redo log（上）"></a>21. redo log（上）</h2><p>问题： 事务提交了，数据修改了只存在Buffer Pool中，flush链等待写入磁盘，就不能保证持久化。</p>
<p>方法： 在事务提交完成之前把该事务修改的所有页面都刷新到磁盘</p>
<p>问题： 1. 刷新整个数据页太浪费了，2. 随机IO刷新起来比较慢</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>把事务修改数据库的内容记录，系统重启的时候只需要redo log就行</p>
<p><strong>好处：</strong> 1. redo log 占用的空间小 2. redo log 是顺序写入磁盘的（按顺序写入log）</p>
<h3 id="redo-log-格式"><a href="#redo-log-格式" class="headerlink" title="redo log 格式"></a>redo log 格式</h3><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230824202827065.png" alt="image-20230824202827065"></p>
<p>spaceID 是 表空间ID</p>
<h4 id="简单的日志类型"><a href="#简单的日志类型" class="headerlink" title="简单的日志类型"></a>简单的日志类型</h4><p>物理日志：记录在某一个页的某个偏移量修改了几个字节的值和具体内容：MLOG_8BYTE</p>
<h4 id="复杂的日志类型"><a href="#复杂的日志类型" class="headerlink" title="复杂的日志类型"></a>复杂的日志类型</h4><p>一条INSERT语句，要向B+树插入数据，也要更新系统数据（比如系统表空间中页号为7的页面的Max Row ID属性），每处修改都记录一个log很浪费，完整记录全部修改内存为一条log很浪费，所以需要设置插入行格式的redo日志类型。</p>
<p>MLOG_COMP_REC_INSERT   MLOG_COMP_PAGE_CREATE等</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825100714639.png" alt="image-20230825100714639" style="zoom: 80%;" />

<p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来</p>
<h3 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h3><h4 id="以组的形式插入redo-log"><a href="#以组的形式插入redo-log" class="headerlink" title="以组的形式插入redo log"></a>以组的形式插入redo log</h4><p>执行语句产的redo log需要分成若干个不可分割的组： 因为一些redo日志需要保证原子性，比如向聚簇索引插入一条记录产生的redo log是不可分割的。</p>
<ul>
<li><p>乐观插入：数据页剩余空间足够</p>
</li>
<li><p>悲观插入：数据页剩余空间不够，需要页分裂，甚至内节点也不够，非叶子节点也需要页分裂。这整个过程需要<strong>以组的形式记录log来保证原子性</strong></p>
</li>
</ul>
<p>标志：以MLOG_MULTI_REC_END结尾。</p>
<p>恢复：解析到标志，才是一组完整的redo日志，进行恢复</p>
<p>其他一条原子性的保证： type字段的第一个位是1</p>
<h4 id="对底层页面一次原子访问是Mini-Transaction-（mtr"><a href="#对底层页面一次原子访问是Mini-Transaction-（mtr" class="headerlink" title="对底层页面一次原子访问是Mini-Transaction （mtr"></a>对底层页面一次原子访问是Mini-Transaction （mtr</h4><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825103038372.png" alt="image-20230825103038372" style="zoom: 50%;" />

<h3 id="redo-log写入过程"><a href="#redo-log写入过程" class="headerlink" title="redo log写入过程"></a>redo log写入过程</h3><p>redo log block ：mtr生成的redo日志存在512字节的页中，称为block</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230825103501535.png" alt="image-20230825103501535"></p>
<p><strong>redo log buffer</strong>的连续内存空间，划分为若干连续的redo log block：</p>
<ul>
<li>每个 mtr 运行过程中产生的日志先暂时存到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志再全部复制到 log buffer 中。</li>
</ul>
<h2 id="22-redo-log-（下）"><a href="#22-redo-log-（下）" class="headerlink" title="22. redo log （下）"></a>22. redo log （下）</h2><h3 id="redo-log-文件"><a href="#redo-log-文件" class="headerlink" title="redo log 文件"></a>redo log 文件</h3><p>log buffer需要持久化，</p>
<h4 id="日志刷盘时机："><a href="#日志刷盘时机：" class="headerlink" title="日志刷盘时机："></a>日志刷盘时机：</h4><ol>
<li>log buffer空间不足 </li>
<li>事务提交： 可以不提交buffer pooll页面，但是为了持久性不许要提交redo log</li>
<li>后台线程每秒都刷</li>
<li>开关服务器 6.checkpoint</li>
</ol>
<h4 id="具体文件组"><a href="#具体文件组" class="headerlink" title="具体文件组"></a>具体文件组</h4><p>SHOW VARIABLES LIKE ‘datadir’ 查看mysql的数据目录</p>
<p>ib_logfile0 和 ib_logfile1 的文件记录刷新的log</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230825105401574.png" alt="image-20230825105401574"></p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825110426049.png" alt="image-20230825110426049" style="zoom:50%;" />

<h3 id="Log-Sequeue-Number-（lsn"><a href="#Log-Sequeue-Number-（lsn" class="headerlink" title="Log Sequeue Number （lsn"></a>Log Sequeue Number （lsn</h3><p>日志序列号lsn，InnoDB的初始lsn是8704</p>
<p>要存log的话，回想一下：log是以mtr方式存入的，单位是512B的log Block，其中Block有header和trailer</p>
<h4 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h4><p>刷新到磁盘中的redo log的全局变量</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825112606149.png" alt="image-20230825112606149" style="zoom:50%;" />

<p>lsn的值在读入log buffer的时候增长，flushed_to_disk_lsn的值在刷新到磁盘时往后增长，两值相同说明log buffer中的redo log都刷新到磁盘中了</p>
<h4 id="flush链中的lsn"><a href="#flush链中的lsn" class="headerlink" title="flush链中的lsn"></a>flush链中的lsn</h4><p>回想之前mtr执行后，redo log写入log buffer，还有修改的页面加入到Buffer Pool中的flush链表中；</p>
<p>flush链中页面的更新： 首次加入写一个lsn， 每次修改页面会更新lsn为新的</p>
<p>顺序是<strong>按照初始的lsn（oldest_modification）排序</strong>，更新的页面会更新newest_modification, 但不用更新链表的顺序</p>
<h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><p>redo log可覆盖操作： 当对应的脏页已经刷新到磁盘中</p>
<p>checkpoint_lsn: 系统中可以被覆盖的redo log总量是多少，初始是8704</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230825115710329.png" alt="image-20230825115710329"></p>
<p><strong>批量刷脏页</strong>： lsn增长过快，需要线程同步从flush 链表中把最早修改的脏页刷新到磁盘，然后去做checkpoint</p>
<p>SHOW ENGINE INNODB STATUS 命令查看当前 InnoDB 存储引擎中的<strong>各种 LSN 值的情况</strong></p>
<h3 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h3><p>可以设置： </p>
<p>1 事务提交时立即磁盘同步redo log </p>
<p>0 不交，等待后台线程做</p>
<p>2 写到<strong>操作系统的缓冲区</strong>，专业操作系统没挂就能保证事务的持久性</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><strong>起点</strong> ： 从checkpoint_lsn开始读取redo log （最近的checkpoint）</p>
<p><strong>终点</strong> ： 最后一条log，也就是按顺序下去block不为512的那个最后block为止</p>
<p><strong>恢复</strong> ： 按照SpaceID和page number哈希表放在一起加速读取，避免一些随机IO</p>
<ul>
<li>每个页面的File Header部分都有一个FIL_PAGE_LSN记录最近一次修改页面的lsn</li>
</ul>
<h2 id="undo-log-（上"><a href="#undo-log-（上" class="headerlink" title="undo log （上"></a>undo log （上</h2><p>保证原子性，需要把旧数据记录下来，以用于事务的回滚</p>
<h3 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h3><p>只读事务：只有在第一次对用户创建的临时表进行CUD时，才会分配一个事务id</p>
<p>读写事务： 只有在第一次对某个表（包括用户创建的临时表）进行CUD时，才会分配事务id</p>
<p><strong>事务id递增</strong>： 页号为5的页面一个Max Trx ID 的属性处，每次分配自增1</p>
<ul>
<li>聚簇索引的记录会保存用户数据外，还有自动添加的trx_id代表改动语句所在的事务id</li>
</ul>
<h3 id="undo-log的格式"><a href="#undo-log的格式" class="headerlink" title="undo log的格式"></a>undo log的格式</h3><p>每条记录一次改动，就对应一个undo日志，编号undo no</p>
<p>undo日志记录在类型为FIL_PAGE_UNDO_LOG页中</p>
<h4 id="INSERT操作"><a href="#INSERT操作" class="headerlink" title="INSERT操作"></a>INSERT操作</h4><p>TRX_UNDO_INSERT_REC类型</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825160853833.png" alt="image-20230825160853833" style="zoom:80%;" />

<ul>
<li>需要把主键包含的所有列的长度和真实值记录下来；</li>
<li>只需要考虑向聚簇索引插入记录时的情况记录就好了，因为回滚的时候只要知道记录的主键信息，然后回滚聚簇索引的时候顺带着把二级索引记录也回滚了</li>
</ul>
<p>例子：INSERT INTO undo_demo(id, key1, col)<br> VALUES (1, ‘AWM’, ‘狙击枪’), (2, ‘M416’, ‘步枪’);</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825161636437.png" alt="image-20230825161636437" style="zoom:50%;" /> <img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825161645429.png" alt="image-20230825161645429" style="zoom:50%;" /></p>
<ul>
<li>数据页每条记录中的roll_pointer,就是指向记录对应的undo日志的一个指针</li>
</ul>
<h4 id="DELETE操作"><a href="#DELETE操作" class="headerlink" title="DELETE操作"></a>DELETE操作</h4><p>删除的过程： </p>
<ol>
<li><p>deletd mark阶段： 记录的delete_mask标识位设置为1，</p>
</li>
<li><p>purge阶段：  <code>删除的事务提交后</code>，专门的线程来把记录从 正常记录链表 中移除，加入到 垃圾链表 中</p>
</li>
</ol>
<p>所以要处理回滚，只需要考虑第一个阶段</p>
<p>TRX_UNDO_DEL_MARK_REC</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825163029255.png" alt="image-20230825163029255" style="zoom:80%;" />

<ul>
<li>old trx_id和old roll_pointer属性，可以帮助找到记录修改前一条的undo日志<br>利用这些 可以组成<strong>记录的一个版本链</strong></li>
<li>索引列各列信息&lt;pos, len, value&gt; ，在事务提交后真正删除阶段用</li>
</ul>
<h4 id="UPDATE操作"><a href="#UPDATE操作" class="headerlink" title="UPDATE操作"></a>UPDATE操作</h4><h5 id="不更新主键"><a href="#不更新主键" class="headerlink" title="不更新主键"></a>不更新主键</h5><p>如果更新的<strong>每个列</strong>前后存储空间一样大，可以就地更新</p>
<p><strong>任何列</strong>更新前后存储空间大小不一致，需要记录删掉后（真删除，不是delete mark）新记录插入页面中； 新添加的空间可以重用垃圾链表空间，或者页分裂</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826150530261.png" alt="image-20230826150530261"></p>
<ul>
<li>n_updated 表示将有几个列被更新，后边跟着的 &lt;pos, old_len, old_value&gt;<br>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</li>
</ul>
<h5 id="更新主键"><a href="#更新主键" class="headerlink" title="更新主键"></a>更新主键</h5><p>意味着记录在聚簇索引的位置会发送改变</p>
<ol>
<li>旧记录进行delete mark操作</li>
<li>更新后列的值创建一条新纪录，并插入聚簇索引中</li>
</ol>
<p>所以会记录额外的TRX_UNDO_DEL_MARK_REC 和 TRX_UNDO_INSERT_REC 两条redo log</p>
<h2 id="23-undo-log-（下）"><a href="#23-undo-log-（下）" class="headerlink" title="23. undo log （下）"></a>23. undo log （下）</h2><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p>List Node结构：表空间中通过一个页的页号和在页内的偏移量唯一定位一个节点的位置</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826152109320.png" alt="image-20230826152109320"> </p>
<p>基结点管理List Node： </p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826152129088.png" alt="image-20230826152129088"></p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826152135283.png" alt="image-20230826152135283"></p>
<h3 id="undo-log页面类型"><a href="#undo-log页面类型" class="headerlink" title="undo log页面类型"></a>undo log页面类型</h3><p>表空间中的FIL_PAGE_UNDO_LOG类型页面存储redo log</p>
<p>这类页有有特有的Undo Page Header</p>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230826152534627.png" alt="image-20230826152534627" style="zoom:50%;" />

<p><strong>TRX_UNDO_PAGE_TYPE</strong> ：本页面准备存储什么种类的 undo日志</p>
<ol>
<li>TRX_UNDO_INSERT类型， 2. TRX_UNDO_UPDATE 类型</li>
</ol>
<ul>
<li>前者只存Insert，后者存其他，因为后者需要提供MVCC服务不能直接删除</li>
</ul>
<p><strong>TRX_UNDO_PAGE_NODE</strong> ：代表一个 List Node 结构</p>
<h3 id="undo-log页面链表"><a href="#undo-log页面链表" class="headerlink" title="undo log页面链表"></a>undo log页面链表</h3><h4 id="单个事务："><a href="#单个事务：" class="headerlink" title="单个事务："></a>单个事务：</h4><p>一个事务多个undo log，可能放在多个页中，需要用<strong>TRX_UNDO_PAGE_NODE属性连成一个链表</strong>，其中第一个undo页面叫first undo page，除了记录 undo page header以外，要记录一些管理信息，也就是<code>undo log segment header</code></p>
<p>最多四个链表，按需分配：简单表和临时表的分别两个insert undo链表，upadate undo链表，</p>
<h4 id="多事务："><a href="#多事务：" class="headerlink" title="多事务："></a>多事务：</h4><p>不同事务产生的undo log写入不同的undo页面链表</p>
<h3 id="undo-log-写入具体过程"><a href="#undo-log-写入具体过程" class="headerlink" title="undo log 写入具体过程"></a>undo log 写入具体过程</h3><blockquote>
<p>Undo Log Segment</p>
</blockquote>
<p>每个<strong>undo页面链表</strong>都有一个<strong>对应的段</strong> <code>Undo Log Segment</code>，****，也就是说链表的页面都是从这个段中申请的。</p>
<p>所以在first undo page有关于这个段的信息，Undo Log segment Header部分</p>
<p>没有被重用的 Undo页面 链表来说，链表的第一个页面，也就是 first undo page 在真正写入 undo日志前，会填充 Undo Page Header 、 Undo Log Segment Header 、Undo Log Header 这3个部分，之后才开始正式写入 undo日志 。</p>
<h3 id="重用-undo页面"><a href="#重用-undo页面" class="headerlink" title="重用 undo页面"></a>重用 undo页面</h3><p>一般一个页面链表只存一个事务产生的一组undo日志</p>
<p>每次开启事务都创建新的undo页面链表存undo log是一种浪费，事务提交后可以重用undo页面链表。</p>
<p><strong>重用条件</strong>：</p>
<ol>
<li>该链表只包含<code>一个undo页面</code>， 2. 该undo页面已经使用的空间小于整页面空间的3&#x2F;4</li>
</ol>
<p><strong>重用分类</strong>：</p>
<p>insert undo链表 ，事务提交后重用可以覆盖undo log</p>
<p>update undo链表， 事务提交后不能删除，往后写undo log。 </p>
<h3 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h3><p>一个事务最多可以分配4个undo 页面链表，不同事务不同。</p>
<p>设置了一种统一放<strong>Rollback Segment Header页面</strong>， 存放每个undo页面链表的first undo page 页号<strong>（undo slot）</strong></p>
<p><strong>回滚段</strong>Rollback Segment ：每个Rollback Segment Header页面对应一个段，</p>
<blockquote>
<p>好像分配页面必须要有对应的段??? 也就是物理存址需要有逻辑上对应的操作</p>
<p>这里的回滚段就是对应了 <strong>记录了所有回滚链的第一个页的页号</strong> 的页</p>
<p>前面的undo log segment 就是对应了 undo log 页面的链表</p>
</blockquote>
<p>从回滚段中省去undo页面链表： 分配FIL_NULL状态的undo slot。</p>
<p>一个Rollback Segment Header页面对应<strong>1024个undo slot</strong></p>
<h5 id="回滚段的数量和分类"><a href="#回滚段的数量和分类" class="headerlink" title="回滚段的数量和分类"></a>回滚段的数量和分类</h5><p>系统一共有<strong>128 个回滚段</strong>，在系统表空间的第 5 号页面中存储了128个 Rollback Segment Header<br>页面地址，</p>
<p>这些回滚段分类： 0号是系统表空间中的，1-32是在临时表空间的，33-127号是既可以在系统表空间中，也可以在自己配置的undo表空间中</p>
<p><strong>分类的原因：</strong>在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志</p>
<h3 id="为事务分配undo页面链表的过程"><a href="#为事务分配undo页面链表的过程" class="headerlink" title="为事务分配undo页面链表的过程"></a>为事务分配undo页面链表的过程</h3><p>系统5号页面分配回滚段，查看回滚段的两个cached链表（insert 和 update）有没有缓存的undo slot，没有就在Rollback Segment Header页面找一个可用的undo slot分配给该事务，分配一个undo log segment，从中申请一个页面作为undo 页面的first undo page。然后事务就把undo log 写到这个页面链表了</p>
<p>如果也有临时表的改动，那也要相同的分配临时表的回滚段</p>
<h2 id="24-事务的隔离级别与MVCC"><a href="#24-事务的隔离级别与MVCC" class="headerlink" title="24. 事务的隔离级别与MVCC"></a>24. 事务的隔离级别与MVCC</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>隔离性： 在某个事务对某个数据进行访问时，其他事务应该排队。</p>
<p>性能： CS架构需要同时处理多个会话</p>
<h4 id="事务并发的问题："><a href="#事务并发的问题：" class="headerlink" title="事务并发的问题："></a>事务并发的问题：</h4><p><strong>脏写</strong>：一个事务修改了另一个未提交事务修改过的数据 </p>
<p><strong>脏读</strong>: 一个事务读到了<strong>另一个未提交事务</strong>修改过的数据</p>
<p><strong>不可重复读 ：</strong> 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</p>
<p><strong>幻读:</strong> 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。</p>
<ul>
<li>从下往上依次严重</li>
</ul>
<blockquote>
<p>不可重复读：重点是修改，同一事务，两次读取到的数据不一样。<br>幻读：重点在于新增或者删除，同样的条件 , 第 1 次和第 2 次读出来的记录数不一样。<br>脏读：强调的是第二个事务读到的不够新。</p>
</blockquote>
<h4 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h4><p>READ UNCOMMITTED ：未提交读。<br>READ COMMITTED ：已提交读。<br>REPEATABLE READ ：可重复读。<br>SERIALIZABLE ：可串行化。</p>
<p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826190649111.png" alt="image-20230826190649111"></p>
<h4 id="MySQL中支持的4中隔离级别"><a href="#MySQL中支持的4中隔离级别" class="headerlink" title="MySQL中支持的4中隔离级别"></a>MySQL中支持的4中隔离级别</h4><p>MySQL默认支持<strong>REPEATABLE READ</strong> ,并且是可以禁止幻读问题的发生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure>

<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="版本链："><a href="#版本链：" class="headerlink" title="版本链："></a><strong>版本链</strong>：</h4><p>InnoDB每条记录的必要两个隐藏列 trx_id、 roll_pointer</p>
<p>其中roll_pointer之前一个操作undo log，如果前一个是insert undo，并且事务提交了，他的undo log segment被系统回收了，就会指向空的。其中第一个字节标识类型，1代表inset undo，看到就可以不用管了</p>
<p>随着更新次数增加，<strong>所有版本的roll_pointer属性连成一个链表，叫做版本连</strong>，头结点是当前记录的值</p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的<strong>最新</strong>版本就好了；</p>
<p>对于使用 SERIALIZABLE 隔离级别的事务来说， InnoDB 规定使用<strong>加锁</strong>的方式来访问记录；</p>
<p>READ COMMITTED 和 REPEATABLE READ 隔离级别不一定能读取最新版本的记录。（加入另一个事务已经修改记录但是尚未提交，不能读取最新版本的记录）</p>
<ul>
<li>需要判断一下版本链中的哪个版本是当前事务可见的，设计了版本的ReadView：</li>
</ul>
<ol>
<li>m_ids:在生成 ReadView 时当前系统中活跃的读写事务的事务id列表</li>
<li>min_trx_id</li>
<li>max_trx_id</li>
<li>creator_trx_id : 生成这个ReadView的事务id</li>
</ol>
<ul>
<li>通过当前版本的ReadView，判断判断trx_id可见性：</li>
</ul>
<ol>
<li><p>trx_id&#x3D; creator_trx_id 自己访问，可以</p>
</li>
<li><p>&lt; min_trx_id trx_id 比当前最小的还小，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，可以 </p>
</li>
<li><p>&gt; max_trx_id  比当前的最大的还新，不行</p>
</li>
<li><p>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，<strong>如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问</strong>；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</p>
</li>
</ol>
<p>READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们<strong>生成ReadView的</strong><br><strong>时机不同</strong></p>
<p>READ COMMITTED —— 每次读取数据前都生成一个ReadView</p>
<p>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</p>
<h4 id="MVCC小结"><a href="#MVCC小结" class="headerlink" title="MVCC小结"></a>MVCC小结</h4><p>MVCC （Multi-Version Concurrency Control ，多版本并发控制）：使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p>
<p>READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同：</p>
<p>生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>
<h3 id="purge前后"><a href="#purge前后" class="headerlink" title="purge前后"></a>purge前后</h3><p> update undo 由于还需要支持 MVCC ，不能立即删除掉，只是delete mark；</p>
<p>在确定系统中包含<strong>最早产生的那个 ReadView 的事务不会再访问某些 update undo日志</strong> 以及被打了删除标记的记录后，有一个后台运行的 purge线程 会把它们真正的删除掉。</p>
<h2 id="25-锁"><a href="#25-锁" class="headerlink" title="25. 锁"></a>25. 锁</h2><p>事务并发在读情况下不会对记录产生影响，但是脏写的问题是每个隔离级别都不允许的；</p>
<p>一般用锁实现事务执行同步</p>
<p>每条记录在事务修改时都要检查有没有锁结构，锁结构：trx信息、 is_waiting标志</p>
<blockquote>
<p>这里锁结构是对应记录和事务的，如果前一个事务锁着，另一个事务要拿到这条记录要生成了一个 锁结构 与这条记录关联，不过 锁结构 的is_waiting 属性值为 true ，表示当前事务需要等待</p>
</blockquote>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230828102250590.png" alt="image-20230828102250590" style="zoom:67%;" />

<h3 id="解决并发事务问题的两种方式"><a href="#解决并发事务问题的两种方式" class="headerlink" title="解决并发事务问题的两种方式"></a>解决并发事务问题的两种方式</h3><ol>
<li>读操作利用MVCC控制，写操作加锁： 效率高</li>
<li>读 写操作都加锁：但是幻读的幻影记录在读之前不存在，不知道给谁加锁</li>
</ol>
<h4 id="一致性无锁读："><a href="#一致性无锁读：" class="headerlink" title="一致性无锁读："></a><strong>一致性无锁读</strong>：</h4><p>一般的SELECT语句在在 READ COMMITTED 、 REPEATABLE READ 隔离级别下都算是 一致性读</p>
<h4 id="锁定读："><a href="#锁定读：" class="headerlink" title="锁定读："></a><strong>锁定读</strong>：</h4><p>既要允许读 读不受影响，又要使得写 写， 读 写， 写 读 互相阻塞，需要设计锁</p>
<p>用锁来解决 脏读、不可重复读、幻读 问题</p>
<p><code>共享锁S</code>：<strong>读取记录</strong>需要获得锁； <code>独占锁X</code>： <strong>改动记录</strong>需要获得锁</p>
<blockquote>
<p>S锁是兼容的，X和S是不兼容，X和X是不兼容的：</p>
<p>假如事务 T1 首先获取了一条记录的 S锁 之后，事务 T2 接着也要访问这条记录：<br>如果事务 T2 想要再获取一个记录的 S锁 ，那么事务 T2 也会获得该锁，也就意味着事务 T1 和 T2 在该记录上同时持有 S锁 。<br>如果事务 T2 想要再获取一个记录的 X锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S锁 释放掉。<br>如果事务 T1 首先获取了一条记录的 X锁 之后，那么不管事务 T2 接着想获取该记录的 S锁 还是 X锁 都会被阻塞，直到事务 T1 提交。</p>
</blockquote>
<p>可以锁定读语句： </p>
<ol>
<li><p>对读取的记录加 S锁 ：不允许写<br>SELECT … LOCK IN SHARE MODE;</p>
</li>
<li><p>对读取的记录加 X锁 ：不允许读 写<br>SELECT … FOR UPDATE;</p>
</li>
</ol>
<h4 id="读操作："><a href="#读操作：" class="headerlink" title="读操作："></a>读操作：</h4><ol>
<li>DELETE: <strong>X锁读</strong> 取记录在B+树的位置，<strong>X锁写</strong> delete mark</li>
<li>UPDATE: <ol>
<li>不修改主键 不修改存储空间：<strong>X锁读</strong> B+树定位，<strong>X锁写</strong> 修改原纪录</li>
<li>不修改主键 至少有列占用存储空间修改前后变化： <strong>X锁读</strong> B+树定位， <strong>X锁写</strong> 彻底删除记录，<strong>INSERT 隐形锁</strong> 新插入记录</li>
<li>修改主键 相当于 DELETE后INSERT操作</li>
</ol>
</li>
<li>INSERT： 一般不加锁，用<strong>隐式锁</strong>保护</li>
</ol>
<h3 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h3><p>锁的粒度 包括 行锁 表锁</p>
<h4 id="意向锁："><a href="#意向锁：" class="headerlink" title="意向锁："></a>意向锁：</h4><p>意向共享锁：IS 事务给记录上S锁，需要在表加SI锁</p>
<p>意向独占锁：IX 事务给记录上X锁，需要在表加XI锁</p>
<p>IS、IX锁是表级锁，它们的提出仅仅<strong>为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否</strong><br><strong>被上锁</strong>，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</p>
<h3 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h3><h4 id="其他引擎的锁"><a href="#其他引擎的锁" class="headerlink" title="其他引擎的锁"></a>其他引擎的锁</h4><p>对于 MyISAM 、 MEMORY 、 MERGE 这些存储引擎来说，它们<strong>只支持表级锁，而且这些引擎并不支持事务</strong>，所以使用这些存储引擎的锁一般都是<strong>针对当前会话来</strong>说的。比方说在 Session 1 中对一个表执行 SELECT 操作，就相当于为这个表加了一个表级别的 S锁 ，如果在 SELECT 操作未完成时， Session 2 中对这个表执行 UPDATE 操作，相当于要获取表的 X锁 ，此操作会被阻塞，直到 Session 1 中的 SELECT 操作完成，释放掉表级别的 S锁 后，Session 2 中对这个表执行 UPDATE 操作才能继续获取 X锁 ，然后执行具体的更新语句。</p>
<ul>
<li>这些引擎的表在同时只允许一个会话对表写操作，一般用在大<strong>部分只读、或者单用户</strong>的场景</li>
</ul>
<h4 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h4><h5 id="表锁："><a href="#表锁：" class="headerlink" title="表锁："></a>表锁：</h5><ol>
<li>表级别的 S锁 、 X锁：<br>在对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时， InnoDB 存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。</li>
</ol>
<p>ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如 SELECT 、 INSERT 、 DELETE 、 UPDATE 的语句会发生阻塞。 </p>
<p>不过请尽量避免在使用 InnoDB 存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。 InnoDB 的厉害之处还是实现了更细粒度的行锁</p>
<ol start="2">
<li><p>表级别的 IS锁 、 IX锁</p>
</li>
<li><p>表级别的 AUTO-INC锁： 实现AUTO_INCREMENT修饰的列递增赋值：</p>
<p>一种方式：在执行插入语句时，表级别加AUTO_INC锁，自增列分配递增值，然后释放AUTO_INC锁</p>
<p>另一种： 采用轻量级的锁，原理差不多，但是可以避免锁定表，提升插入性能</p>
</li>
</ol>
<h5 id="行锁："><a href="#行锁：" class="headerlink" title="行锁："></a>行锁：</h5><ol>
<li><p><strong>Record Locks</strong> ，单条记录锁，类型名LOCK_REC_NOT_GAP</p>
</li>
<li><p><strong>Gap Locks</strong>， 防止幻影记录提出来的，锁住主键的一个间隙，防止插入新纪录，类型名为LOCK_GAP<br>比如对Supremum记录插入gap锁，就可以防止（最后一个记录主键，+无穷）范围插入记录</p>
</li>
<li><p><strong>Next-Key Locks</strong>, next-key锁 的本质就是一个 正经记录锁 和一个 gap锁 的合体，它既能保护该条记录，又能阻止别的事务<br>将新记录插入被保护记录前边的 间隙 。</p>
</li>
<li><p><strong>LOCK_INSERT_INTENTION</strong> ， 插入意向锁 , 插入位置被gap锁锁住， 需要等待。</p>
<p>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。 就是记录一下</p>
</li>
<li><p><strong>隐式锁</strong>：INSERT操作不会自己加锁，而是依靠<strong>trx_id</strong>，别的事务对这条记录加S锁或X锁时，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构进入等待</p>
</li>
</ol>
<h4 id="InnoDB的锁结构"><a href="#InnoDB的锁结构" class="headerlink" title="InnoDB的锁结构"></a>InnoDB的锁结构</h4><p>以下情况，可以放到一个锁结构中： </p>
<ol>
<li>在同一个事务中进行加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ol>
<img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230828143936242.png" alt="image-20230828143936242" style="zoom:67%;" />

<p>表锁／行锁信息 ：</p>
<p>表锁：<br>记载着这是对哪个表加的锁，还有其他的一些信息。</p>
<p>行锁：<br>记载了三个重要的信息：<br>Space ID ：记录所在表空间。<br>Page Number ：记录所在页号。<br>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比<br>特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 n_bits 属<br>性代表使用了多少比特位。</p>
<p>type_mode ：<br>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://forthdifferential.github.io">陈锴烺</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://forthdifferential.github.io/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">https://forthdifferential.github.io/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://forthdifferential.github.io" target="_blank">个人主页</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/title.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">陈锴烺</div><div class="author-info__description">Every man is the master of his own fortune.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/forthdifferential"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/forthdifferential" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:klchen_auto@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><b>---Welcome to my blog---<br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E9%83%A8%E5%88%86"><span class="toc-text">1.初始部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CS%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">CS进程间通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-text">服务器处理客户端的查询请求流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">连接管理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">解析与优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">存储引擎</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-text">2. 启动选项和系统变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E9%80%89%E9%A1%B9%EF%BC%88%E5%BD%93%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E6%95%88%EF%BC%89"><span class="toc-text">命令行上使用选项（当次启动生效）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%89%E9%A1%B9%EF%BC%88%E6%9C%AC%E6%9C%BA%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-text">配置文件中使用选项（本机修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F-VARIABLES"><span class="toc-text">系统变量 VARIABLES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F-STATUS"><span class="toc-text">状态变量 STATUS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="toc-text">3.字符集和比较规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="toc-text">比较规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">4.InnoDB记录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E8%A1%8C%E6%A0%BC%E5%BC%8FROW-FORMAT-%EF%BC%9A"><span class="toc-text">四种行格式ROW_FORMAT ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compact%E7%A4%BA%E4%BE%8B"><span class="toc-text">Compact示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%83%A8%E5%88%86"><span class="toc-text">1. 变长字段部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-NULL%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-text">2. NULL值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">3. 记录头信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E9%9A%90%E8%97%8F%E5%88%97"><span class="toc-text">4. 还有一些隐藏列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-text">5. 真实数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">Redundant行格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%EF%BC%9A%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%8D%A0%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E8%B6%85%E5%87%BA"><span class="toc-text">行溢出：一条记录占用的最大存储空间超出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic%E5%92%8CCompressed%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">Dynamic和Compressed行格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-text">5.InnoDB数据页结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">记录的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95%E6%9D%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">添加记录条的过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E4%B8%BB%E9%94%AE%E5%80%BC%E7%9A%84%E8%AE%B0%E5%BD%95%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">一个数据页中查找指定主键值的记录过程：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-B-%E6%95%B0%E7%B4%A2%E5%BC%95"><span class="toc-text">6. B+数索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-text">聚簇索引：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-text">二级索引：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-text">联合索引：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-text">注意事项：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E4%B8%AD%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">MyISAM中索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">创建和删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7. B+树索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%A3%E4%BB%B7"><span class="toc-text">索引代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E9%80%82%E7%94%A8%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">B+树索引适用的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">回表的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E7%B4%A2%E5%BC%95"><span class="toc-text">如何挑选索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AA%E4%B8%BA%E6%90%9C%E7%B4%A2%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E5%88%86%E7%BB%84%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BA"><span class="toc-text">1. 只为搜索、排序、分组的列创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%97%E7%9A%84%E5%9F%BA%E6%95%B0%E8%B6%8A%E5%A4%A7%E4%BA%8E%E5%A5%BD"><span class="toc-text">2. 列的基数越大于好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%BD%E9%87%8F%E5%B0%8F"><span class="toc-text">3. 索引列的类型尽量小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E7%9A%84%E5%89%8D%E7%BC%80"><span class="toc-text">4.索引字符串值的前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E5%88%97%E5%9C%A8%E6%AF%94%E8%BE%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8D%95%E7%8B%AC%E5%87%BA%E7%8E%B0"><span class="toc-text">5.索引列在比较表达式单独出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%BB%E9%94%AE%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-text">6.主键插入顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%8D%E8%A6%81%E5%86%97%E4%BD%99%E6%88%96%E8%80%85%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="toc-text">7.不要冗余或者重复索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8"><span class="toc-text">8.尽量使用覆盖索引避免回表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-text">8.MySQL的数据目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-text">数据目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">数据库在文件中的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6"><span class="toc-text">其他文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">系统数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4-%E4%B8%8D%E5%A4%AA%E7%86%9F%E5%86%8D%E7%9C%8B%E7%9C%8B"><span class="toc-text">9.InnoDB的表空间 不太熟再看看</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-text">页面类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%80%9A%E7%94%A8%E9%83%A8%E5%88%86"><span class="toc-text">页面通用部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-text">独立表空间结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E3%80%81%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">区、段的概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">区的分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">段的分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%A6%E7%BB%86%E6%83%85%E5%86%B5"><span class="toc-text">各类页面的详细情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Segment-Header"><span class="toc-text">Segment Header</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-text">系统表空间结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">10. 单表查询的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%B8%B8%E6%95%B0%E7%BA%A7%E5%88%AB"><span class="toc-text">const常数级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-or-null"><span class="toc-text">ref_or_null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#range"><span class="toc-text">range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index"><span class="toc-text">index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#all"><span class="toc-text">all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system"><span class="toc-text">system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eq-ref"><span class="toc-text">eq_ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fulltext"><span class="toc-text">fulltext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-merge"><span class="toc-text">index_merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-subquery"><span class="toc-text">unique_subquery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-subquery"><span class="toc-text">index_subquery</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%BF%9E%E6%8E%A5%EF%BC%88%E8%81%94%E7%BB%93%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">11.连接（联结）的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">连接过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">内连接和外连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5"><span class="toc-text">嵌套循环连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%8A%A0%E5%BF%AB%E8%BF%9E%E6%8E%A5%E9%80%9F%E5%BA%A6"><span class="toc-text">使用索引加快连接速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%9D%97%E7%9A%84%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5"><span class="toc-text">基于块的嵌套循环连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">12.MySQL基于成本的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">单表查询的成本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E8%AE%A1%E7%AE%97%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">基于成本计算的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97all%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">计算all的成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%B4%A2%E5%BC%95%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">计算索引的成本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">连接查询的成本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">两表连接的成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">多表连接的成本分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86"><span class="toc-text">13. InnoDB统计数据如何收集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B8%E4%B9%85%E6%80%A7%E6%95%B0%E6%8D%AE"><span class="toc-text">永久性数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-table-stats"><span class="toc-text">innodb_table_stats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-index-stats"><span class="toc-text">innodb_index_stats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%92%8C%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="toc-text">自动更新和手动更新表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb-stats-method"><span class="toc-text">innodb_stats_method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">14. MySQL基于规则的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8C%96%E7%AE%80"><span class="toc-text">条件化简</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%B6%88%E9%99%A4"><span class="toc-text">外连接消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">子查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C"><span class="toc-text">子查询执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Explain%E8%AF%A6%E8%A7%A3"><span class="toc-text">15.Explain详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-15-Explain%E8%AF%A6%E8%A7%A3-%E4%B8%8B"><span class="toc-text">16. 15.Explain详解 下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra"><span class="toc-text">Extra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">Json格式的执行计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extented-EXPLAIN"><span class="toc-text">Extented EXPLAIN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-optimizer-trace%E8%A1%A8"><span class="toc-text">17. optimizer trace表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCUP%E7%9A%84%E7%9F%9B%E7%9B%BE-InnoDB%E7%9A%84BufferPool"><span class="toc-text">18. 调节磁盘和CUP的矛盾-InnoDB的BufferPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84Buffer-Pool"><span class="toc-text">InnoDB的Buffer Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-text">内部组成：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free%E9%93%BE%E8%A1%A8"><span class="toc-text">free链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A1%B5%E7%9A%84%E5%93%88%E5%B8%8C%E5%A4%84%E7%90%86"><span class="toc-text">缓存页的哈希处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">flush链表的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E9%93%BE%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-text">LRU链表管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F%E7%9A%84LRU%E9%93%BE%E8%A1%A8"><span class="toc-text">1）划分区域的LRU链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-text">2）进一步优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5%E5%88%B0%E7%A3%81%E7%9B%98"><span class="toc-text">刷新脏页到磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AABuffer-Pool%E5%AE%9E%E4%BE%8B"><span class="toc-text">多个Buffer Pool实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb-buffer-pool-chunk-size"><span class="toc-text">innodb_buffer_pool_chunk_size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BBuffer-Pool%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="toc-text">查看Buffer Pool的状态信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8Btransaction"><span class="toc-text">19. 事务简介transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E8%AF%AD%E6%B3%95"><span class="toc-text">事务语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E"><span class="toc-text">引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-text">自动提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4"><span class="toc-text">隐式提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="toc-text">保存点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-redo-log%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">21. redo log（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E6%A0%BC%E5%BC%8F"><span class="toc-text">redo log 格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">简单的日志类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">复杂的日志类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mini-Transaction"><span class="toc-text">Mini-Transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%BB%84%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%92%E5%85%A5redo-log"><span class="toc-text">以组的形式插入redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%95%E5%B1%82%E9%A1%B5%E9%9D%A2%E4%B8%80%E6%AC%A1%E5%8E%9F%E5%AD%90%E8%AE%BF%E9%97%AE%E6%98%AFMini-Transaction-%EF%BC%88mtr"><span class="toc-text">对底层页面一次原子访问是Mini-Transaction （mtr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">redo log写入过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-redo-log-%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">22. redo log （下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E6%96%87%E4%BB%B6"><span class="toc-text">redo log 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA%EF%BC%9A"><span class="toc-text">日志刷盘时机：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-text">具体文件组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log-Sequeue-Number-%EF%BC%88lsn"><span class="toc-text">Log Sequeue Number （lsn</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flushed-to-disk-lsn"><span class="toc-text">flushed_to_disk_lsn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flush%E9%93%BE%E4%B8%AD%E7%9A%84lsn"><span class="toc-text">flush链中的lsn</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkpoint"><span class="toc-text">checkpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb-flush-log-at-trx-commit"><span class="toc-text">innodb_flush_log_at_trx_commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-text">崩溃恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo-log-%EF%BC%88%E4%B8%8A"><span class="toc-text">undo log （上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1id"><span class="toc-text">事务id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">undo log的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#INSERT%E6%93%8D%E4%BD%9C"><span class="toc-text">INSERT操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE%E6%93%8D%E4%BD%9C"><span class="toc-text">DELETE操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UPDATE%E6%93%8D%E4%BD%9C"><span class="toc-text">UPDATE操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%94%AE"><span class="toc-text">不更新主键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%94%AE"><span class="toc-text">更新主键</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-undo-log-%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">23. undo log （下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">链表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log%E9%A1%B5%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-text">undo log页面类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log%E9%A1%B5%E9%9D%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">undo log页面链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%9A"><span class="toc-text">单个事务：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BA%8B%E5%8A%A1%EF%BC%9A"><span class="toc-text">多事务：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log-%E5%86%99%E5%85%A5%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-text">undo log 写入具体过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%94%A8-undo%E9%A1%B5%E9%9D%A2"><span class="toc-text">重用 undo页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%AE%B5"><span class="toc-text">回滚段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%AE%B5%E7%9A%84%E6%95%B0%E9%87%8F%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">回滚段的数量和分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BA%8B%E5%8A%A1%E5%88%86%E9%85%8Dundo%E9%A1%B5%E9%9D%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">为事务分配undo页面链表的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC"><span class="toc-text">24. 事务的隔离级别与MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">事务并发的问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">SQL标准中的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%844%E4%B8%AD%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">MySQL中支持的4中隔离级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%93%BE%EF%BC%9A"><span class="toc-text">版本链：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadView"><span class="toc-text">ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC%E5%B0%8F%E7%BB%93"><span class="toc-text">MVCC小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#purge%E5%89%8D%E5%90%8E"><span class="toc-text">purge前后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E9%94%81"><span class="toc-text">25. 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">解决并发事务问题的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%97%A0%E9%94%81%E8%AF%BB%EF%BC%9A"><span class="toc-text">一致性无锁读：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%9A"><span class="toc-text">锁定读：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">读操作：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%B2%92%E5%BA%A6%E9%94%81"><span class="toc-text">多粒度锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%9A"><span class="toc-text">意向锁：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81"><span class="toc-text">MySQL中的行锁和表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81"><span class="toc-text">其他引擎的锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%94%81"><span class="toc-text">InnoDB的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%EF%BC%9A"><span class="toc-text">表锁：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%EF%BC%9A"><span class="toc-text">行锁：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%94%81%E7%BB%93%E6%9E%84"><span class="toc-text">InnoDB的锁结构</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - GFS论文阅读"><img src="/imgs/$%7Bfiilename%7D/GFS/image-20230411161308484.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - GFS论文阅读"/></a><div class="content"><a class="title" href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - GFS论文阅读">分布式 - GFS论文阅读</a><time datetime="2023-11-21T11:01:26.674Z" title="发表于 2023-11-21 19:01:26">2023-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - MapReduce论文阅读"><img src="/imgs/$%7Bfiilename%7D/MapReduce/image-20230329113648794.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - MapReduce论文阅读"/></a><div class="content"><a class="title" href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - MapReduce论文阅读">分布式 - MapReduce论文阅读</a><time datetime="2023-11-21T09:01:33.208Z" title="发表于 2023-11-21 17:01:33">2023-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/" title="MySql - MySql必知必会记录"><img src="/imgs/$%7Bfiilename%7D/mysqlbizhibihui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql - MySql必知必会记录"/></a><div class="content"><a class="title" href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/" title="MySql - MySql必知必会记录">MySql - MySql必知必会记录</a><time datetime="2023-11-14T13:39:06.803Z" title="发表于 2023-11-14 21:39:06">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" title="MySql - MySql数据库运行原理"><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/title.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql - MySql数据库运行原理"/></a><div class="content"><a class="title" href="/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" title="MySql - MySql数据库运行原理">MySql - MySql数据库运行原理</a><time datetime="2023-11-14T07:44:37.544Z" title="发表于 2023-11-14 15:44:37">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux - Linux网络编程"><img src="/imgs/$%7Bfiilename%7D/wangluobiancheng.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux - Linux网络编程"/></a><div class="content"><a class="title" href="/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux - Linux网络编程">Linux - Linux网络编程</a><time datetime="2023-11-14T07:12:13.923Z" title="发表于 2023-11-14 15:12:13">2023-11-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 陈锴烺</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>