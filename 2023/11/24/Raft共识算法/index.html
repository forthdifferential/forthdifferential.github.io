<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2) | 个人主页</title><meta name="author" content="陈锴烺"><meta name="copyright" content="陈锴烺"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Raft1. Raft简介一种分布式集群内的共识算法 • 相比于Paxos，Raft最大的特性就是易于理解（Understandable）。为了达到这个目标，Raft主要做了两方面的事情：  问题分解：把共识算法分为三个子问题，分别是领导者选举（leader election）、日志复制（log replication）、安全性（safety） 状态简化：对算法做出一些限制，减少状态数量和可能产生">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式 - Raft介绍和简单实现（MIT6.824&#x2F;2023-lab2)">
<meta property="og:url" content="https://forthdifferential.github.io/2023/11/24/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="个人主页">
<meta property="og:description" content="Raft1. Raft简介一种分布式集群内的共识算法 • 相比于Paxos，Raft最大的特性就是易于理解（Understandable）。为了达到这个目标，Raft主要做了两方面的事情：  问题分解：把共识算法分为三个子问题，分别是领导者选举（leader election）、日志复制（log replication）、安全性（safety） 状态简化：对算法做出一些限制，减少状态数量和可能产生">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://forthdifferential.github.io/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/title.png">
<meta property="article:published_time" content="2023-11-24T07:25:03.230Z">
<meta property="article:modified_time" content="2023-11-24T08:07:08.897Z">
<meta property="article:author" content="陈锴烺">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://forthdifferential.github.io/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/title.png"><link rel="shortcut icon" href="/imgs/head.ico"><link rel="canonical" href="https://forthdifferential.github.io/2023/11/24/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-24 16:07:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="个人主页"><span class="site-name">个人主页</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-24T07:25:03.230Z" title="发表于 2023-11-24 15:25:03">2023-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-24T08:07:08.897Z" title="更新于 2023-11-24 16:07:08">2023-11-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><h3 id="1-Raft简介"><a href="#1-Raft简介" class="headerlink" title="1. Raft简介"></a>1. Raft简介</h3><p>一种分布式集群内的共识算法</p>
<p>• 相比于Paxos，Raft最大的特性就是易于理解（Understandable）。为了达到这个目标，Raft主要做了两方面的事情：</p>
<ol>
<li>问题分解：把共识算法分为三个子问题，分别是领导者选举（leader election）、日志<br>复制（log replication）、安全性（safety）</li>
<li>状态简化：对算法做出一些限制，减少状态数量和可能产生的变动。</li>
</ol>
<img src="/imgs/$%7Bfiilename%7D/raft共识算法/image-20230508171059069.png" alt="image-20230508171059069" style="zoom:80%;" />

<h3 id="2-复制状态机的实现"><a href="#2-复制状态机的实现" class="headerlink" title="2. 复制状态机的实现"></a>2. 复制状态机的实现</h3><img src="/imgs/$%7Bfiilename%7D/raft共识算法/title.png" alt="image-20231124154739398" style="zoom:50%;" />

<p>复制状态机（Replicated State Machine，简称RSM）是一种<strong>分布式系统的设计模式</strong>。在该模式下，一个服务或应用程序的<strong>状态机被复制到多个节点上并行处理</strong>，以提高可用性和性能。具体地说，采用复制状态机的系统中，对于某个特定的客户端请求，它将被发送到所有复制的状态机或者其中的一组。然后，每个状态机独立地执行相同的操作序列，并生成相同的结果。最终，生成的结果将会被汇总并返回给客户端。通过这种方式，复制状态机可以将单点故障风险降至最低并提高系统的可靠性。此外，由于并行执行相同的操作序列，该模式还能够提供更好的性能和可伸缩性。</p>
<p>复制状态机是一种常见的分布式系统设计模式，在诸如Google、Facebook和Amazon等互联网巨头公司的分布式系统中得到广泛应用。</p>
<blockquote>
<p>我们使用共识算法，就是为了实现复制状态机。<br>一个分布式场景下的各节点间，就是通过共识算法来保证命令序列的一致，从而始终保持它们的状态一致，从而实现高可用的。</p>
</blockquote>
<h4 id="2-1-状态简化"><a href="#2-1-状态简化" class="headerlink" title="2.1 状态简化"></a>2.1 状态简化</h4><p>在任何时刻，每一个服务器节点都处于<strong>leader，follower或candidate</strong>这三个状态之一。相比于Paxos，这一点就极大简化了算法的实现，因为Raft只需考虑状态的切换，而不用像Paxos那样考虑状态之间的共存和互相影响。</p>
<img src="/imgs/$%7Bfiilename%7D/raft共识算法/image-20231121224950686.png" alt="image-20231121224950686" style="zoom: 80%;" />

<p>Raft把时间分割成任意长度的任期（term），任期用连续的整数标记。<br>• 每一段任期从一次选举开始。在某些情况下，一次选举无法选出leader（比如两个节点收到了相同的票数），在这种情况下，这一任期会以没有leader结束；一个新的任期（包含一次新的选举）会很快重新开始。Raft保证在任意一个任期内，最多只有一个<br>leader。</p>
<p><img src="/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/image-20231121225316668.png" alt="image-20231121225316668"></p>
<p>• Raft算法中服务器节点之间使用RPC进行通信，并且Raft中只有两种主要的RPC：</p>
<p>• RequestVote RPC（请求投票）：由<strong>candidate</strong>在<strong>选举</strong>期间发起。</p>
<p>• AppendEntries RPC（追加条目）：由<strong>leader</strong>发起，用来<strong>日志同步</strong>和提供一种<strong>心跳机制</strong>。</p>
<p>• 服务器之间通信的时候会交换当前任期号；如果一个服务器上的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。</p>
<p>• 如果一个candidate或者leader发现自己的任期号过期了，它会立即回到follower状态。</p>
<p>• 如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</p>
<h4 id="2-2-单点故障"><a href="#2-2-单点故障" class="headerlink" title="2.2 单点故障"></a>2.2 单点故障</h4><p>前面几篇介绍过的复制系统，都存在单点故障问题(single point of failure)。</p>
<ul>
<li>mapreduce中的cordinator</li>
<li>GFS的master</li>
<li>VM-FT的test-and-set存储服务器storage</li>
</ul>
<p> 而上述的方案中，采用单机管理而不是采用多实例&#x2F;多机器的原因，是为了避免**脑裂(split-brain)**问题。</p>
<p> 不过大多数情况下，单点故障是可以接受的，因为单机故障率显著比多机出现一台故障的概率低，并且重启单机以恢复工作的成本也相对较低，只需要容忍一小段时间的重启恢复工作。</p>
<p><strong>为什么单机管理能避免脑裂问题</strong> ？</p>
<p>比如有两个strorage，要选出primary，那可能有网络分区的原因，<strong>storage两个分区产生两个primary控制与外界交互</strong>，对外界的client来说有两种不同的数据</p>
<h4 id="2-3-大多数原则-majority-rule"><a href="#2-3-大多数原则-majority-rule" class="headerlink" title="2.3 大多数原则 majority rule"></a>2.3 大多数原则 majority rule</h4><p>如何解决脑裂： 如果投票得大于一半，多数的那个成为leader，也就是多数的分区会继续运行，如果没有获得多少投票的Leader,系统不能运行</p>
<h4 id="2-4-用Raft构造复制状态机RSM"><a href="#2-4-用Raft构造复制状态机RSM" class="headerlink" title="2.4 用Raft构造复制状态机RSM"></a>2.4 用Raft构造复制状态机RSM</h4><p>这里raft就像一个library应用包。假设我们通过raft协议构造了一个由3台机器组成的K&#x2F;V存储系统,以集群内机器数量是3为例</p>
<p>系统正常工作时，大致流程如下：</p>
<ul>
<li>Client向3台机器中作为leader的机器发查询请求</li>
<li>leader机器将接收到的请求记录到底层raft的顺序log中</li>
<li>当前leader的raft将顺序log中尾部新增的log记录通过网络同步到其他2台机器</li>
<li>其他两台K&#x2F;V机器的raft成功追加log记录到自己的顺序log中后，回应leader一个ACK，（如果有一台网络问题比较慢，那也达到了majority）</li>
<li>leader的raft<strong>得知其他机器majority成功将log存储到各自的storage后</strong>，将log操作反映给自己的K&#x2F;V应用（网慢的那台这时候才发ACK）</li>
<li>K&#x2F;V应用实际进行K&#x2F;V查询，并且将结果响应给Client</li>
</ul>
<p>系统出现异常时，发生如下事件：</p>
<ul>
<li>Client向leader请求</li>
<li>leader向其他2台机器同步log并且获得ACK</li>
<li>leader准备响应时突然宕机，无法响应Client</li>
<li>其他2台机器重新选举出其中1台作为新的leader</li>
<li>Client请求超时或失败，重新发起请求，<strong>系统内部failover故障转移</strong>，所以这次Client请求到的是新leader</li>
<li>新leader同样记录log并且同步log到另一台机器获取到ACK</li>
<li>新leader响应Client</li>
</ul>
<h3 id="3-Raft的选举机制"><a href="#3-Raft的选举机制" class="headerlink" title="3. Raft的选举机制"></a>3. Raft的选举机制</h3><p>初始状态，集群中的所有节点都是follower，在Raft中，每个节点等待Leader的心跳的超时时间都是随机的，这样，在节点都是follower的状态下，会有一个节点首先达到超时状态，这时它就会开启一轮选举，自己变成候选人，首先投自己一票，并增加当前的Term，并向其他节点发送选举请求，其他节点给他投票，如果票数超过一半则选举成功。每个节点只能投一票，所有最多只有一个合法的leader被选出来，且选举成功后的leader会定时向follower发heartbeat阻止新一轮的选举。</p>
<p>如果说节点A已经成功了，节点B还在请求选举，如果B在收到投票结果之前收到了A的心跳，那它会转变成follower，如果在收到心跳之前收到了投票结果，节点B也必然是失败的，因为同一任期内一个节点只能投一票，它的票数不够。</p>
<p>随机超时时间也是用来避免无限选举的情况。如果大家的超时时间都是一样的，那么它们会同时成为candidate，那么就很可能你一票我一票，大家都没有超过一半的票，就选不出来，下轮选举并且还有可能这样，所以用随机超时时间。</p>
<p>各类时间的要求：broadcastTime ≪ electionTimeout ≪ MTBF<br>broadcastTime 指的是RPC往返时间，MTBF指的是平均一个服务器的故障时间。</p>
<h4 id="开始选举时机"><a href="#开始选举时机" class="headerlink" title="开始选举时机"></a>开始选举时机</h4><p>Raft内部有一种心跳机制，如果存在leader，那么它就会周期性地向所有follower发送心跳，来维持自己的地位。如果follower一段时间没有收到心跳，那么他就会认为系统中没有可用的leader了，然后开始进行选举。</p>
<p>假设此时某个follower收不到leaders的心跳，election time超时，则该follwer会开始发起重新选举，直到选举产生新的Leader；</p>
<blockquote>
<p>leader term机制确保Leader在当前时刻的唯一性：</p>
<p>如果产生了新的Leader,随着会产生新的leader term，这时候就算原leader接进来，也会发现是新的leader term，而退化为Follower</p>
</blockquote>
<h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>开始一个选举过程后，follower先增加自己的当前任期号，并转换到candidate状态。然后投票给自己，并且并行地向集群中的其他服务器节点发送投票请求（RequestVote RPC）</p>
<p>处理别节点发来的RequestVote RPC时，需要检查限制，满足以下之一才能赞同票：</p>
<ol>
<li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号；或者</li>
<li>候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录的长度</li>
</ol>
<p>成为leader的限制：</p>
<ol>
<li>大多数原则</li>
<li>当选的机器一定是具有最新的term的机器</li>
</ol>
<p>因此，任何一个Server发起选举后，会产生三类结果一种：</p>
<p>• 1. 它获得超过半数选票赢得了选举 -&gt; 成为主并开始发送心跳</p>
<p>• 2. 其他节点赢得了选举 -&gt; 收到新leader的心跳后，如果新leader的任期号不小于自己当前的任期号，那么就从candidate回到follower状态。</p>
<p>• 3. 一段时间之后没有任何获胜者 -&gt; 每个candidate都在一个自己的随机选举超时时间后增加任期号开始新一轮投票。</p>
<blockquote>
<p> 为什么会没有获胜者？比如有多个follower同时成为candidate，得票太过分散，没有任何一个candidate得票超过半数, 如果本轮Term没有选出leader, 那就会进入下一个Term继续选Leader。</p>
</blockquote>
<h4 id="防止选举死循环"><a href="#防止选举死循环" class="headerlink" title="防止选举死循环"></a>防止选举死循环</h4><p>如果两个followers的election time 几乎同时到齐，都成为candidate，那会一直竞争leader死循环;</p>
<p>解决方法： 一般采用election time为随机值，防止同时发起选举</p>
<h4 id="选举超时时间"><a href="#选举超时时间" class="headerlink" title="选举超时时间"></a>选举超时时间</h4><p>选举超时时间的设置是需要平衡的：</p>
<ol>
<li>选举超时时间太短会频繁选举，而选举过程中是对外宕机的情况，会导致降低系统的可用性；</li>
<li>选举超时时间太长检测不到，发起选举的机器此时也是对外宕机的；</li>
</ol>
<p>略大于心跳时间加入些随机数，防止分裂选举死循环</p>
<blockquote>
<p>Raft论文进行了大量实验，以得到250ms～300ms这个在它们系统中的合理值作为eleciton timeout。</p>
</blockquote>
<h3 id="4-Raft的日志同步"><a href="#4-Raft的日志同步" class="headerlink" title="4. Raft的日志同步"></a>4. Raft的日志同步</h3><h4 id="Raft的log"><a href="#Raft的log" class="headerlink" title="Raft的log"></a>Raft的log</h4><p>集群中Leader接收到客户端的指令后，会把指令作为一个新的条目追加到日志中去。一条日志中需要具有三个信息：</p>
<ol>
<li>状态机指令</li>
<li>leader的任期号</li>
<li>日志号（日志索引）</li>
</ol>
<p>为了分布式集群的一致性，需要保证所有机器的log的一致性。</p>
<p>Leader并行发送AppendEntries RPC给follower，让它们<strong>复制该条目</strong>。当该条目被超过半数的follower复制后，leader就可以在本地执行该指令并把结果返回客户端。</p>
<blockquote>
<p>这一步本地执行指令，也就是leader应用日志与状态机这一步，称作提交Apply</p>
</blockquote>
<p>日志的用途：持久化、顺序化的操作数据，方便重传，方面查看同步操作进行的情况</p>
<p>格式：有很多的log entry（入口），比如log index 、 leader term这些唯一标识；每个log entry 有 command 和 leader term信息；</p>
<h4 id="日志覆写同步-未优化版本"><a href="#日志覆写同步-未优化版本" class="headerlink" title="日志覆写同步- 未优化版本"></a>日志覆写同步- 未优化版本</h4><p>leader选出来后，需要保证所有server的log一致性，就会发送RPC进行日志同步</p>
<p>首先需要明确的是Leader上的允许Commit的日志都是正确的，因为这些日志都得到了超过一半的节点的响应。对于Follower日志的错误，本质就是要把他们强制修改为Leader允许Commit的日志。整体来说，分为两步：</p>
<ul>
<li>通过AppendEntries 找到日志冲突点，就是follower从哪个位置开始和leader的日志不一致了。</li>
<li>leader把follower日志冲突点以后的日志强行刷新成自己的。</li>
</ul>
<p> 具体细节就是leader会向follower不间断的发送AppendEntries请求，如果follower返回false的话，那就证明follower和leader不一致。那么leader发送的AppendEntries就会把 prevLogIndex减1再次发送，直至和follower匹配上。匹配成功以后，通过AppendEntries请求将leader上的entries同步至follower。</p>
<p>在所有raft节点维护两个Index</p>
<ul>
<li><p>nextIndex数组：乐观的变量，所有raft节点都维护<code>nextIndex[followerId]</code>用于记录leader认为followerId的下一个需要填充log的index。</p>
<p>更新时间：每个leader当选之后都会乐观的认为所有的follower的nextIndex是自己的log最后的下一个，而在实际appendEntries或者installSnapshot的时候如果发现日志同步没有那么乐观就会根据情况减小next，把之前没有同步的log先同步上。</p>
</li>
<li><p>matchIndex数组：悲观变量，，所有raft节点都维护<code>matchIndex[followerId]</code>用于记录leader认为followerId的已经确认的log最后一个的index，表示在此之前的log都是和当前的leader确认一致的。</p>
<p>更新时间：每个leader当选之后都会悲观的认为自己已经确认过所有的follower的nextIndex是0，因为还没开始确认。</p>
</li>
</ul>
<blockquote>
<p> 未优化版本的问题：Raft集群中有出现log落后很多的server，leader需要进行很多次请求才能将其log与自己对齐</p>
</blockquote>
<h4 id="日志擦除"><a href="#日志擦除" class="headerlink" title="日志擦除"></a>日志擦除</h4><p>新上任的leader发现其他follower有和自己不一样的log，就会把从那个log开始往后的logs都擦除，来保证leader的日志权威性一致性。</p>
<h4 id="日志快速覆写同步-优化版本"><a href="#日志快速覆写同步-优化版本" class="headerlink" title="日志快速覆写同步-优化版本"></a>日志快速覆写同步-优化版本</h4><p>落后较多的log（比如新机器接入、宕机恢复很久）要同步到现在leader一致的话，按照之前的逐步回退很慢，浪费网络资源。</p>
<h5 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h5><p>当拒绝一个AppendEntries RPC的请求的时候，follower可以包含冲突条目的任期号和自己存储的那个任期的<strong>第一个index</strong>,借助这些信息，leader可以跳过那个任期内所有冲突的日志条目来减小nextIndex；这样就变成每个有冲突日志条目的任期需要一个AppendEntries RPC而不是每个条目一次。</p>
<blockquote>
<p>论文里提到认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目；</p>
<p>lab2中会测试高频率的网络分区和机器故障，所以实现了日志快速覆写同步的功能。</p>
</blockquote>
<p>优化后的log catch up quickly过程：</p>
<table>
<thead>
<tr>
<th></th>
<th>logIndex1</th>
<th>logIndex2</th>
<th>logIndex3</th>
<th>logIndex4</th>
<th>logIndex5</th>
</tr>
</thead>
<tbody><tr>
<td>S1</td>
<td>term4</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>S2</td>
<td>term4</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
</tbody></table>
<ol>
<li>S2的leader是term7当选，那nextIndex &#x3D; 6，发送hearbeat随带log是(空, 6, 5)，意思是(当前nextIndex指向的term，nextIndex-1的term, nextIndex-1的值)</li>
<li>S1收到心跳，对比自己的logIndex为term5，与之前不同的是，除了no顺带回复自己的log信息(5,2), 意思是(请求中logIndex位置的值，当前值最早出现的logIndex位置)</li>
<li>S2收到回应后，把nextIndex改为2，下次附带([6,6,6,6],4,1), 意思是nextIndex之后的数据是[6,6,6,6]</li>
<li>S1收到后，检查logIndex1是term4对齐了，更新一致性</li>
</ol>
<p>广播的时候，面对大量followers， 用每个go程单独处理followers</p>
<h4 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h4><p>随着log数量的增大，log会占用大量空间，并且也会导致重放日志的时间变长。所以Raft需要定期做Snapshot，需要保存的信息：</p>
<ul>
<li>状态机当前的状态（根据状态机而定）</li>
<li>状态机最后一条应用的 entry 对应的 index 和 term</li>
</ul>
<p>需要注意的是<strong>状态机当前的状态的数据，Raft层是无法进行解析的，比如一个kv数据库，通常是保存各个kv对，这对于Raft层是透明，因此状态机当前状态的保存和解析是交给上层来完成的，Raft层只做到保存这些数据即可。</strong></p>
<p><strong>在安装快照时，是不允许新的log进行apply的</strong>，因为快照安装结束后会覆盖该条log</p>
<h3 id="5-数据持久化"><a href="#5-数据持久化" class="headerlink" title="5. 数据持久化"></a>5. 数据持久化</h3><p>持久化原因：如果基于raft的服务器重新启动，它应该从停止的地方恢复服务，所以需要Raft将持久化状态写入磁盘，并在冲洗器你懂时从磁盘读取状态。</p>
<p>持久化就是把一些全局的变量（比如currentTerm）写到（持久化存储）磁盘里，当然是在操作回复之前写入，类似于同步过程。</p>
<p>一个Raft节点崩溃重启（和新加入节点一样）后，必须重新加入，除了重新加入重新执行本地的log，更偏向于快速重启，上次持久化快照位置开始，这就要考虑持久化一些状态量：</p>
<ul>
<li>vote for：投票情况，因为需要保证每轮term每个server只能投票一次</li>
<li>log：崩溃前的log记录，<strong>因为我们需要保证(promise)已发生的(commit)不会被回退</strong>。否则崩溃重启后，可能发生一些奇怪的事情，比如client先前的请求又重新生效一次，导致某个K&#x2F;V被覆盖成旧值之类的。</li>
<li>current term：崩溃前的当前term值。因为选举(election)需要用到，用于投票和拉票流程，并且<strong>需要保证单调递增</strong>(monotonic increasing)，如果重启之后不知道任期号，很难确保任期只有一个leader</li>
<li>lastIncludedIndex: 奔溃前的快照保存的最后一个log的index，到这个log位置都是保存在快照中的，也就是状态机的持久化数据，如果崩溃后重启就不用交这个log之前的log了，因为上层可以直接读取整个快照。</li>
<li>lasIncludedIndex: 奔溃前的快照保存的最后一个log的term</li>
</ul>
<h3 id="6-利用快照服务恢复"><a href="#6-利用快照服务恢复" class="headerlink" title="6. 利用快照服务恢复"></a>6. 利用快照服务恢复</h3><p>我们的日志肯定是不可以持续的增长下去的，因为当我们日志数量达到很大的时候，比如说我们的日志数据已经达到了几千万条的时候，我们和一个还没有多少数据的跟随者进行同步的话，需要将这些日志全部发送，其实是十分浪费资源和时间的。</p>
<p>那么我们其实可以使用快照，也就是对领袖某一个时刻它的状态机的数据进行保存，然后将这个快照发送给那些很落后的节点进行快速的同步，同时由于快照已经记录此时的所有必要数据，那么我们可以将这些日志删除，避免日志无限度的增长下去。</p>
<p>利用快照还可以帮助服务重启快速恢复，服务重启恢复时有两种策略：</p>
<ol>
<li>日志重放(replay log)：理论上将log中的记录全部重放一遍，能得到和之前一致的工作状态。这一般来说是很昂贵的策略，特别是工作数年的服务，从头开始执行一遍log，耗时难以估量。所以一般人们不会考虑策略1。</li>
<li>**周期性快照(periodic snapshots)**：假设在i的位置创建了快照，那么可以裁剪log，只保留i往后的log。此时重启后可以通过snapshot快照先快速恢复到某个时刻的状态，然后后续可以再通过log catch up或其他手段，将log同步到最新状态。（一般来说周期性的快照不会落后最新版本太多，所以恢复工作要少得多）</li>
</ol>
<p> 这里可以扩展考虑一些场景，比如Raft集群中加入新的follower时，可以让leader将自己的snapshot传递给follower，帮助follower快速同步到近期的状态，尽管可能还是有些落后最新版本，但是根据后续log catch up等机制可以帮助follower随后快速跟进到最新版本log。</p>
<p> 使用快照时，需要注意几点：</p>
<ul>
<li>需要拒绝旧版本的快照：有可能收到的snapshot比当前服务状态还老</li>
<li>需要保持快照后的log数据：在加载快照时，如果有新log产生，需要保证加载快照后这些新产生的log能够能到保留</li>
</ul>
<h3 id="7-总结使用Raft流程"><a href="#7-总结使用Raft流程" class="headerlink" title="7. 总结使用Raft流程"></a>7. 总结使用Raft流程</h3><p> 重新回顾一下服务使用Raft的大致流程</p>
<ol>
<li>应用程序中集成Raft相关的library包</li>
<li>应用程序接收Client请求</li>
<li>应用程序调用Raft的start函数&#x2F;方法</li>
<li>下层Raft进行log同步等流程</li>
<li>Raft通过apply channel向上层应用反应执行完成</li>
<li>应用程序响应Client</li>
</ol>
<ul>
<li>并且前面提过，可能作为leader的Raft所在服务器宕机，所以Client必须维护server列表来切换请求的目标server为新的leader服务器。</li>
<li>同时，有时候请求会失败，或者Raft底层失败，导致重复请求，而我们需要有手段辨别重复的请求。通常可以在get、put请求上加上请求id或其他标识来区分每个请求。一般维护这些请求id的服务，被称为clerk。提供服务的应用程序通过clerk维护每个请求对应的id，以及一些集群信息。</li>
</ul>
<h2 id="Lab2-Raft具体实现"><a href="#Lab2-Raft具体实现" class="headerlink" title="Lab2 Raft具体实现"></a>Lab2 Raft具体实现</h2><p>下面介绍下 Raft 复制状态机协议 的基本实现和遇到的一些问题</p>
<p>主要实现难点:</p>
<p>故障导致副本一致性受损的各种情况考虑，分布式调试也是比较复杂，因为并发环境下，由于消息通信需要时间，log甚至不可靠，很多条件是否成立需要在当前的环境下重新得到考量。</p>
<p>coding之前想清楚具体实现的逻辑并且考虑一些corner case是否覆盖到，coding过程中用打log方式调试，Debug考虑到测试环境，log不能打太多，也不能太少，最好是做到精准有效。</p>
<p><img src="/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/image-20230508171059069.png" alt="image-20230508171059069"></p>
<h3 id="1-Raft数据结构"><a href="#1-Raft数据结构" class="headerlink" title="1. Raft数据结构"></a>1. Raft数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.Mutex          <span class="comment">// to protect shared acLockcess to this peer&#x27;s state</span></span><br><span class="line">	peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">	commitIndex <span class="type">int</span>   <span class="comment">// 已经commit的最后一个log的index，每个节点的值不一样，但是最后趋于相同</span></span><br><span class="line">	lastApplied <span class="type">int</span>   <span class="comment">// 已经appliy到状态机的最后一个log的index,也就是被执行的指令，每个节点相同</span></span><br><span class="line">	nextIndex   []<span class="type">int</span> <span class="comment">// leader认为的所有server下次需要新得到的log的index,乐观值</span></span><br><span class="line">	matchIndex  []<span class="type">int</span> <span class="comment">// leader保证的所有server的log一致的最后一个，悲观值</span></span><br><span class="line"></span><br><span class="line">	state       <span class="type">uint32</span>  <span class="comment">// 0 follower 1 candidata 2 leader</span></span><br><span class="line">	logs        []Entry <span class="comment">// 日志数组</span></span><br><span class="line">	currentTerm <span class="type">int</span>     <span class="comment">// 当前任期</span></span><br><span class="line">	voteFor     <span class="type">int</span>     <span class="comment">// 当前任期收到选票的candidateId</span></span><br><span class="line"></span><br><span class="line">	electionTime  time.Time     <span class="comment">// 下一次选举的时间点</span></span><br><span class="line">	heartbeatTime time.Duration <span class="comment">// 心跳时间间隔</span></span><br><span class="line"></span><br><span class="line">	applyCh    <span class="keyword">chan</span> ApplyMsg <span class="comment">// 提交操作的应用通道</span></span><br><span class="line">	applyVCond *sync.Cond    <span class="comment">// 提交操作的通道使用的条件变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2D</span></span><br><span class="line">	LastIncludedIndex <span class="type">int</span> <span class="comment">// 快照保存的最后一个log的index</span></span><br><span class="line">	LastIncludedTerm  <span class="type">int</span> <span class="comment">// 快照保存的最后一个log的term</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-RPC的处理"><a href="#2-RPC的处理" class="headerlink" title="2. RPC的处理"></a>2. RPC的处理</h3><p>每个RPC应该在自己的goroutine中发送并处理回复，因为：</p>
<ol>
<li>到不了的peer不会延迟收集选票的过程</li>
<li>electiontime和heartbeattime可以继续在任何时候计时</li>
</ol>
<p>election是并行的给集群中的其它机器发送 RequestVote RPCs</p>
<p>选取投票的写法： 一个函数开始投票，分出很多go程每个单独对接，每个函数对接发RPC和后处理</p>
<h4 id="考虑RPC发送时间"><a href="#考虑RPC发送时间" class="headerlink" title="考虑RPC发送时间"></a>考虑RPC发送时间</h4><p>三个时间的比较： broadcastTime 100 « electionTimeout 200-400 « 平均故障时间</p>
<p>两个RPC ：  AppendEntriesRPCs是 leader进行日志复制和心跳时使用的 &lt;&lt; RequestVoteRPCs是候选在这选举过程中使用的</p>
<p>两个时间驱动用单独的goroutine驱动 </p>
<p>定时的设置考虑到广播时间和超时事件的区别，<strong>把elctiontime作为下一个选举的时间点</strong>，定期检查是否超过这个时间点，如果超过了就要选举，<strong>heartbeattime设置为随机范围内的时间长度</strong>，用sleep相应长度然后发送heartbeat	</p>
<h4 id="一个RPC重试的BUG"><a href="#一个RPC重试的BUG" class="headerlink" title="一个RPC重试的BUG"></a>一个RPC重试的BUG</h4><p>原来的实现：</p>
<p>​	如果appendEntriesLeader发现follower的日志不同步，重新修改后递归appendEntriesLeader，也就是重发RPC直到同步完成。但是因为本身就是上锁的函数，递归调用自己，还要解锁再加锁，就算这样了递归调用不知道有错，错误不匹配后retry，但是第二次还出错会到导致不再retry了。</p>
<p>修改后的实现：</p>
<p>​	retry可能会导致死锁。修改为如果同步失败，则修改nextIndex，等着下一次心跳或者快照来同步。也就是修改为用RPC交互通知Leader下一次尝试发送的log条目的起始位置，这一点在日志快速同步的也使用了</p>
<h3 id="3-RequestVote"><a href="#3-RequestVote" class="headerlink" title="3.RequestVote"></a>3.RequestVote</h3><p>安全性的限制：Raft使用选举过程来保证一个候选者必须包含有所有已提交的日志才能胜出；请求中包含了 leader的日志信息，如<br>果投票者的日志比候选者的日志更新，那么它就拒绝投票 :</p>
<ol>
<li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号；或者</li>
<li>候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录的长度</li>
</ol>
<p>成为leader的限制：</p>
<ol>
<li>大多数原则</li>
<li>当选的机器一定是具有最新的term的机器</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">	Term         <span class="type">int</span></span><br><span class="line">	CandidataId  <span class="type">int</span></span><br><span class="line">	LastLogIndex <span class="type">int</span></span><br><span class="line">	LastLogTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your data here (2A).</span></span><br><span class="line">	Term        <span class="type">int</span></span><br><span class="line">	VoteGranted <span class="type">bool</span> <span class="comment">// 如果canditate当选为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-AppendEntries"><a href="#4-AppendEntries" class="headerlink" title="4. AppendEntries"></a>4. AppendEntries</h3><p>完成了leader election之后，leader会立刻触发一次心跳包，随后在每个心跳周期发送心跳包，来阻止新一轮leader election。<br>Figure 2中<em>Rules for Servers</em>的<em>Leaders</em>部分将心跳称为<code>initial empty AppendEntries RPCs (heartbeat)</code>，将包含log的RPC称为<code>AppendEntries RPC with log entries starting at nextIndex</code>。这种描述听起来像是用了两段不同的代码。<br>而实际上因为这里的心跳有两种理解：每个心跳周期，发送一次AppendEntries RPC，当这个RPC不包含log时，这个包被称为心跳包。所以也有可能发生这么一种情况：触发了一次心跳，但是带有log（即心跳周期到了，触发了一次AppendEntries RPC，但是由于follower落后了，所以这个RPC带有一段log，此时这个包就不能称为心跳包）。</p>
<p>实践中，我在每个心跳周期和收到新的command之后各会触发一次AppendEntries RPC。然而仔细读论文后发现，论文中并没有只说了心跳会触发AppendEntries RPC，并没有说收到客户端的指令之后应该触发AppendEntries RPC。</p>
<p>我甚至认为在理论上AppendEntries可以完全交给heartbeat周期来触发，即收到command后，并不立刻发送AppendEntries，而是等待下一个心跳。这种方法可以减少RPC的数量，并且通过了连续1000次测试。但是代价就是每条command的提交周期变长。</p>
<p><strong>具体实现：</strong></p>
<p>每次当 leader发送 AppendEntries RPCs请求的时候，请求中会包含当前nextIndex后面的日志记录 和 他直接前继的任期和索引，</p>
<ol>
<li><p>如果存在一条日志索引和 prevLogIndex相等，但是任期和 prevLogItem不相同的日志，需要删除这条日志及所有后继日志。</p>
</li>
<li><p>如果 leader复制的日志本地没有，则直接追加存储。</p>
</li>
</ol>
<p>以上两条需要分别进行，如果直接用leader发来的日志记录覆盖follower的日志，那会产生bug，因为这个RPC可能是过时的RPC，所以需要严格保存这两条的分别执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term         <span class="type">int</span></span><br><span class="line">	LeaderId     <span class="type">int</span></span><br><span class="line">	PrevLogIndex <span class="type">int</span></span><br><span class="line">	PrevLogTerm  <span class="type">int</span></span><br><span class="line">	Entries      []Entry</span><br><span class="line">	LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term    <span class="type">int</span></span><br><span class="line">	Success <span class="type">bool</span> <span class="comment">// 是否follower包含prevLogIndex和preLogItem的日志</span></span><br><span class="line">	Xindex  <span class="type">int</span>  <span class="comment">// 告诉leader期望下次发过来的nextIndex</span></span><br><span class="line">	Xterm   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-applyCh"><a href="#5-applyCh" class="headerlink" title="5. applyCh"></a>5. applyCh</h3><p>作为一个ApplyMsg的chan，日志提交之后 需要添加发送的条目</p>
<p>需要用单独的goroutine实现，因为可能阻塞，必须是一个不然难以确保按照日志顺序发送</p>
<p>go程用sync.Cond在不满足发送条件的时候等待, 需要提交的时候唤醒</p>
<blockquote>
<ol>
<li><p>leaderCommit() 的提交log需要检查和当前的term是否一致，如果一致则提交，如果不一致不管。</p>
</li>
<li><p>当leader提交新的log，那么之前的log间接提交，因为 log Matching Property</p>
</li>
</ol>
</blockquote>
<h3 id="6-日志设置"><a href="#6-日志设置" class="headerlink" title="6. 日志设置"></a>6. 日志设置</h3><h4 id="log-entry"><a href="#log-entry" class="headerlink" title="log entry"></a>log entry</h4><ul>
<li><code>entry</code>：Raft 中，将每一个事件都称为一个 entry，每一个 entry 都有一个表明它在 log 中位置的 index（之所以从 1 开始是为了方便 <code>prevLogIndex</code> 从 0 开始）。只有 leader 可以创建 entry。entry 的内容为 <code>&lt;term, index, cmd&gt;</code>，其中 cmd 是可以应用到状态机的操作。在 raft 组大部分节点都接收这条 entry 后，entry 可以被称为是 committed 的。</li>
<li><code>logs</code>：由 entry 构成的数组，只有 leader 可以改变其他节点的 log。 entry 总是先被 leader 添加进本地的 log 数组中去，然后才发起共识请求，获得 quorum 同意后才会被 leader 提交给状态机。follower 只能从 leader 获取新日志和当前的 commitIndex，然后应用对应的 entry 到自己的状态机</li>
</ul>
<h4 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h4><p>nextIndex是leader认为的下次发给其他follower新log的首位置，在当选的时候会自认为所有follower的nextIndex都和自己一样，是自己日志的记录的最后一条的+1位置；</p>
<p>commitIndex是每个server被提交日志后最新log的索引。</p>
<p>lastApplied是每个server提交状态机的最新log的索引。</p>
<p><strong>Raft 保证下列两个性质</strong>：</p>
<ul>
<li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd；</li>
<li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同。</li>
</ul>
<p>通过”仅有 leader 可以生成 entry”来确保第一个性质， 第二个性质则通过一致性检查（consistency check）来保证，该检查包含几个步骤：</p>
<p>leader 在通过 AppendEntriesRPC 和 follower 通讯时，会带上上一块 entry 的信息， 而 follower 在收到后会对比自己的日志，如果发现这个 entry 的信息（index、term）和自己日志内的不符合，则会拒绝该请求。一旦 leader 发现有 follower 拒绝了请求，则会与该 follower 再进行一轮一致性检查， 找到双方最大的共识点，然后用 leader 的 entries 记录覆盖 follower 所有在最大共识点之后的数据。</p>
<p>寻找共识点时，leader 还是通过 AppendEntriesRPC 和 follower 进行一致性检查， 方法是发送再上一块的 entry， 如果 follower 依然拒绝，则 leader 再尝试发送更前面的一块，直到找到双方的共识点。 因为分歧发生的概率较低，而且一般很快能够得到纠正，所以这里的逐块确认一般不会造成性能问题。当然，在这里进行二分查找或者某些规则的查找可能也能够加速一致化。</p>
<h4 id="边界条件考虑"><a href="#边界条件考虑" class="headerlink" title="边界条件考虑"></a>边界条件考虑</h4><p>初始存入 0 0 空作为第一个log，作为dummy节点。</p>
<p>在添加快照功能之后需要把logs[0].index改成lastIncludedIndex。在这之前，保持dummy节点作为锚点不被改变。</p>
<h4 id="快速同步"><a href="#快速同步" class="headerlink" title="快速同步"></a>快速同步</h4><p>实现的主要方法是在reply中添加一个Xindex，每次RPC结束后都通知leader更新nextIndex[serverID]。</p>
<p>如果落后的较多，则返回Xindex为最后一个log的index + 1通知leader发送下次从这个Xindex开始日志串</p>
<p>如果index匹配了，但是term不一致，则按照论文给出的优化方法，找到这个term对应的第一个日志并放到Xindex中存起来，这样 leader接受到响应后，就可以直接跳过所有冲突的日志（其中可能包含了一致的日志）。这样就可以减少寻找一致点的过程。</p>
<h3 id="7-日志提交的一致性如何保证"><a href="#7-日志提交的一致性如何保证" class="headerlink" title="7.日志提交的一致性如何保证"></a>7.日志提交的一致性如何保证</h3><p>leader知道有log entry到达majority servers，他就会commit这个log。</p>
<p>有特殊情况是达到了majority servers但还没commit的leader crash，所以不通过判断majority servers来判断是不是该commit，因为就算达到了majority server之后的leader可能还会全部覆盖。Raft采用只有的currentTerm的leaders的logs被提交，因为选主过程中的<strong>Log Matching Property</strong>原则就已经保证了选出的leader在整个集群中日志的完整性。</p>
<p>Log Matching Property：</p>
<ol>
<li>如果两个日志的两条日志记录有相同的索引和任期，那么这两条日志记录中的命令必然也是相同的。</li>
<li>如果两个日志的两条日志记录有相同的索引和任期，那么这两个日志中的前继日志记录也是相同的</li>
</ol>
<h4 id="applier日志"><a href="#applier日志" class="headerlink" title="applier日志"></a>applier日志</h4><ol>
<li>如果上任leader在提交日志之前宕机，下一任 leader将尝试完成日志的复制。这时候，如果有rf.logs[%v].Term: %v !&#x3D; rf.currentTerm的情况，因为新的leader不能准确判断这个log是不是已经提交，就不能去提交这个log，也就是只提交当前term的日志；</li>
<li>如果在上个term残留的日志后面有新的日志满足提交的条件，因为<strong>Log Matching Property</strong>已经保证了在此之前的日志都是一致性的，那就会把新日志之前的所有log都保证提交，顺便也提交了之前的term残留的log。</li>
</ol>
<h3 id="8-锁的使用"><a href="#8-锁的使用" class="headerlink" title="8. 锁的使用"></a>8. 锁的使用</h3><ol>
<li>考虑修改server的状态变量的时候一定要上锁，</li>
<li>在可能需要wait的操作不要上锁：channel的读写，等待timer，sleep()，发送RPC ，重传RPC（已经删除）</li>
<li>先考虑大粒度的锁，不要提前优化，不过大粒度的锁也要考虑死锁问题</li>
</ol>
<h3 id="9-2C-persistence"><a href="#9-2C-persistence" class="headerlink" title="9. 2C persistence"></a>9. 2C persistence</h3><p>由于我们现在都是保存在内存中的，那么断电即失，因此我们肯定是需要持久化保存起来的，比如说写入磁盘中。由于lab测试方便，官方提供的是一个类<code>Persister</code>来模拟持久化存储的容器，实际上这部分可以换成直接对磁盘的写入进行持久化。</p>
<p>对以下的数据进行更改的时候，都需要进行一次持久化：</p>
<ul>
<li>vote for：投票情况，因为需要保证每轮term每个server只能投票一次</li>
<li>log：崩溃前的log记录，<strong>因为我们需要保证(promise)已发生的(commit)不会被回退</strong>。否则崩溃重启后，可能发生一些奇怪的事情，比如client先前的请求又重新生效一次，导致某个K&#x2F;V被覆盖成旧值之类的。</li>
<li>current term：崩溃前的当前term值。因为选举(election)需要用到，用于投票和拉票流程，并且<strong>需要保证单调递增</strong>(monotonic increasing)，如果重启之后不知道任期号，很难确保任期只有一个leader</li>
<li>lastIncludedIndex: 奔溃前的快照保存的最后一个log的index，到这个log位置都是保存在快照中的，也就是状态机的持久化数据，如果崩溃后重启就不用交这个log之前的log了，因为上层可以直接读取整个快照。</li>
<li>lasIncludedIndex: 奔溃前的快照保存的最后一个log的term</li>
</ul>
<h4 id="2CBUG："><a href="#2CBUG：" class="headerlink" title="2CBUG："></a>2CBUG：</h4><p>TestFigure8Unreliable2C，leader commit判断通过之后，还没有applier就断了或者applier了之后断了，这样一千次</p>
<p>解决: 我理解是考验日志同步速度的问题，添加了快速覆写同步功能，RPC回复校验了冲突的log index来直接发送冲突的日志开始的日志片段，加快log同步速度。 然后我自己考虑了超时时间和心跳时间的设置，也一定程度加快了一致化的速度。</p>
<h3 id="10-2D-快照"><a href="#10-2D-快照" class="headerlink" title="10. 2D 快照"></a>10. 2D 快照</h3><h4 id="InstallSnapshot"><a href="#InstallSnapshot" class="headerlink" title="InstallSnapshot"></a>InstallSnapshot</h4><p>用于日志压缩，拍摄快照以存储当前的状态，那么这个点之前的日志就可以删除。</p>
<p><img src="/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/image-20230504201733607.png" alt="image-20230504201733607"></p>
<p>一般机器单独的进行快照，除非有一个很慢或者新加入的follower需要leader网络发送快照来使其快速追赶</p>
<p>InstallSnapshot RPC</p>
<p>leader发送快照RPC，followers来决定使用；</p>
<ol>
<li>如果快照包含新信息超过follower的logs, 那会完全选择快照覆盖和logs删减；</li>
<li>如果快照比follower的logs短，那prefix覆盖，之后的保留</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term              <span class="type">int</span></span><br><span class="line">	LeaderId          <span class="type">int</span></span><br><span class="line">	LastIncludedIndex <span class="type">int</span></span><br><span class="line">	LastIncludedTerm  <span class="type">int</span></span><br><span class="line">	Data              []<span class="type">byte</span> <span class="comment">// 快照数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term    <span class="type">int</span></span><br><span class="line">	Success <span class="type">bool</span> <span class="comment">// 快照应用情况</span></span><br><span class="line">	Xindex  <span class="type">int</span>  <span class="comment">// 期待下次发过来的log的index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快照和一致性的冲突的</strong>：<br>虽然违背了只有leader修改logs的强领导原则，但是快照的时候一致性已经达成了，所以没有决定是冲突的，数据流还是leader流向follower</p>
<h4 id="快照的时机"><a href="#快照的时机" class="headerlink" title="快照的时机"></a>快照的时机</h4><p><strong>快照拍摄：</strong> 状态机发现自己的目前的存储数据过大，那么就保存当前的状态机必须状态以及日志和Raft的必须状态到快照中。然后通知Raft对自己的日志进行丢弃，也就是调用Raft的<code>Snapshot()</code>。(日志数组第一位要么为空占位日志，也就是一次快照都没进行的时候日志数组下标为0位置的日志，要么为快照后索引为<code>lastIncludeIndex</code>的日志)</p>
<p><strong>快照接收：</strong> 当领袖发送<code>ApppendEntries RPC</code>的时候，发现需要跟随者的<code>nextIndex</code> &lt;&#x3D; 日志数组中第一个日志的索引的时候，也就是需要发送的日志已经被丢弃了，那么就调用<code>InstallSnapshot()</code>来安装快照。</p>
<p>当跟随者接收到领袖发来的快照的时候，若快照是正确的，那么就接收，并通过<code>applyCh</code>传递给状态机。</p>
<p>状态机接收到安装快照的请求，进行快照数据的应用，并且通知Raft去更新到该快照。也就是调用Raft的<code>installSnapshotLeader()</code>。</p>
<p>Raft被调用<code>installSnapshotLeader()</code>之后，对响应的日志进行丢弃。</p>
<h4 id="bug-日志压缩后需要修改index"><a href="#bug-日志压缩后需要修改index" class="headerlink" title="bug - 日志压缩后需要修改index"></a>bug - 日志压缩后需要修改index</h4><p>因为压缩之后logs数组的下标就不是index了，需要修改为真正的index</p>
<ol>
<li><p>lastLog的index可能变成了以一个dummy节点，index &#x3D; 0，需要改成nextIncludedIndex，因为在选举的时候需要判断</p>
</li>
<li><p>nextIndex 等等也需要改</p>
</li>
<li><p>添加一个接口，然后一个个测，改掉所有的下标</p>
<p>func (rf *Raft) GetRealLastLogIndex() int {</p>
<p>  return Max(rf.logs[len(rf.logs)-1].Index, rf.LastIncludedIndex)</p>
<p>}</p>
</li>
</ol>
<h4 id="2d-快照bug"><a href="#2d-快照bug" class="headerlink" title="2d-快照bug"></a>2d-快照bug</h4><ol>
<li><p>先写所有server的快照功能，需要大改下标</p>
<p>解决： 主要是加了rf.GetRealLastLogIndex()函数</p>
</li>
<li><p>快照之后，上一次append还没发出去的Entry会被部分覆盖，也就是说在go程去append 的时候args被其他线程修改了</p>
<p>解决：这个bug改了好久，对go不熟悉，并发的问题，因为之前args.Entry的创建直接用数组切片初始化Entries:    rf.logs[nextindex-rf.LastIncludedIndex:]，可能编译器折叠args.Entry为切片的表达式，也就是并发过程中切片本身变化可能会导致args.Entry的变化。</p>
<p>之后改成了make空间，然后用copy(args.Entries, rf.logs[nextindex-rf.LastIncludedIndex:])赋值，bug解决</p>
</li>
<li><p>crash后恢复的server需要把之前的log重新应用到状态机（这里重新应用logs应该采用提交快照应用），否则直接往后提交新追加的logs是无法提交的，因为lastApplied没有持久化时恢复的时候是0，用日志applier的方式会从log1开始交，但是lastIncludedindex之前的log已经被快照剪短了。</p>
</li>
</ol>
<p>改成make的时候lastApplied和commitIndex都初始化为lastIncludedindex，但是这时候也可能会出现直接提交新的log，而没有实现重新应用之前的log到状态机。这里测试能通过，不清楚什么原因？可能是之前的状态也持久化了？</p>
<p>这里一直有个误区时把加载快照和重新log跑一遍搞混淆了，加载快照后，得到的状态就是快照的最后一个log执行完后的状态，也就是不需要再跑最后一个log之前的log中的命令了。</p>
<p>也即是说真正的原因是在2D之后已经<strong>持久化了快照</strong>，那服务器重启的时候<strong>上层状态机就可以直接读取硬盘中存储的快照</strong>（之前的logs的总和操作），对于重启的server只需要继续添加之后的log就可以了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>现实中raft集群一般是3 5 个，单数防止脑裂，一个服务器损坏的平均情况大概是几个月一次，所以3 5 个足够修复恢复了</li>
<li>服务器遇到的问题会有网络分区联系不上、机器故障挂了等，需要考虑很多种极端情况，比如TestFigure8Unreliable2C当选leader会频繁的掉线，我们需要保证在1000次混乱后还能让raft在10s内成功提交日志， 每一次尝试必须在2s的时间成功提交，对日志同步速度要求很高。</li>
<li>千万不要过早优化。直接使用函数粒度的锁，细粒度的锁在提升性能的同时，会增加复杂度，尤其debug的难度，并且这个难度在复杂的高并发+不可靠的网络背景下可以无限上升。等待debug难度过大，就只能删掉重构了。</li>
</ol>
<p>实现了Raft支持的Leader选举、日志复制、Snapshot、异步Apply等基本功能, 有空看看Paxos，因为这是最经典的一致性算法</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://forthdifferential.github.io">陈锴烺</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://forthdifferential.github.io/2023/11/24/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">https://forthdifferential.github.io/2023/11/24/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://forthdifferential.github.io" target="_blank">个人主页</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/title.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">陈锴烺</div><div class="author-info__description">Every man is the master of his own fortune.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/forthdifferential"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/forthdifferential" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:klchen_auto@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><b>---Welcome to my blog---<br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Raft"><span class="toc-text">Raft</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Raft%E7%AE%80%E4%BB%8B"><span class="toc-text">1. Raft简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. 复制状态机的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%8A%B6%E6%80%81%E7%AE%80%E5%8C%96"><span class="toc-text">2.1 状态简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C"><span class="toc-text">2.2 单点故障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8E%9F%E5%88%99-majority-rule"><span class="toc-text">2.3 大多数原则 majority rule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%94%A8Raft%E6%9E%84%E9%80%A0%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BARSM"><span class="toc-text">2.4 用Raft构造复制状态机RSM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Raft%E7%9A%84%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">3. Raft的选举机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E9%80%89%E4%B8%BE%E6%97%B6%E6%9C%BA"><span class="toc-text">开始选举时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99"><span class="toc-text">选举规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E9%80%89%E4%B8%BE%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">防止选举死循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-text">选举超时时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Raft%E7%9A%84%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5"><span class="toc-text">4. Raft的日志同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft%E7%9A%84log"><span class="toc-text">Raft的log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5-%E6%9C%AA%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-text">日志覆写同步- 未优化版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%93%A6%E9%99%A4"><span class="toc-text">日志擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BF%AB%E9%80%9F%E8%A6%86%E5%86%99%E5%90%8C%E6%AD%A5-%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-text">日志快速覆写同步-优化版本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">如何优化？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="toc-text">日志压缩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">5. 数据持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%A9%E7%94%A8%E5%BF%AB%E7%85%A7%E6%9C%8D%E5%8A%A1%E6%81%A2%E5%A4%8D"><span class="toc-text">6. 利用快照服务恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8Raft%E6%B5%81%E7%A8%8B"><span class="toc-text">7. 总结使用Raft流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab2-Raft%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">Lab2 Raft具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Raft%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1. Raft数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RPC%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">2. RPC的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%99%91RPC%E5%8F%91%E9%80%81%E6%97%B6%E9%97%B4"><span class="toc-text">考虑RPC发送时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AARPC%E9%87%8D%E8%AF%95%E7%9A%84BUG"><span class="toc-text">一个RPC重试的BUG</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-RequestVote"><span class="toc-text">3.RequestVote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AppendEntries"><span class="toc-text">4. AppendEntries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-applyCh"><span class="toc-text">5. applyCh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%97%A5%E5%BF%97%E8%AE%BE%E7%BD%AE"><span class="toc-text">6. 日志设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#log-entry"><span class="toc-text">log entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5"><span class="toc-text">日志同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E8%80%83%E8%99%91"><span class="toc-text">边界条件考虑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%90%8C%E6%AD%A5"><span class="toc-text">快速同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%97%A5%E5%BF%97%E6%8F%90%E4%BA%A4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-text">7.日志提交的一致性如何保证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#applier%E6%97%A5%E5%BF%97"><span class="toc-text">applier日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">8. 锁的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2C-persistence"><span class="toc-text">9. 2C persistence</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2CBUG%EF%BC%9A"><span class="toc-text">2CBUG：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2D-%E5%BF%AB%E7%85%A7"><span class="toc-text">10. 2D 快照</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InstallSnapshot"><span class="toc-text">InstallSnapshot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">快照的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bug-%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9%E5%90%8E%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9index"><span class="toc-text">bug - 日志压缩后需要修改index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2d-%E5%BF%AB%E7%85%A7bug"><span class="toc-text">2d-快照bug</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/24/MIT6.824lab3/" title="分布式 - 基于Raft的简单FT-kv服务（MIT6.824/2023-lab3)"><img src="/imgs/$%7Bfiilename%7D/MIT6.824lab3/title.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - 基于Raft的简单FT-kv服务（MIT6.824/2023-lab3)"/></a><div class="content"><a class="title" href="/2023/11/24/MIT6.824lab3/" title="分布式 - 基于Raft的简单FT-kv服务（MIT6.824/2023-lab3)">分布式 - 基于Raft的简单FT-kv服务（MIT6.824/2023-lab3)</a><time datetime="2023-11-24T13:03:00.988Z" title="发表于 2023-11-24 21:03:00">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/24/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" title="分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)"><img src="/imgs/$%7Bfiilename%7D/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/title.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)"/></a><div class="content"><a class="title" href="/2023/11/24/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" title="分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)">分布式 - Raft介绍和简单实现（MIT6.824/2023-lab2)</a><time datetime="2023-11-24T07:25:03.230Z" title="发表于 2023-11-24 15:25:03">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - GFS论文阅读"><img src="/imgs/$%7Bfiilename%7D/GFS/image-20230411161308484.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - GFS论文阅读"/></a><div class="content"><a class="title" href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - GFS论文阅读">分布式 - GFS论文阅读</a><time datetime="2023-11-21T11:01:26.674Z" title="发表于 2023-11-21 19:01:26">2023-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - MapReduce论文阅读"><img src="/imgs/$%7Bfiilename%7D/MapReduce/image-20230329113648794.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式 - MapReduce论文阅读"/></a><div class="content"><a class="title" href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="分布式 - MapReduce论文阅读">分布式 - MapReduce论文阅读</a><time datetime="2023-11-21T09:01:33.208Z" title="发表于 2023-11-21 17:01:33">2023-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/" title="MySql - MySql必知必会记录"><img src="/imgs/$%7Bfiilename%7D/mysqlbizhibihui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql - MySql必知必会记录"/></a><div class="content"><a class="title" href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/" title="MySql - MySql必知必会记录">MySql - MySql必知必会记录</a><time datetime="2023-11-14T13:39:06.803Z" title="发表于 2023-11-14 21:39:06">2023-11-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 陈锴烺</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>