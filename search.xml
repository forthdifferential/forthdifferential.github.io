<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计网 - 网络是怎样连接的</title>
      <link href="/2023/11/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E9%93%BE%E6%8E%A5%E7%9A%84/"/>
      <url>/2023/11/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E9%93%BE%E6%8E%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h1><h2 id="探索浏览器内容"><a href="#探索浏览器内容" class="headerlink" title="探索浏览器内容"></a>探索浏览器内容</h2><h3 id="生成HTTP请求消息"><a href="#生成HTTP请求消息" class="headerlink" title="生成HTTP请求消息"></a>生成HTTP请求消息</h3><p>URL(uniform resource locator)统一资源定位符<br>FTP (file transfer protocol)文件传送协议<br>HTTP(hypertext transfor protocol) 超文本传送协议<br>TCP（transmission control protocol）传输控制协议<br>UDP（user datagram protocol）用户数据报协议<br>IP（internet protocol）网络互联协议</p><p>浏览器是综合性的客户端软件，需要不同的URL来判断使用哪个功能<br>URL开头部分指明了访问方法(协议)；</p><h4 id="HTTP定义了客户端与服务器之间交互的消息内容和步骤："><a href="#HTTP定义了客户端与服务器之间交互的消息内容和步骤：" class="headerlink" title="HTTP定义了客户端与服务器之间交互的消息内容和步骤："></a>HTTP定义了客户端与服务器之间交互的<strong>消息内容</strong>和<strong>步骤</strong>：</h4><p>内容包括：<br>URI(identifier)：存放网页数据的文件名或者CGI程序的文件名<br>其中CGI(common gateway iterface)通用网关接口 ：web服务器调用其他程序的规则<br>方法：<br>GET POST HEAD OPTIONS PUT DELETE TRACE CONNECT</p><p>Web服务器对其中内容进行解析，完成工作后，结果存放在响应消息中，包括状态码、头字段、网页数据</p><h3 id="向DNS服务器查询Web服务器的IP地址"><a href="#向DNS服务器查询Web服务器的IP地址" class="headerlink" title="向DNS服务器查询Web服务器的IP地址"></a>向DNS服务器查询Web服务器的IP地址</h3><p>TCP&#x2F;IP结构 用集线器链接的计算机形成子网，通过路由器连接成一个大的网络；<br>数据以包的形式传送；</p><p>IP地址： 网络号和主机号；共32位，8比特为一组，十进制表示，圆点隔开；<br>子网掩盖码：写在IP地址右侧，表示IP地址的结构，也可以用网络号的位数表示‘</p><p>DNS(dommain name system)域名服务器系统：用于为各种信息关联相应的名称；<br>DNS解析器用于域名解析，包含在 操作系统的Socket库（操作系统中用于调用网络功能的程序组件几何）中；</p><h3 id="DNS服务器大接力"><a href="#DNS服务器大接力" class="headerlink" title="DNS服务器大接力"></a>DNS服务器大接力</h3><p>控制流程转移；web浏览器——》Socket向DNS查询IP地址——》操作系统内部协议栈；</p><p>DNS接受客户端的查询信息：域名  、Class 、记录类型（A表示IP地址，MX表示邮件服务器）；</p><h4 id="域名层次结构："><a href="#域名层次结构：" class="headerlink" title="域名层次结构："></a>域名层次结构：</h4><ol><li>内部网络服务器数量有限的情况下，可以都保存在一台DNS服务器中；</li><li>多台DNS服务器接力,分层次从后往前缩小，最下层的www为服务器名<br>com的上一层为根域，写法可以省略，根域的IP地址只有13个且不变，一般已经配置在DNS服务器程序中了</li></ol><h4 id="客户端查询过程："><a href="#客户端查询过程：" class="headerlink" title="客户端查询过程："></a>客户端查询过程：</h4><p>最近的DNS服务器——》没有则从根目录自顶向下查找；<br>如果有域名缓存，可以从缓存位置向下查找；</p><p>缓存：使用过的数据存放在离使用该数据较近的高速存储装置中，以提高后续访问速度</p><h4 id="收发数据的操作："><a href="#收发数据的操作：" class="headerlink" title="收发数据的操作："></a>收发数据的操作：</h4><ul><li>1.创建套接字（调用socket）、2.接管道连接到服务器端的套接字上、3.收发数据、4.断开管道并删除套接字；</li></ul><ol><li>创建套接字完成后系统返回 <strong>描述符</strong>，应用程序通过描述符来识别套接字；</li><li>connect连接用到：描述符（应用程序用来识别套接字的机制）、服务器IP地址、端口号（这两个是服务器和客户端实现互相识别对方套接字的机制）</li><li>write和read：接收缓存区</li><li>close：客户端和服务器一端先断开，然后断开操作传到另一端</li></ol><h2 id="用电信号传输TCP-x2F-IP数据——协议栈和网卡"><a href="#用电信号传输TCP-x2F-IP数据——协议栈和网卡" class="headerlink" title="用电信号传输TCP&#x2F;IP数据——协议栈和网卡"></a>用电信号传输TCP&#x2F;IP数据——协议栈和网卡</h2><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908192019506.png" alt="image-20220908192019506"></p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>应用程序——Socket库和解析器——<em>操作系统中的TCP、UDP、IP</em>——网卡驱动程序——硬件网卡</p><p>浏览器、邮件等一般应用程序收发数据时用TCP，DNS查询等收发较短的控制数据时用UDP；<br>网络包：网络中数据的小包（几十到几千字节）；<br>IP协议将网络包发送给通信对象</p><p>套接字作用：记录了用于控制通信操作的各种控制信息，协议栈根据这些信息判断下一步的行动；<br>processID：操作系统为了标识应用程序分配的编号；</p><p>应用程序调用socket创建套接字，协议栈首先分配内存空间，然后写入初始状态，返回描述符给应用程序</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>TCP头部大概有<strong>双方的端口号、初始序号、窗口大小、ACK号、校验、头部长度、控制位</strong>等信息</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193526768.png" alt="image-20220908193526768"></p><p>连接：通信双方交换控制信息，在套接字中记录这些信息并准备数据收发的一连串操作；<br>控制信息：头部中记录的信息和套接字中记录的信息<br>A发送SYN为1的TCP包、创建数据的初始序号、需要的窗口大小——》B返回SYN为1的TCP包、初始序号、窗口大小、返回收到包的ACK号——》B返回收到的ACK号</p><p>TCP模块创建连接控制信息的头部——》找到套接字——》修改状态为正在连接</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>应用程序调用write将数据交给给协议栈，协议栈执行发送操作；</p><ul><li>积累多少数据发送出去判断标准:<strong>1,MTU 2,时间</strong><br>MTU（maximum transmission unit）最大传输单元：每个<strong>网络包</strong>所能容纳的最大长度；一般是1500字节<br>MSS（maximum segment size）最大分段大小：MTU减去头部的长度；也就是实际缓冲区能放的数据量<br>时间主要是看频率，协议栈内部有一个计时器；</li></ul><ol><li>以上两个要素时矛盾的，需要综合考虑，可以指定直接发送</li><li>数据块较大的需要按照MSS拆分</li></ol><ul><li><p>序号和ACK号使用方法——<strong>确认对方是否收到网络包</strong>：<br>连接时将SYN设置为1，并告知初始序号；<br>计算数据长度后发送ACK号，并设置比特为1，表示ACK号有效<br>在返回ACK号确认之前，包都保存在缓冲区，可以重写发送</p></li><li><p>客户端和服务器端双向传输过程</p></li><li><p>网络的错误检测和补偿机制非常复杂；</p></li><li><ol><li>按照ACK返回时间动态调整等待时间；</li><li>滑动窗口管理ACK：接收方通过TCP头部的窗口字段将缓冲区余量告知发送方；发送方在等待ACK返回时继续发送下一个包，但需要在缓冲区余量内。<br>最大数据量称为<strong>窗口大小</strong>：一般就是接收方缓冲区的大小</li><li>ACK和窗口合并，多个ACK时只需要发最后一个以告知接收数据的最后位置——都是为了减少包</li></ol></li><li><p><strong>协议栈接受数据的基本操作</strong>：检查收到的数据库和TCP头部，没有数据确实则返回ACK，将数据放在缓存区，数据拼接为原始数据并交给应用程序（复制到程序的内存空间），最后向发送方发送窗口更新</p></li></ul><h3 id="服务器断开并删除套接字"><a href="#服务器断开并删除套接字" class="headerlink" title="服务器断开并删除套接字"></a>服务器断开并删除套接字</h3><p>例子：服务器端调用Socket库中close程序，协议栈生成包含断开的TCP头部（控制为<strong>FIN设为1</strong>），委托IP模块向客户端发送数据，同时服务端套接字记入断开信息；客户端收到收到TCP头部，协议栈将套接字进入断开状态，并返回给服务器端<strong>ACK号</strong>；协议栈就可以等应用程序取数据了。应用程序read数据，这是协议栈告知应用程序数据收到完成。客户端应用close关闭生成<strong>FIN为1</strong>发送为服务端，服务端<strong>返回ACK</strong>，通信结束。</p><ul><li>删除套接字：需要等待时间以方便重新发送FIN</li></ul><p>总结TCP整体流程：</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908104715535.png" alt="总结TCP整体流程"></p><h3 id="IP和以太网的包收发操作"><a href="#IP和以太网的包收发操作" class="headerlink" title="IP和以太网的包收发操作"></a>IP和以太网的包收发操作</h3><p>mac头部——集线器——子网中的以太网协议（可以更换成其他网络如无线局域网）<br><strong>凡是局域网使用的头部豆角MAC头</strong></p><p>IP头部——IP协议——路由器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193611154.png" alt="image-20220908193611154"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193629305.png" alt="image-20220908193629305"></p><h4 id="包收发操作"><a href="#包收发操作" class="headerlink" title="包收发操作"></a>包收发操作</h4><ol><li>IP模块（包传输过程的入口）：TCP模块委托IP模块发送包，即加上IP头，MAC头，包就封装好了；</li><li>封装好的包交给硬件网卡，将数字信息转换为光电信息，通过集线器、路由器等传递到接收方；</li><li>接收方拿到后做出相应，返回的包被转换为数字信息，加上TCP头部</li></ol><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908145444278.png" alt="image-20220908145444278"></p><p>Gateway网关：在TCP&#x2F;IP中指的是路由器；<br>通过路由表来匹配该把包发给哪个网卡的IP地址；</p><h4 id="以太网内MAC地址查询："><a href="#以太网内MAC地址查询：" class="headerlink" title="以太网内MAC地址查询："></a>以太网内MAC地址查询：</h4><p>ARP（address resolution protocol）地址解析协议：一种地址广播的方法，能返回子网内相应IP地址的MAC地址；</p><p>MAC地址长度为48比特，IP地址长度32比特，也就是6部分，一字节一部分，用-或者：分开，十进制和十六进制表示；<br>media access control</p><p>目前常用的是交换式集线器：信号会更具MAC地址流到指定的设备</p><ul><li><p>以太网特性：</p><ol><li>将包发送到MAC头的接收方MAC地址所代表的的目的地；</li><li>用发送方的MAC地址识别发送方；</li><li>用以太类型识别包类型</li></ol><p>说明：无线局域网也有1和2的特点，所以用来替代以太网</p></li></ul><h4 id="网卡将IP包转化成光电信号（没看）"><a href="#网卡将IP包转化成光电信号（没看）" class="headerlink" title="网卡将IP包转化成光电信号（没看）"></a>网卡将IP包转化成光电信号（没看）</h4><p>网卡中的ROM保存唯一的MAC地址，生产时就写入的，网卡驱动初始化后生效；</p><p>返回接收包：对应MAC地址的包放入缓存区——》产生中断信号，中断控制器，CPU暂时挂起切换到中断程序——》调用网卡驱动执行操作<br>——》从缓冲区中取出包，通过MAC头部中以太类型判断包类型（协议类型）</p><p>接收——》检查IP头部——》如果不一致，返回错误ICMP（查表）</p><h3 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h3><p>TCP复杂是为了实现高效和可靠：缺失部分包的时候只需要发送出错的部分，避免了重发已经送达的包；<strong>（数组在多个包的情况）</strong></p><p>UDP没有连接和断开阶段，只要加上UDP头部，交给IP发送就行了；接收按照IP头部和接收方的地址，UDP头部端口号<strong>（在一个包大小范围内解决）</strong></p><ol><li>UDP只负责单纯发送，不会监控，所以协议栈也不知道有没有错误；</li><li>最大数据长度为IP包减去UDP头部</li><li>音频和视频会使用UDP，确实部分包会失真，但是用TCP要额外的几倍带宽</li></ol><h2 id="网线到网络设备——集线器、交换机、路由器"><a href="#网线到网络设备——集线器、交换机、路由器" class="headerlink" title="网线到网络设备——集线器、交换机、路由器"></a>网线到网络设备——集线器、交换机、路由器</h2><h3 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h3><p>每个包都是独立传输的；</p><p>传输过程：网卡中PHY（MAU）模块将包转化为电信号——》通过RJ-45进入双绞线——》信号流入网线——》集线器的接口；<br>（传输过程中信号会衰减，波形会失真；用<strong>双绞线</strong>来抑制衰减，阻隔噪声措施等）</p><p>——》集线器将信号发送给所有连接在他上面的线路（<strong>原封不动广播</strong>）</p><h3 id="交换机的包转发"><a href="#交换机的包转发" class="headerlink" title="交换机的包转发"></a>交换机的包转发</h3><p>PHY模块接收网线中信号转化为通用格式——》MAC模块将信号转化为数字信号——》包尾部检查FCS——》没异常所有包放到缓冲区——》查询MAC地址表(MAC地址和端口的对应表)——》将信号发送到相应的端口</p><ul><li>交换机的MAC模块不具有MAC地址</li><li>MAC地址表会自动维护，异常时重启交换机重置地址表就行</li><li>全双工模式是交换机特有，可以同时发送和接收操作</li><li>全&#x2F;半双工切换的问题，自动协商功能</li><li>交换机可以同时执行多个转发操作，转发能力强</li></ul><h3 id="路由器的包转发"><a href="#路由器的包转发" class="headerlink" title="路由器的包转发"></a>路由器的包转发</h3><p>路由器是基于IP设计，交换机是基于以太网设计</p><h4 id="路由器转发包过程："><a href="#路由器转发包过程：" class="headerlink" title="路由器转发包过程："></a>路由器转发包过程：</h4><p>通过委托端口接受包（取决于端口通信技术）——转发模块根据接受包的IP头部中记录接收方IP地址，在路由表中查询——》委托端口模块转发包</p><ul><li>端口模块以实际的接收方&#x2F;发送方的身份来收发网络包</li><li>路由器的以太网端口<strong>有MAC地址</strong>，路由器的IP端口<strong>有IP地址</strong></li><li>路由器的子网掩盖码值表示在匹配网络包目标地址时需要对比的比特数，有可能路由聚合合并为一个子网</li></ul><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220909144520902.png" alt="image-20220909144520902"></p><h5 id="路由器接受包"><a href="#路由器接受包" class="headerlink" title="路由器接受包"></a>路由器接受包</h5><ol><li>转化为数字信息，检查MAC地址是否匹配；</li><li>接受操作后包的MAC头部被丢弃（<strong>MAC头部的作用就是将包传递到路由器</strong>）</li></ol><h5 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h5><ol><li>按照IP头部转发，子网掩码配合IP地址，确定候选转发目标</li><li>最长匹配原则</li></ol><h5 id="找不到匹配路由时选择默认路由"><a href="#找不到匹配路由时选择默认路由" class="headerlink" title="找不到匹配路由时选择默认路由"></a>找不到匹配路由时选择默认路由</h5><ol><li>子网掩码<strong>0.0.0.0</strong>，不需要匹配，默认路由，这样配置的网关地址被称为<strong>默认网关</strong></li><li>在找不到其他匹配路由，选择默认路由</li></ol><h5 id="路由器相关工作"><a href="#路由器相关工作" class="headerlink" title="路由器相关工作"></a>路由器相关工作</h5><ul><li><p>TTL：在IP头部，表示保底有效期，经过一个路由器减1,为0就是超过有效期。<br>一般设置为64&#x2F;128，防止信息错误或者路由混乱</p></li><li><p>分片功能拆分大网络包:<br>原因：不同类型线路传输的最大包长度不同；<br>操作：用IP协议中定义的分片功能，对整个包拆分<br>前提：检查MTU，检查IP头部标志字段是否能拆</p></li></ul><blockquote><p>不同于TCP拆分，TCP是在数据拆好后放到包中，也就是一个数据块刚好是包的大小</p></blockquote><h5 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h5><p>判断下一个转发目标：<br>    如果网关列表内容为IP地址，该地址为下一个转发目标；<br>    网关列表为空，则IP头部中的接收方IP地址为下一个转发目标；<br>路由器也会用ARP查询下一个转发目标的MAC地址；         </p><h4 id="路由器和交换机"><a href="#路由器和交换机" class="headerlink" title="路由器和交换机"></a>路由器和交换机</h4><p>所说的加上MAC头，实际是上将IP包装进以太网包的数据部分，委托以太网传输数据，i.e. 路由器把包的传输工作委托给交换机；</p><p><strong>IP（路由器）负责将包发送给通信对象整个过程；</strong></p><p><strong>以太网（交换机）将包传输到下一个路由器；</strong></p><h3 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h3><p>为了解决地址不足分为<strong>私有地址(golbally unique address)，公有地址(public address)</strong></p><p>私有地址是公有地址还没有分配的范围</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220909172640673.png" alt="image-20220909172640673"></p><p>但是公司内部的私有地址不能和互联网直接进行通信，需要通过地址转换机制</p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>地址转换设备（路由器）</p><p>改写端口号，提高公有地址的利用率</p><h2 id="接入网和网络运营商"><a href="#接入网和网络运营商" class="headerlink" title="接入网和网络运营商"></a>接入网和网络运营商</h2><h3 id="ADSL接入网的结构和工作方式"><a href="#ADSL接入网的结构和工作方式" class="headerlink" title="ADSL接入网的结构和工作方式"></a>ADSL接入网的结构和工作方式</h3><p>互联网上万台路由器，按照接收方IP地址判断，将包转发出去；<br><strong>距离的不同和路由的维护方式</strong>不同，就是互联网与家庭、公司网络之间最初主要的两个不同点；</p><p>接入网：连接互联网与家庭、公司网络的通信线路（ADSL、FTTH、CATV、电话线、ISDN等）；<br>ADSL（asymmetric digital subscriber line）不对称数字用户线</p><p>ADSL modem 调制解调器：将包拆分成信元，并且转化为电信号发送给分离器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911135603820.png" alt="image-20220911135603820"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911140104023.png" alt="image-20220911140104023"></p><p>BAS（broadband access server）宽带接入服务器 ，一种<strong>路由器</strong>（不同与普通，具有身份认证，向客户端下发IP地址等配置信息的功能）：1.用户认证的窗口，2.隧道方式传输网络包</p><p>PPP （point to point protocol）点到点协议。电话线、ISDN等通信路线所用的一种协议</p><p>ATM （asynchronous transfer mode）异步传输 ，电话线为载体的通信方式，以“信元”为单位进行。</p><p>FTTH （Fibre (Fiber) To The Home）基于光线的接入网技术：用光纤代替ADSL将用户端接入路由器和运营商的BAS连接起来的接入方式</p><h4 id="分离器的作用"><a href="#分离器的作用" class="headerlink" title="分离器的作用"></a>分离器的作用</h4><p>ADSL modem将信元转化为电信号后，通过分离器，但没作用；（电话和ADSL信号同时流入线路）<br>信号从电话线传入时，分离电话和ADSL信号，防止ADSL成为电话的噪音：<br>        对于电话：分离器过滤掉高频的ADSL；<br>        对ADSL：ADSL modem内部就有信号过滤功能；<br>分离器也可以房子电话对ADSL传输方式的干扰</p><p>分离器——》电话线——》总配线架——》电话局——》DSLAM（转回数字信号 信元）——》BAS（将ATM信元转化为原始的包）</p><h3 id="光纤接入网"><a href="#光纤接入网" class="headerlink" title="光纤接入网"></a>光纤接入网</h3><p>光线的工作原理。。</p><h4 id="FTTH技术"><a href="#FTTH技术" class="headerlink" title="FTTH技术"></a>FTTH技术</h4><ol><li>直连：一种是光纤直接从用户端连接到最近的电话局：以太信号——》光信号——》DSLAM——》BAS转化为电信号，将包转发到互联网内部——》到达互联网后，服务器响应——》响应包的光信号沿着光纤返回</li></ol><p>​光线中波分复用，区别上行和下行信号</p><ol start="2"><li>分路：分光器设备，让光纤分录，同时连接多个用户：OLT和ONU避免碰撞；</li></ol><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911154100876.png" alt="image-20220911154100876"></p><h3 id="接入网中使用的PPP和隧道"><a href="#接入网中使用的PPP和隧道" class="headerlink" title="接入网中使用的PPP和隧道"></a>接入网中使用的PPP和隧道</h3><p>PPPoE（Point to Point Protocol  over Ethernet）以太网的点对点协议：将PPP消息装入以太网包进行传输的方式；</p><p>包原封不动的搬运到另一端，原理上就可以看成建立隧道；</p><p>互联网接入路由器通过PPPoE的发现机制查询BAS的MAC地址（相当于拨号上网中拨号）</p><ul><li>地址转换：是否BAS向计算机下发了TCP&#x2F;IP配置，没下发需要在路由器中转化为公有地址</li></ul><h3 id="网络运营商的内部"><a href="#网络运营商的内部" class="headerlink" title="网络运营商的内部"></a>网络运营商的内部</h3><p>POP(Point of Presense)接入点：ADSL、FTTH等接入网的连接点，互联网的入口在这里</p><p>NOC（Network Operation Center）网络运行中心，（扩大版、高性能的POP）</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911155250806.png" alt="image-20220911155250806"></p><p>按照不同类型的接入网分别使用不同类型的路由器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911160108080.png" alt="image-20220911160108080"></p><h3 id="跨越运营商的网络包"><a href="#跨越运营商的网络包" class="headerlink" title="跨越运营商的网络包"></a>跨越运营商的网络包</h3><p>BGP（border gateway protocol） 边界网关协议：路由信息交换的过程；</p><p>运营商之间所有路由器平等交换，多路判断优先级，收费；</p><p>IX(internet eXchange)互联网交换中心：将运营商汇聚在一起，设置中信设备，减少线路数量；具有高速以太网端口的二层交换机</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911162156742.png" alt="image-20220911162156742"></p><h2 id="服务器端的局域网"><a href="#服务器端的局域网" class="headerlink" title="服务器端的局域网"></a>服务器端的局域网</h2><p>在服务器前部署一个防火墙：只允许发往特定服务器中的特定应用程序的包通过，屏蔽其他的包；常用的是包过滤方式</p><h4 id="包过滤方式（主流防火墙方式）"><a href="#包过滤方式（主流防火墙方式）" class="headerlink" title="包过滤方式（主流防火墙方式）"></a>包过滤方式（主流防火墙方式）</h4><ul><li>设置允许通过的<strong>接收方IP和发送方IP</strong>（注意应答机制，要回复ACK）</li><li>设置端口号限定应用程序，<strong>接收方端口号、发送方端口号</strong></li><li><strong>控制位</strong>判断连接方向（TCP头部的控制位；但是对UDP没有控制位可以设置只能公司内网访问DNS服务器，牺牲便利性）</li><li>对具体数据不能识别风险：一种是持续关注安全漏洞信息并更新软件的版本；一种是在防火墙之外部署用来检查包内容并阻止有害包的设备或软件。</li></ul><p>内网访问公开区域</p><p>外部互联网访问公司内网，默认不能访问，内网到外网的话需要地址转化</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911171030839.png" alt="image-20220911171030839"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911171046135.png" alt="image-20220911171046135"></p><h4 id="通过将请求平均分配给多台服务器来平衡负载"><a href="#通过将请求平均分配给多台服务器来平衡负载" class="headerlink" title="通过将请求平均分配给多台服务器来平衡负载"></a>通过将请求平均分配给多台服务器来平衡负载</h4><p>服务器的访问量上升，需要增加带宽和提高服务器性能；<br>提高服务器性能可以使用多台服务器来分担负载的方法——分布式架构；<br>采用多台Web服务器，减少每台服务器的访问量；<br>用DNS按顺序循环分配多台不同的IP地址——轮询；</p><p>问题：1. 一台宕机了咋办——访问返回失败，尝试下一个IP<br>            2. 有些操作跨多个页面，访问服务器变化则操作无法继续</p><h5 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h5><p>用其IP地址代替Web服务器的实际地址注册到DNS服务器上；</p><p>操作跨多个页面时，请求发送到同一个Web服务器——》判断请求之间的相关性，在HTTP头部加入Cookie<br>其他情况需要定期采集Web服务器的CPU、内存使用率</p><h5 id="缓存服务器"><a href="#缓存服务器" class="headerlink" title="缓存服务器"></a>缓存服务器</h5><p>服务器按照功能划分不同服务器，缓存服务器是一台通过代理机制对数据进行缓存的服务器；<br>代理在Web服务器和客户端之间，Web服务器返回的数据保存在此版中（<strong>缓存</strong>）</p><p>缓存服务器注册到DNS服务器中</p><p>Via: 表示缓存服务器中专的</p><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p>缓存服务器在客户端一侧部署；用作转发过程判断是否允许访问、用作防火墙的实现；</p><ul><li><p>设置时，需要在浏览器的设置窗口的代理服务器中填写正向代理的IP地址</p></li><li><p>有代理时，客户端发送给缓存服务器的请求头不需要直接填写http:&#x2F;&#x2F;这样的完整网址</p></li></ul><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p>服务器端的缓存服务器，将请求消息中URI的吗，目录名与Web服务器进行关联，能转发不带完整网址的请求</p><h5 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h5><p>用包的IP头部中接收方的Ip地址判断访问服务器；</p><p>在消息经过时拦截</p><h3 id="内容分发服务"><a href="#内容分发服务" class="headerlink" title="内容分发服务"></a>内容分发服务</h3><p>缓存服务器放在客户端——降低Web服务器的负载——无法减少互联网的网络流量</p><p>缓存服务器放在Web服务器端——Web服务器无法控制——减少网络流量</p><p>缓存服务器放在互联网的边缘（集合优点，但是互联网都可以访问，部署数量需求多）——服务器运营者能控制——降低网络流量</p><p>内容分发服务：CDN(content delivery network) 或者叫CDS(system)<br>内容分发服务运营商：CDSP(provider)</p><p>提前查询路由器到各个缓存服务器的之间的距离，判断最近的</p><h2 id="请求到达服务器，响应返回浏览器"><a href="#请求到达服务器，响应返回浏览器" class="headerlink" title="请求到达服务器，响应返回浏览器"></a>请求到达服务器，响应返回浏览器</h2><h3 id="服务器的基本信息"><a href="#服务器的基本信息" class="headerlink" title="服务器的基本信息"></a>服务器的基本信息</h3><p>服务器和客户端的协议栈、网卡、Socket库（调用其中的程序组件不一致）等功能一致，TCP&#x2F;IP的功能统一，客户端计算机也可以用作服务器；</p><h5 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h5><p>客户端通信模块一般是与客户端一对一的关系；<br>服务器操作系统具有多任务、多线程功能，同时运行多个程序；<br>：任务作为单个程序，线程是程序的一个部分</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220912222625199.png" alt="image-20220912222625199"></p><p>服务器在调用Socket库上的区别在连接阶段：<br>客户端：用管道连接服务器端的套接字<br>服务器端：1.将套接字设置为等待连接的状态 2. 接受连接</p><p>套接字的确定：客户端IP地址、客户端端口号、服务器IP地址、服务器端口号；</p><p>使用描述符来指代套接字的原因：等待连接的套接字中没有客户端IP地址和端口号、使用描述符比较简单</p><h3 id="服务器接收操作"><a href="#服务器接收操作" class="headerlink" title="服务器接收操作"></a>服务器接收操作</h3><h5 id="服务器接收操作的全过程回顾"><a href="#服务器接收操作的全过程回顾" class="headerlink" title="服务器接收操作的全过程回顾"></a>服务器接收操作的全过程回顾</h5><blockquote><p>网卡（硬件）接收信号，转化为数字信号——》按照包尾部的帧校验符FCS来校验错误——》MAC头部检查接收方的MAC地址——》保存在网卡的缓冲区中</p></blockquote><ul><li>网卡的MAC模块将网络包从信号还原为数字信息，校验FCS并且存入缓冲区</li></ul><blockquote><p>——》CPU处理中断，网卡驱动运行，读取缓冲区的包——》根据MAC头部的以太类型判断协议种类——》调用负责处理该协议的程序（也就是TCP&#x2F;IP协议栈）</p></blockquote><ul><li>网卡驱动按照MAC头部判断协议类型，并且发送个相应的协议栈</li></ul><blockquote><p>——》达到协议栈后，IP模块检查IP头部中接收方IP地址，判断转发——》检查IP头部知道是否分片，如果分片了，现存在内存里，等组装充足后还原为原始包——》检查IP头部的协议号，06则为TCP模块，11为UDP模块</p></blockquote><ul><li>协议栈的IP模块检查IP头部，判断是不是发给自己的，网络包有没有呗切片，对应转发协议栈是TCP还是UDP</li></ul><blockquote><p> ——》TCP模块按照包的内容区别，如果是SYN为1发起连接的包——》检查包的接收方端口号有没有等待连接的套接字——》无则返回ICMP消息，有则创建套接字副本，信息写入套接字生成ACK号，生产TCP头部，委托IP模块发送给客户端——》客户端返回ACK号确认，连接完成——》服务器端及进入调用accept的暂停状态，当将新套接字的描述符转交服务器程序后，服务器恢复运行</p></blockquote><ul><li>TCP模块：根据收到包的发送方&#x2F;接收方的IP地址&#x2F;端口号找到对应的套接字；将数据拼接放在缓冲区；向客户端返回ACK号</li></ul><blockquote><p>——》服务器或者客户端发起，调用Socket库中close，TCP模块生成控制位FIN为1,发送——》客户端或服务器返回一个ACK号，生成FIN为1的TCP头部发送——》服务器或客户端返回ACK号完成</p></blockquote><ul><li>HTTP1.1中，客户端先发起断开；断开操作后，套接字过一段时间被删除</li></ul><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220913140803131.png" alt="image-20220913140803131"></p><h3 id="Web服务程序解释请求消息并做出相应"><a href="#Web服务程序解释请求消息并做出相应" class="headerlink" title="Web服务程序解释请求消息并做出相应"></a>Web服务程序解释请求消息并做出相应</h3><p>最简单的是按照请求方法+URI的HTML文件名获取</p><p>判断访问权限依据：客户端IP地址；客户端域名；用户名和密码</p><h3 id="浏览器接受响应消息并显示内容"><a href="#浏览器接受响应消息并显示内容" class="headerlink" title="浏览器接受响应消息并显示内容"></a>浏览器接受响应消息并显示内容</h3><p>按照Content-Type判断数据类型</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220913142737133.png" alt="image-20220913142737133"></p><p>charset&#x3D;urf-8表示文本编码方式</p><p>Content-Encoding表示压缩格式的具体转换方式</p><p>实际显示是浏览器负责对操作系统发出指令显示的</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>网络是怎样连接的 - 户根勤</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么 你不服气吗？</title>
      <link href="/2023/11/06/test1/"/>
      <url>/2023/11/06/test1/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="怎么-你不服气吗？"><a href="#怎么-你不服气吗？" class="headerlink" title="怎么 你不服气吗？"></a>怎么 你不服气吗？</h1><p><img src="/imgs/$%7Bfiilename%7D/bufuqi.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入信息(退出输入e或exit):&quot;</span>);</span><br><span class="line"><span class="comment">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((s = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;安全退出!!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将读取到的整行字符串转成大写输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt;:&quot;</span> + s.toUpperCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            br.close(); <span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ - 复习STL和泛型</title>
      <link href="/2023/11/06/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/11/06/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一讲：STL和泛型概述"><a href="#第一讲：STL和泛型概述" class="headerlink" title="第一讲：STL和泛型概述"></a>第一讲：STL和泛型概述</h1><h2 id="认识headers、版本、重要资源"><a href="#认识headers、版本、重要资源" class="headerlink" title="认识headers、版本、重要资源"></a>认识headers、版本、重要资源</h2><h4 id="1STL"><a href="#1STL" class="headerlink" title="1STL"></a>1STL</h4><p>1.C++标准库具有6大部件，使用的方法，认识、使用、扩充；</p><p>2.C++SL包括C++STL六大部件和其他零碎的</p><p>3.新式的headers内的组件封装在namespace std</p><h2 id="STL体系架构"><a href="#STL体系架构" class="headerlink" title="STL体系架构"></a>STL体系架构</h2><h4 id="六个部件"><a href="#六个部件" class="headerlink" title="六个部件"></a>六个部件</h4><ol><li>容器containers、分配器allocators、算法algorithms、迭代器iterators、适配器adapters、仿函数Functors</li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221007201443143.png" alt="image-20221007201443143"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大于等于40的数</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>,allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia,ia+<span class="number">6</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),<span class="number">40</span>)));</span><br></pre></td></tr></table></figure><p>not1(bind2nd(less<int>(),40))为一个predicate，谓词</p><ol start="2"><li>复杂度Big-oh 其中n为一个比较大的规模</li></ol><h4 id="“前闭后开”区间用于标准库容器；"><a href="#“前闭后开”区间用于标准库容器；" class="headerlink" title="“前闭后开”区间用于标准库容器；"></a>“前闭后开”区间用于标准库容器；</h4><p>3.1 迭代器定义一<code>contianer&lt;T&gt;::iterator ite =c.begin()</code><br>3.2 <code>for(decl:coll)&#123;statement&#125;</code><br>3.3 <code>for(auto&amp; elem:vec)&#123;elem*=3&#125;;</code></p><h2 id="容器之分类与各种测试"><a href="#容器之分类与各种测试" class="headerlink" title="容器之分类与各种测试"></a>容器之分类与各种测试</h2><h4 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h4><p>sequence contaniners：array、vector 、deque、list、forward_list</p><p>associative contanniers：set&#x2F;multiset、map&#x2F;multimap（STL没有规定怎么实现，一般编译器采用红黑树实现）</p><p>unordered contaniners不定序：unordered_(hash table实现，其用separate chaining创建)</p><ul><li>呼叫时间调用clock()</li><li>全局函数前面加上::，比如<code>::find</code></li><li>容器自身算法有的时候，用容器自身的</li></ul><h4 id="容器扩充"><a href="#容器扩充" class="headerlink" title="容器扩充"></a>容器扩充</h4><p>vector的扩展是两倍扩展，新空间并拷贝原值</p><p>forward_list,一个个扩充</p><p>deque，左右边界满，扩充</p><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>一个类，不建议单独使用，应该用容器本身或者new和delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">allocator&lt;<span class="type">int</span>&gt; alloc1;</span><br><span class="line">p=alloc1.<span class="built_in">allocator</span>(<span class="number">1</span>);</span><br><span class="line">alloc1.<span class="built_in">deallocate</span>(p,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="源代码之分布（VC，GCC）"><a href="#源代码之分布（VC，GCC）" class="headerlink" title="源代码之分布（VC，GCC）"></a>源代码之分布（VC，GCC）</h2><p>2.91源代码的说明</p><h3 id="泛型GP和OOP"><a href="#泛型GP和OOP" class="headerlink" title="泛型GP和OOP"></a>泛型GP和OOP</h3><p>OOP（objective-Oriented programming）企图将date和methods合在一起；</p><p>GP(generic programming)将date和methods分开来</p><ul><li>list不能用sort()，因为不能随机访问，也就不能用二分查找</li></ul><blockquote><p>所有algorithms，其内最终设计元素本身的操作，无非就是比大小；所以类型本身类需要重载比大小操作符</p></blockquote><h3 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h3><ol><li>函数模板 <code>template &lt;typename T&gt;</code></li><li>类模板 <code>template &lt;class T&gt;</code></li><li>成员模板</li></ol><h4 id="类模板中泛化、特化、偏特化"><a href="#类模板中泛化、特化、偏特化" class="headerlink" title="类模板中泛化、特化、偏特化"></a>类模板中泛化、特化、偏特化</h4><h5 id="泛化：操作符重载和模板的复习"><a href="#泛化：操作符重载和模板的复习" class="headerlink" title="泛化：操作符重载和模板的复习"></a>泛化：操作符重载和模板的复习</h5><h5 id="Specialization-特化（全特化）"><a href="#Specialization-特化（全特化）" class="headerlink" title="Specialization 特化（全特化）"></a>Specialization 特化（全特化）</h5><p>在泛化的模板基础上，指定类型</p><p>也就是 <code>class allocator&lt;void&gt;</code> 指定了 _Tp为void类型</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008165726014.png" alt="image-20221008165726014"></p><h5 id="Partial-Specialization-偏特化"><a href="#Partial-Specialization-偏特化" class="headerlink" title="Partial Specialization 偏特化"></a>Partial Specialization 偏特化</h5><p>分为</p><ol><li>数量上（多参数中某些特化）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">People</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类的偏特化 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line">    <span class="comment">// 这句指定了偏特化T2类型到T1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&lt;T1, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(T1 a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>范围上(随意类型到指针 特化为 指针类型 或者const类型)</li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008165747920.png" alt="image-20221008165747920"></p><h1 id="第二讲：STL容器解析"><a href="#第二讲：STL容器解析" class="headerlink" title="第二讲：STL容器解析"></a>第二讲：STL容器解析</h1><h2 id="分配器allocator"><a href="#分配器allocator" class="headerlink" title="分配器allocator"></a>分配器allocator</h2><p>学习目的：理解效率，不要单独用</p><p>operator new()实际上使用malloc（）</p><h5 id="malloc-的理解"><a href="#malloc-的理解" class="headerlink" title="malloc()的理解"></a>malloc()的理解</h5><p>底层都是malloc()和free()使用分配内存;</p><p>malloc()分配时有额外的开销；</p><h5 id="allocators-的两个成员函数"><a href="#allocators-的两个成员函数" class="headerlink" title="allocators()的两个成员函数"></a>allocators()的两个成员函数</h5><p>VC6+中的allocate和deallocate，只是::operator new和::operator delete完成的；</p><p>GC和BC都也是malloc，额外开销有点大；</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器之间的关系"><a href="#容器之间的关系" class="headerlink" title="容器之间的关系"></a>容器之间的关系</h3><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008173455125.png" alt="image-20221008173455125"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008173745929.png" alt="image-20221008173745929"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>实际上里面只有一个指针（G2.9）,G4.9里存了两个指针</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008202939418.png" alt="image-20221008202939418"></p><p>void* 无类型指针：void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void指针赋值。</p><h4 id="简要包括"><a href="#简要包括" class="headerlink" title="简要包括"></a>简要包括</h4><ol><li>一堆typedef</li><li>每个节点的设计</li><li>一些操作符重载</li></ol><h4 id="操作符重载的-符"><a href="#操作符重载的-符" class="headerlink" title="操作符重载的++符"></a>操作符重载的++符</h4><p>前++重载函数无入参；后++一个入参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;node=(link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;<span class="comment">//前++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;self tmp=*<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;<span class="comment">//后++（用后++去调用前++）</span></span><br></pre></td></tr></table></figure><p>C++不允许后++两次；</p><h4 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载*"></a>操作符重载*</h4><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008203508483.png" alt="image-20221008203508483"></p><h4 id="G4-9对G2-9的改进"><a href="#G4-9对G2-9的改进" class="headerlink" title="G4.9对G2.9的改进"></a>G4.9对G2.9的改进</h4><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008203703884.png" alt="image-20221008203703884"></p><h4 id="Iterator需要遵循的原则"><a href="#Iterator需要遵循的原则" class="headerlink" title="Iterator需要遵循的原则"></a>Iterator需要遵循的原则</h4><h6 id="iterator的五种associated-type需要定义出来，以便回答算法调用时的提问；"><a href="#iterator的五种associated-type需要定义出来，以便回答算法调用时的提问；" class="headerlink" title="iterator的五种associated type需要定义出来，以便回答算法调用时的提问；"></a>iterator的五种associated type需要定义出来，以便回答算法调用时的提问；</h6><p>value_type 元素类型</p><p>difference_type距离类型</p><p>iterator_category 迭代器类型：</p><blockquote><p>1、input_iterator：istream独有的迭代器。<br>2、output_iterator：ostream独有的迭代器。<br>3、forward_iterator：继承自input_iterator，单向走的迭代器，只能走一个，不能跳。如forward_list、单向list的hashtable<br>4、bidirectional_iterator：继承自forward_iterator，双向走的迭代器，只能走一个，不能跳。如list、rb-tree、双向list的hashtable<br>5、random_access_iterator：继承自bidirectional_iterator，可以跳的迭代器。如array、vector、deque。</p></blockquote><p>reference</p><p>pointer</p><p>后两种从来没用到</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008205733573.png" alt="image-20221008205733573"></p><h4 id="萃取traits特性"><a href="#萃取traits特性" class="headerlink" title="萃取traits特性"></a>萃取traits特性</h4><p>如果iterator不是一个类，而是指针，不能用typedef咋办？？？？</p><p>方法是增加中间层——萃取机iterator_traits</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008210535103.png" alt="image-20221008210535103"></p><p>第一种是问I，第二种用偏特化区别指针和常量指针</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><strong>实际上是三个指针，大小为12</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008211832130.png" alt="image-20221008211832130"></p><h4 id="容量扩充函数的实现"><a href="#容量扩充函数的实现" class="headerlink" title="容量扩充函数的实现"></a>容量扩充函数的实现</h4><p>当容量不够了，找新空间并两倍成长（有的时候是1.5 看版本），拷贝前部，拷贝后部</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008213508832.png" alt="image-20221008213508832"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008213538716.png" alt="image-20221008213538716"></p><h4 id="traits特性"><a href="#traits特性" class="headerlink" title="traits特性"></a>traits特性</h4><p>G2.9也是依靠萃取机作为中介，区分指针和迭代器类；G4.9也是，只是typedef很多次，评价为乱七八糟</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>没有构造、析构函数</p><p>array&lt;int ,10&gt; myArray;</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011133911387.png" alt="image-20221011133911387"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011134049430.png" alt="image-20221011134049430"></p><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011134328233.png" alt="image-20221011134328233"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ol><li><p>分段连续；</p></li><li><p>扩充时分配新的缓冲区，并且指针指向；</p></li><li><p>iterator有四个元素，node指向控制中心；当cur到达last后，需要通过node指向下一个buffer；</p></li><li><p>控制中心是vector，当缓冲区数量不够的时候，两倍增长；</p></li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011135259752.png" alt="image-20221011135259752"></p><h4 id="简要包括-1"><a href="#简要包括-1" class="headerlink" title="简要包括"></a>简要包括</h4><p>start和finish(iterator)，一个map(T**) ,一个map_type(size_type);其中iterator有四个元素，大小是16；</p><p>总大小是16+16+4+4&#x3D;40；</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011140426560.png" alt="image-20221011140426560"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011141436990.png" alt="image-20221011141436990"></p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>判断指定位置靠近头还是尾&#x3D;》推动原来的元素往前或往后&#x3D;》在指定位置插入新元素</p><h4 id="deque如何模拟连续空间"><a href="#deque如何模拟连续空间" class="headerlink" title="deque如何模拟连续空间"></a>deque如何模拟连续空间</h4><p>全部都是iterator的功劳</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011141645219.png" alt="image-20221011141645219"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142440111.png" alt="image-20221011142440111"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142457558.png" alt="image-20221011142457558"></p><ol><li><p>++调用set_node；–先判断cur</p></li><li><p>后++调用前++</p></li><li><p>+调用+&#x3D;；+&#x3D;的时候，判断有没有超出当前缓冲区，并调整缓冲区位置</p></li><li><p>-调用-&#x3D;；-&#x3D;调用+&#x3D;{return *this +&#x3D; -n;}</p></li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142758686.png" alt="image-20221011142758686"></p><h4 id="G4-9对G2-9的改进-1"><a href="#G4-9对G2-9的改进-1" class="headerlink" title="G4.9对G2.9的改进"></a>G4.9对G2.9的改进</h4><ol><li>deque类继承；</li><li>入参去掉了buffer_size，只有两个了</li></ol><h3 id="queue和stack"><a href="#queue和stack" class="headerlink" title="queue和stack"></a>queue和stack</h3><p>这两个是容器适配器；</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011150245087.png" alt="image-20221011150245087"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011150254672.png" alt="image-20221011150254672"></p><h5 id="一些特性："><a href="#一些特性：" class="headerlink" title="一些特性："></a>一些特性：</h5><ol><li>不允许遍历，不提供iterator；</li><li>包含deque，并且封锁一些接口；这两者实际上list也可以作为底层容器，但是慢；stack也可以用vector作为底层容器，queue不能，因为没有pop()操作；都不能用set和map作为底层；</li></ol><h3 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h3><h4 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h4><p>红黑树是平衡二叉搜索树中常被使用的一种；排序规则有利search和insert，并保持高度平衡；</p><p>红黑树提供遍历和iterators；按照正常规则遍历，就能得到排序状态；</p><p>不应使用iterators改变元素值，但是编程里面有没有禁止此。如此设计，是因为rb_tree即将为set和map服务，map允许元素的date被改变，只有元素的key才是不可改变的；</p><p>红黑树提供两种insertion操作：inset_unique()和insert_equal()</p><h4 id="容器re-tree"><a href="#容器re-tree" class="headerlink" title="容器re_tree"></a>容器re_tree</h4><p>value分为key和date两部分</p><p>模板参数5个</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011154503636.png" alt="image-20221011154503636"></p><p>使用举例</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011155147816.png" alt="image-20221011155147816"></p><h4 id="G4-9对G2-9的修改"><a href="#G4-9对G2-9的修改" class="headerlink" title="G4.9对G2.9的修改"></a>G4.9对G2.9的修改</h4><p>改为容器_Rb_tree</p><p>新版是24个字节</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011155838022.png" alt="image-20221011155838022"></p><h3 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h3><p>内含红黑树，set也是一个container adapter容器适配器</p><p>set的key就是value；</p><p>set的迭代器是const_iterator，不能修改</p><p>inset_unique()和insert_equal()的区别</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011215003032.png" alt="image-20221011215003032"></p><h3 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h3><p>以rb_tree为底层结构，自动排序</p><p>无法用iterators改变元素的key，但是可以改变date；底层实现的iterator就是红黑树的，不做任何约束，但是在模板参数设置时<code>pair&lt;const Key,T&gt; value_type</code>  </p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011221046294.png" alt="image-20221011221046294"></p><p>multimap不能用[]插入</p><blockquote><p>lower_bound二分查找，在有序数列中查找与value相同第一元素的迭代器，如果没有则返回第一个&gt;&#x3D;value的元素的迭代器，再没有就返回end()；也就是说不破坏排序得以安插value的第一个适当的位置;</p></blockquote><p> <strong>既然[]判断元素不存在的时候，也是调用insert，直接调用insert比较快</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011221344136.png" alt="image-20221011221344136"></p><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>散列表比红黑树简单</p><p>如果发送碰撞，用链表串Separate Chaining在一起;但是链表太长（元素个数比桶个数多），要把它打散，就是把桶扩大一倍，并取最近的素数（实际上备选的list中元素已经预选好）作为新的桶个数，所有元素重新计算一遍；</p><p>![image-20221011223731538](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221011223731538.png)</p><p>模板参数6个：Value, Key, HasFcn, ExtractKey, EqualKey, Alloc</p><p>Data大小19(20)：hash(1), equals(1), get_key(1), buckets(12),num_elements(4)</p><p>![image-20221013160407487](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013160407487.png)</p><p>HashFunction的设置</p><p>![image-20221013163528922](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013163528922.png)</p><h3 id="unordered容器"><a href="#unordered容器" class="headerlink" title="unordered容器"></a>unordered容器</h3><p>![image-20221013164353617](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013164353617.png)</p><h1 id="第三讲：STL算法"><a href="#第三讲：STL算法" class="headerlink" title="第三讲：STL算法"></a>第三讲：STL算法</h1><p>算法是模板函数，其他都是模板类；</p><p>算法看不到容器，所有信息都由迭代器告知</p><p>两种形式，包含Cmp和不包含：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Cmp&gt;</span></span><br><span class="line"><span class="function"><span class="title">Algorithm</span><span class="params">(Iterator itr1,Iterator it2,Cmp comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Random Access和不能；双向和单向</p><h3 id="迭代器的分类继承图"><a href="#迭代器的分类继承图" class="headerlink" title="迭代器的分类继承图"></a>迭代器的分类继承图</h3><p>这样的好处是，用萃取提取迭代器的类型是，可以用不同入参的类型重载提取函数</p><p>![image-20221013170117951](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170117951.png)</p><p>![image-20221013170857286](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170857286.png)</p><p>在头文件typeinfo中函数typeid()，能得到编译后的类型名称</p><p>![image-20221013170950813](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170950813.png)</p><h3 id="istream-iterator和ostrean-iteraror"><a href="#istream-iterator和ostrean-iteraror" class="headerlink" title="istream_iterator和ostrean_iteraror"></a>istream_iterator和ostrean_iteraror</h3><p>这两种的iterator_category</p><p>![image-20221013171729243](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013171729243.png)</p><p>![image-20221013171734578](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013171734578.png)</p><h3 id="逆向迭代器reverse-iterator"><a href="#逆向迭代器reverse-iterator" class="headerlink" title="逆向迭代器reverse_iterator"></a>逆向迭代器reverse_iterator</h3><p>调用迭代器适配器</p><p>![image-20221014140726217](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014140726217.png)</p><h3 id="iterator对算法的影响"><a href="#iterator对算法的影响" class="headerlink" title="iterator对算法的影响"></a>iterator对算法的影响</h3><h4 id="distance算法"><a href="#distance算法" class="headerlink" title="distance算法"></a>distance算法</h4><p>：返回值，输入参数</p><ol><li>其中randomaccess类型只需要相减，但是input类型只能一步步操作，差异非常大</li><li>distance()调用子函数_distance()的不同重载，这是常见的处理方法</li></ol><p>![image-20221013190247992](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013190247992.png)</p><h4 id="advance-算法"><a href="#advance-算法" class="headerlink" title="advance()算法"></a>advance()算法</h4><p>与distance不同，这里用iterator_category()函数返回迭代器的类型</p><p>![image-20221013191224717](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013191224717.png)</p><h4 id="copy-算法"><a href="#copy-算法" class="headerlink" title="copy()算法"></a>copy()算法</h4><p>![image-20221013194550327](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013194550327.png)</p><h4 id="destroy-算法"><a href="#destroy-算法" class="headerlink" title="destroy()算法"></a>destroy()算法</h4><p>![image-20221013192424286](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013192424286.png)</p><h4 id="unique-copy-算法"><a href="#unique-copy-算法" class="headerlink" title="unique_copy()算法"></a>unique_copy()算法</h4><p>![image-20221013192928038](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013192928038.png)</p><h4 id="小结对算法的影响"><a href="#小结对算法的影响" class="headerlink" title="小结对算法的影响"></a>小结对算法的影响</h4><p>继承可以翻译为is a</p><p>算法源码对迭代器类型的暗示是通过形参的名字告诉你，但是必须接受所有类型的迭代器；</p><p>![image-20221013194419258](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013194419258.png)</p><h2 id="算法例子剖析"><a href="#算法例子剖析" class="headerlink" title="算法例子剖析"></a>算法例子剖析</h2><p>按照算法的标准样式，区别STL的算法和普通函数</p><h3 id="算法例子11个"><a href="#算法例子11个" class="headerlink" title="算法例子11个"></a>算法例子11个</h3><h4 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate()算法"></a>accumulate()算法</h4><p>第三个参数可以是自定义函数或者仿函数的对象</p><p>![image-20221014135321464](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135321464.png)</p><h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each()算法"></a>for_each()算法</h4><p>![image-20221014135418453](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135418453.png)</p><h4 id="replace-算法"><a href="#replace-算法" class="headerlink" title="replace()算法"></a>replace()算法</h4><p>![image-20221014135440211](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135440211.png)</p><h4 id="count-算法"><a href="#count-算法" class="headerlink" title="count()算法"></a>count()算法</h4><p>迭代器类型非random_access的不能用</p><p>关联容器用自带的快多了</p><p>![image-20221014135546161](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135546161.png)</p><h4 id="find-算法"><a href="#find-算法" class="headerlink" title="find()算法"></a>find()算法</h4><p>迭代器类型非random_access的不能用</p><p>关联容器用自带的快多了</p><p>![image-20221014135744390](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135744390.png)</p><h4 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort()算法"></a>sort()算法</h4><p>关联容器自带排序的</p><p>![image-20221014140156822](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014140156822.png)</p><h4 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search()算法"></a>binary_search()算法</h4><p>调用lower_bound()二分搜寻</p><p>归纳后：</p><p>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>![image-20221014141107968](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014141107968.png)</p><h2 id="仿函数functors"><a href="#仿函数functors" class="headerlink" title="仿函数functors"></a>仿函数functors</h2><p>函数对象，类中重载小括号，STL定义很多仿函数</p><p>![image-20221014143544712](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014143544712.png)</p><h4 id="仿函数可适配的条件"><a href="#仿函数可适配的条件" class="headerlink" title="仿函数可适配的条件"></a>仿函数可适配的条件</h4><p>：需要继承一元和二元仿函数的基类，也就是unary_function或者binary_function其中一个。继承之后，才可回答被仿函数适配器的提问，实参的类型是什么。</p><p>![image-20221014143605807](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014143605807.png)</p><h2 id="适配器Adapters"><a href="#适配器Adapters" class="headerlink" title="适配器Adapters"></a>适配器Adapters</h2><p>改造器，要改造原有的部件的功能，用内含而不是继承的方式包含原有的部件</p><p>存在多种适配器：Contanier Adapters, Functor Adapters, Iterator Adapters</p><p>![image-20221014153946103](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014153946103.png)</p><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>stack,queue内含的deque并且改造函数接口</p><p>![image-20221014153956095](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014153956095.png)</p><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><p>修饰function形成function的样子</p><h4 id="bind2nd-函数和binder2nd函数对象"><a href="#bind2nd-函数和binder2nd函数对象" class="headerlink" title="bind2nd()函数和binder2nd函数对象"></a>bind2nd()函数和binder2nd函数对象</h4><ol><li><p>less<int>()和40被记在binder2nd类的Data中，等之后类内operatpr()调用后再拿出来用；</p></li><li><p>bind2nd()函数返回临时对象binder2nd;</p></li><li><p>适配器操作后，需要询问算法的入参（1或2个参数的类型）和结果（返回值的类型）</p></li><li><p>![image-20221014154005666](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014154005666.png)</p></li></ol><h4 id="新型适配器-，bind来取代原有的"><a href="#新型适配器-，bind来取代原有的" class="headerlink" title="新型适配器 ，bind来取代原有的"></a>新型适配器 ，bind来取代原有的</h4><p>![image-20221014154134036](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014154134036.png)</p><h4 id="not1"><a href="#not1" class="headerlink" title="not1()"></a>not1()</h4><p>一元谓词；</p><p>记录入参，返回<code>!pred</code>，C17已经弃用</p><h4 id="bind-和占位符"><a href="#bind-和占位符" class="headerlink" title="bind()和占位符"></a>bind()和占位符</h4><p>新版STL中取代之前的函数对象和函数</p><ol><li>对于函数，绑定对象，设置占位符以备之后调用函数时作为入参；占位符<code>_1</code>和<code>_2</code>的就是参数的顺序</li><li>还可以改变模板参数，绑定返回类型比如<code>bind&lt;int&gt; (my_divide,10,2)</code>;</li><li>还可以把成员函数，绑定给要做用的对象，比如<code>auto f1=bind(&amp;MyPair::multiply,_1);f1(ten_two);</code></li></ol><p>![image-20221014155526664](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014155526664.png)</p><p><strong>std::bind可以绑定</strong>：</p><ol><li>functions;</li><li>function objects;&#x2F;&#x2F;这种是注释讲了，也就是把方程改为仿函数</li><li>member functions,_1必须是个object地址;&#x2F;&#x2F;比如说<code>auto f1 = bind(&amp;MyPair::multiply,ten_two);</code></li><li>date member，_1必须是某个object地址；&#x2F;&#x2F;比如说<code>auto f1 = bind(&amp;MyPair::b,_1);</code>,调用<code>f1(ten_two)</code>只会输出成员b的数，这个很特别</li></ol><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><h4 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h4><p>![image-20221014162046483](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014162046483.png)</p><h4 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h4><p>不同于赋值assign，重载操作符，使得&#x3D;变为insert操作</p><p>![image-20221014163840295](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014163840295.png)</p><h3 id="X适配器"><a href="#X适配器" class="headerlink" title="X适配器"></a>X适配器</h3><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p>输出迭代器的适配器，直接用于输出;</p><p>实现方式也是用重载算法的操作符operator&#x3D;为&lt;&lt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(std::cout,<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>(),out_it);</span><br></pre></td></tr></table></figure><p>![image-20221015113148564](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015113148564.png)</p><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>输出迭代器的适配器</p><p>实现是重载算法的operator&#x3D;为&gt;&gt;</p><p>没有参数的作为标兵，有参数的绑定输如cin，读当前it指向的值，++往下读；</p><p>![image-20221015114603355](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015114603355.png)</p><p>下面这个连算法的first和last迭代器都改为了iit和eos，但是算法流程框架没变，第三个参数insert(c,c.begin())重载了&#x3D;为insert操作；</p><ul><li>当创建了istream_iterator后，这个类自动实现++也就是立刻read，往下进行。</li></ul><p>![image-20221015114949021](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015114949021.png)</p><h1 id="第四讲-STL其余体系结构"><a href="#第四讲-STL其余体系结构" class="headerlink" title="第四讲 STL其余体系结构"></a>第四讲 STL其余体系结构</h1><h3 id="一个万用的hash-fuction"><a href="#一个万用的hash-fuction" class="headerlink" title="一个万用的hash fuction"></a>一个万用的hash fuction</h3><ol><li>其中…是省略一些参数的写法, <strong>variadic templates</strong>可变化的模板，可以放任意的参数</li><li>每一个分出来seed，计算出，最后当做hashcode，一直到全部拆解完成加上hashcode</li><li>hash_combine()中seed的计算用的是黄金分割</li></ol><p>![image-20221015150133530](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150133530.png)</p><p>用例尝试，作为unordered_set的hashfunction(第二参数)</p><p>![image-20221015150909323](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150909323.png)</p><p>![image-20221015150932418](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150932418.png)</p><h3 id="tuple，用例"><a href="#tuple，用例" class="headerlink" title="tuple，用例"></a>tuple，用例</h3><p>一些数据的组合，相对于pair</p><p>![image-20221015153445595](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015153445595.png)</p><ol><li>创建用括号初始化，也可以用make_tuple创建</li><li>取出成员用get&lt;1&gt;(t1)</li><li>整个tuple可以用于比较，相同成分的tuple比较，不同成分tuple的比较</li><li>整个tuple可以互相赋值，整个tuple可以cout</li><li>可以初始刷为具体的值，然后用tie绑定变量到值</li><li>tuple_size<t1>::value可以得到tuple的成员数；tuple_element&lt;1,t1&gt;::type f1&#x3D;10可以获得指定元素的类型；</li></ol><h4 id="tuple实现"><a href="#tuple实现" class="headerlink" title="tuple实现"></a>tuple实现</h4><p>还是用到<strong>variadic templates</strong>；tuple类继承他自己，递归继承他的尾部，头部作为成员数据，用于声明变量；当为空就结束</p><p>![image-20221015155218423](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015155218423.png)</p><h3 id="type-traits原编程"><a href="#type-traits原编程" class="headerlink" title="type traits原编程"></a>type traits原编程</h3><p>C++ 提供元编程设施，诸如类型特性、编译时有理数算术，以及编译时整数序列。</p><p>利用特化偏特化，判断构造函数、拷贝构造、析构函数等重不重要</p><p>![image-20221015161257834](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161257834.png)</p><p>C++11中定义了很多的元编程，用于各种类型的查询</p><p>![image-20221015161808849](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161808849.png)</p><p>![image-20221015161851035](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161851035.png)</p><h4 id="用traits分析string"><a href="#用traits分析string" class="headerlink" title="用traits分析string"></a>用traits分析string</h4><p>实际上使用string，是调用<code>basic_string&lt;char&gt;</code></p><p>![image-20221015162105748](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015162105748.png)</p><h4 id="traits实现"><a href="#traits实现" class="headerlink" title="traits实现"></a>traits实现</h4><p>基本都是泛化和偏特化实现的</p><p>remove_const和remove_volatile，用特化来拿掉</p><p>_is_void用特化返回void类型，实现</p><p>![image-20221015165340384](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165340384.png)</p><p>is_integral</p><p>![image-20221015165633636](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165633636.png)</p><p>调用编译过程的接口，找不到源代码，grep的工具可以查看</p><p>![image-20221015165652628](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165652628.png)</p><p>![image-20221015170030086](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170030086.png)</p><h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout的类型为_IO_ostream_withassign，继承自ostream，其中重载了和对不同入参的&lt;&lt;操作、</p><p>![image-20221015170847219](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170847219.png)</p><p>![image-20221015170907392](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170907392.png)</p><h3 id="moveable元素（移动构造）"><a href="#moveable元素（移动构造）" class="headerlink" title="moveable元素（移动构造）"></a>moveable元素（移动构造）</h3><h4 id="对于vector速度效能的影响"><a href="#对于vector速度效能的影响" class="headerlink" title="对于vector速度效能的影响"></a>对于vector速度效能的影响</h4><p>加入move功能的容器，速度上效率会高</p><p>其中MCtor是有move功能的构造函数。CCtor是没有move功能的构造函数。</p><p>其中std::move()是有move的拷贝构造。</p><h4 id="对list的影响"><a href="#对list的影响" class="headerlink" title="对list的影响"></a>对list的影响</h4><p>list是逐个创建，时间效率差距不大；deque其实也影响不大；</p><p>但是除了创建，其他操作可能也有影响</p><h4 id="一个moveable类"><a href="#一个moveable类" class="headerlink" title="一个moveable类"></a>一个moveable类</h4><p>是一种浅拷贝，并且在析构中判断是否要delete指针</p><p>![image-20221015172804821](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015172804821.png)</p><p>![image-20221015172812092](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015172812092.png)</p>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Modelica - Modelica语言学习</title>
      <link href="/2023/11/06/modelica%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/06/modelica%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h2><p>1.新建package-》新建modelica类</p><p>2.找组件modelica–&gt;mechanics–&gt;translational–&gt;components等；找信号源blocks–&gt;sources等</p><p>3.模件进行连接</p><p>4.元件设置参数</p><p>5.仿真-仿真设置</p><h2 id="二、模型类化"><a href="#二、模型类化" class="headerlink" title="二、模型类化"></a>二、模型类化</h2><p>打开类看单个构件的建模语言</p><p>新建类–&gt;扩展 （选库中类的)–&gt;在扩展类中写方程–&gt;调用到modelica类中使用</p><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote><p><strong>变量声明：</strong></p><ol><li>类型：Real，Integer, Boolean,String,enumeration</li><li>前缀：input, output, parameter;</li><li>可见性：public， protected;</li></ol><p><strong>注释：</strong><br> 1.单行；多行；<br> 2.引号注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real foo &quot; A special comment&quot;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real x[3,3]=&#123;1,2,3;4,5,6;4,5,6&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>标注：</strong>annotation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equation</span><br><span class="line">der(x) = 1-x ”Drives value of x toward 1.0”;</span><br><span class="line">annotation(experiment(StartTime=0,StopTime=8));//定义模型仿真开始和结束的时间</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>标注中包含的信息与模型的属性没有直接联系，只是提供进行模拟仿真的条件</p><ol><li><p>对变量、语句（方程）、继承：紧跟在一个声明的后面，并且在标示符 ; 的前面 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real length ”Rod length” annotation(...);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li><li><p>模型标注数据直接在模型自身定义的时候声明</p></li></ol><ul><li><p>标注中即可以包含对变量的赋值，也可以包含对一些内部变量的修改</p></li><li><p>标注就是为了方便模型开发者将任意数据添加到模型中而设计的，</p></li><li><p>可以同时多个标注，</p></li><li><p>只要标注的名称不同，我们就可以一次加入多个。</p><p>​：在加入零件号时，最好要将其放一个特别 的变量内。这个变量最好应该和你的公司或者应用情况相关，而且足够特别 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotation(XogenyIndustries(PartNumber=”FF78-E4B879”),</span><br><span class="line">experiment(StartTime=0,StopTime=8));</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>变量 XogenyIndustries 可以为某个特定组织或目的创建出一个“命名空间”</p></li><li><p>几种标准标注：Documentation；experiment；Evaluate；HideResult（P37）</p></li></ul><p><strong>逻辑运算符：</strong><br> and , or, not,&lt;,&gt;,&lt;&gt;,&lt;&#x3D;, &gt;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if &lt;condition&gt; then</span><br><span class="line">...</span><br><span class="line">elseif &lt;condition&gt; then</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>循环：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in1:10 loop</span><br><span class="line">  ...</span><br><span class="line">end for;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h2 id="四、函数语法"><a href="#四、函数语法" class="headerlink" title="四、函数语法"></a><strong>四、函数语法</strong></h2><blockquote><p><strong>分区标志符</strong></p><p>​    函数内容：alogrithm<br>​     局部变量：protected</p><p><strong>参数默认值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input Real tol=le-5 &quot;Input with default value&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>多个输出变量:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line">  function demo_fuction</span><br><span class="line">    input Real in1&quot;The first input demo function&quot;;</span><br><span class="line">    input Real in2&quot;The second argument&quot;;</span><br><span class="line">    output Real out1&quot;The first output for demo&quot;;</span><br><span class="line">    output Real out2&quot;The second output for demo&quot;;</span><br><span class="line">    </span><br><span class="line">    /*(out1,out2)=demo(in1,in2)*/</span><br><span class="line">  protected//局部变量</span><br><span class="line">    Real p1;</span><br><span class="line">  algorithm</span><br><span class="line">       p1:=in1-in2;</span><br><span class="line">     out1:=in1+in2;</span><br><span class="line">     </span><br><span class="line">     out2:=in1*in2;</span><br><span class="line">     </span><br><span class="line">     p1:=in1-in2;</span><br><span class="line">     </span><br><span class="line">  end demo_fuction;</span><br><span class="line">end demo;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>调用:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(out1,out2)=Fuctions.demo_fuction(in1=10,in2=20);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><p>函数测试：右键调用inputs，结果检验；</p><blockquote><p>例题：将致密矩阵M转化为存储格式的稀疏矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function  coo</span><br><span class="line">  input Real M[:,:] &quot;Input dense matrix&quot;;</span><br><span class="line">  input Real tol = le-5 &quot;M[i,j]&lt;tol is considered empty. Tolerance value&quot;;</span><br><span class="line">  </span><br><span class="line">  output Integer rows[:] &quot;Row indices&quot;;</span><br><span class="line">  output Integer cols[:] &quot;Colum indices&quot;;</span><br><span class="line">  output Real data[:] &quot;values&quot;;</span><br><span class="line">protected</span><br><span class="line">  Integer r_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Integer c_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Real d_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Integer counter;</span><br><span class="line">algorithm</span><br><span class="line">  counter := 0;</span><br><span class="line">  for i in 1:size(M, 1) loop</span><br><span class="line">    for j in 1:size(M, 2) loop</span><br><span class="line">      if abs(M[i, j]) &gt; tol then</span><br><span class="line">        counter := counter + 1;</span><br><span class="line">        r_temp[counter] := i;</span><br><span class="line">        c_temp[counter] := j;</span><br><span class="line">        d_temp[counter] := M[i, j];</span><br><span class="line">      end if;</span><br><span class="line">    end for;</span><br><span class="line">  end for;</span><br><span class="line">  rows := r_temp[1:counter];</span><br><span class="line">  cols := c_temp[1:counter];</span><br><span class="line">  date := d_temp[1:counter];</span><br><span class="line">end coo;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h2 id="五、等式语法"><a href="#五、等式语法" class="headerlink" title="五、等式语法"></a>五、等式语法</h2><p>modelica各元素的组合关系</p><p>变量-表达式-等式组件-系统</p><blockquote><p>语法不同于其他语言，掌握核心</p><p>核心：通过<strong>等式</strong>建立起变量之间的关系，并使<strong>未知变量数量与等式变量一致</strong></p></blockquote><h3 id="model-x2F-block结构"><a href="#model-x2F-block结构" class="headerlink" title="model&#x2F;block结构"></a><strong>model&#x2F;block结构</strong></h3><blockquote><p>model ModeName”模型描述（非必要）”<br>  &#x2F;&#x2F;声明状态变量，参数，输入&#x2F;输出变量等<br> initial equation<br>     &#x2F;&#x2F;初始化等式<br> equation<br>     &#x2F;<em>构建已知未知量之间的关系的等式</em>&#x2F;<br> end ModeName;</p></blockquote><h3 id="等式语法-基本等式"><a href="#等式语法-基本等式" class="headerlink" title="等式语法-基本等式"></a>等式语法-基本等式</h3><p>构建已知与未知或未知与未知量之间的关系</p><blockquote><p>格式： &lt;表达式1&gt;&#x3D;&lt;表达式2&gt;</p></blockquote><p>&#x3D;不表示赋值，无因果关系</p><h3 id="条件等式"><a href="#条件等式" class="headerlink" title="条件等式"></a>条件等式</h3><p>表达形式1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x= if a&gt;b then sin(time) else cos(time);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>表达形式2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if a&gt;b then</span><br><span class="line">        x=sin(time);</span><br><span class="line">else</span><br><span class="line">        x=cos(time);</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1.方程的平衡形式：<br> 核心是要保持等式数量不变，等式有if一定有else；<br> 变量的数量必须等于方程的数量，而且，在模拟的过程中方程的数量必须是固定的</p><p> 2.不平衡形式：<br> ​​​​​​​if 和 else 两侧的方程数量是不同的<br> 仅当 ：模拟过程中条件表达式的值不能改变 ；方程的数量在模拟过程中不能改变；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">parameter Boolean steady_state;</span><br><span class="line">initial equation</span><br><span class="line">if steady_state then</span><br><span class="line">der(x) = 0;</span><br><span class="line">der(y) = 0;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果布尔参数 steady_state（稳定状态）为真，那么初始方程是有效的。但是如果参数为假， 它们就无效。这里的条件表达式具有参数级别的可变性是因为，表达式仅仅包含一个变量，而这个变量 是个参数。</p></blockquote><h3 id="初始值等式"><a href="#初始值等式" class="headerlink" title="初始值等式"></a><strong>初始值等式</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initial equation </span><br><span class="line">        x=3;</span><br><span class="line">        der(y)=0;</span><br><span class="line">        z=p0;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="注意：变量定义域；检验等式平衡性"><a href="#注意：变量定义域；检验等式平衡性" class="headerlink" title="注意：变量定义域；检验等式平衡性"></a>注意：变量定义域；检验等式平衡性</h3><h1 id="五、MSL"><a href="#五、MSL" class="headerlink" title="五、MSL"></a>五、MSL</h1><blockquote><p>Modelica.Blocks</p><ul><li>包含强因果关系的模型</li><li>一般包含一个或多个input和output连接器</li><li>一般用于信号生成及信号处理<br> 多用于辅助物理模型，而不是建构</li></ul><p>Modelica.Blocks.Sources<br> 信号源输出</p></blockquote><blockquote><p>差值模块<br> Modelica.Blocks.Tables.CombiTable1Ds一维单变量差值</p><ul><li>用作信号源</li><li>数据模型</li></ul></blockquote><hr><h1 id="一、基本方程"><a href="#一、基本方程" class="headerlink" title="一、基本方程"></a>一、基本方程</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real T_inf(unit=”K”)=298.15 ”Ambient temperature”;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 1.关键字parameter 表明变量的 值是先验已知的（即仿真开始之前）<br> 2.每个变量的声明部分都包含与变量相关联的物理单元文本 (unit&#x3D;”…”): ”1” 代表值没有物理 单位,。另一方面””（默认没有给定值）表明物理单位不确定。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">model NewtonCoolingWithTypes ”Cooling example with physical types”</span><br><span class="line">// Types</span><br><span class="line">type Temperature=Real(unit=”K”, min=0);</span><br><span class="line">type ConvectionCoefficient=Real(unit=”W/(m2.K)”, min=0);</span><br><span class="line">type Area=Real(unit=”m2”, min=0);</span><br><span class="line">type Mass=Real(unit=”kg”, min=0);</span><br><span class="line">type SpecificHeat=Real(unit=”J/(K.kg)”, min=0);</span><br><span class="line">// Parameters</span><br><span class="line">parameter Temperature T_inf=298.15 ”Ambient temperature”;</span><br><span class="line">parameter Temperature T0=363.15 ”Initial temperature”;</span><br><span class="line">parameter ConvectionCoefficient h=0.7 ”Convective cooling coefficient”;</span><br><span class="line">parameter Area A=1.0 ”Surface area”;</span><br><span class="line">parameter Mass m=0.1 ”Mass of thermal capacitance”;</span><br><span class="line">parameter SpecificHeat c_p=1.2 ”Specific heat”;</span><br><span class="line">// Variables</span><br><span class="line">Temperature T ”Temperature”;</span><br><span class="line">initial equation</span><br><span class="line">T = T0 ”Specify initial value for T”;</span><br><span class="line">equation</span><br><span class="line">m*c_p*der(T) = h*A*(T_inf-T) ”Newton’s law of cooling”;</span><br><span class="line">end NewtonCoolingWithTypes;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>一旦定义了一个物理类型比如 Temperature，我们可以使用它为多 个变量（例如 T、T_inf 和 T0）进行声明</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real x(start=5, fixed=true);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li>start 属性的主要目的是（正如在初始化 ( 31) 那节里广泛讨 论过的）为状态变量提供“备用”的初始状态。</li><li>start 属性的也可以用于变量，是迭代变量时的初始假想值。</li><li>最后，如果一个 parameter 没有明确指定的值，那么 start 属性的值可以作为 parameter 的默认值。</li></ol><p>在声明变量的 start 属性时直接指 定其初始条件；变量的 fixed 属性被 用来通知编译器 start 属性必须作为初始条件来使用</p><p>start 属性的其中一个作用是提供初始化猜想值：因为该变量必须通过系统的非线性方程组来 求解。这也就意味着，我们要对变量 x 和 y 的 start 属性值进行指定，以尽量“避开”系统的零解（或 者说至少接近我们期望的非零解）</p></blockquote><blockquote><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model QuiescentModelWithInheritance ”Steady state model with inheritance”</span><br><span class="line">extends ClassicModel;</span><br><span class="line">initial equation</span><br><span class="line">der(x) = 0;</span><br><span class="line">der(y) = 0;</span><br><span class="line">end QuiescentModelWithInheritance;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>从 ClassicModel 模型中复制（或“继承”） 其包含的所有内容，而无需重复定义。因此，除了新加入的初始化方程外，QuiescentModelWithInheritance 模型和 ClassicModel 模型其他部分完全一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model QuiescentModelWithModifications ”Steady state model with modifications”</span><br><span class="line">extends QuiescentModelWithInheritance(gamma=0.3, delta=0.01);</span><br><span class="line">end QuiescentModelWithModifications;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>允许对模型加入相应的“修改语句”</p><ul><li>按照惯例，extends 子句通常列在模型定义最上方，在任何变量之前</li></ul></blockquote><blockquote><h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><p>type NewTypeName &#x3D; BaseTypeName(&#x2F;* attributes to be modified *&#x2F;);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Temperature = Real(unit=”K”); // Could be a temperature difference</span><br><span class="line">type AbsoluteTemperature = Temperature(min=0); // Must be positive</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>BaseTypeName（基本类型名称）一般为内置类型（比如 Real（实数））。但是它也可以是另外一种派生 类型。这意味着多层次的限定也是支持的。</p></blockquote><blockquote><h2 id="Record-类型"><a href="#Record-类型" class="headerlink" title="Record 类型"></a>Record 类型</h2><p>record 类型可以有自己的变量，但是不允许包含方程。record 类型主要用于数据的分组</p><p>定义record；创建record：记录构造函数输入record类型内部定义匹配的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">record Vector ”A vector in 3D space”</span><br><span class="line">Real x;</span><br><span class="line">Real y;</span><br><span class="line">Real z;</span><br><span class="line">end Vector;</span><br><span class="line"></span><br><span class="line">parameter Vector v = Vector(x=1.0, y=2.0, z=0.0);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h1 id="二、离散行为"><a href="#二、离散行为" class="headerlink" title="二、离散行为"></a>二、离散行为</h1><p>事件是任何在系统内触发了某种不连续性的东西：<br> “时间事件”：发生在某个特定时间的事件是最简单的一类事件；<br> “状态事件”：等到某信号越过特定阈值</p><p>time 是一个内置在所有 Modelica 模型内的变量</p><blockquote><p> T_inf &#x3D; 298.15 - (if time&lt;0.5 then 0 else 20*(time-0.5));<br> T_inf &#x3D; 298.15 - max(0, 20*(time-0.5));&#x2F;&#x2F;用max表示环境温度的变化</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">model NewtonCooling</span><br><span class="line">//Types</span><br><span class="line">type Temperature=Real(unit=&quot;K&quot;,min=0);</span><br><span class="line">type ConvectionCoefficient=Real(unit=&quot;W/(m2.k)&quot;,min=0);</span><br><span class="line">type Area=Real(unit=&quot;m2&quot;,min=0);</span><br><span class="line">type Mass=Real(unit=&quot;kg&quot;,min=0);</span><br><span class="line">type SpecificHeat=Real(unit=&quot;J/(K.kg)&quot;,min=0);</span><br><span class="line"></span><br><span class="line">//Parameters</span><br><span class="line">parameter Temperature T0=363.15&quot;Initial temperature&quot;;</span><br><span class="line">parameter ConvectionCoefficient h=0.7&quot;Convective cooling coefficient&quot;;</span><br><span class="line">parameter Area A=1.0&quot;Surface area&quot;;</span><br><span class="line">parameter Mass m=0.1&quot;Mass of thermal capacitance&quot;;</span><br><span class="line">parameter SpecificHeat c_p=1.2&quot;Specific heat&quot;;</span><br><span class="line"></span><br><span class="line">//Variables</span><br><span class="line">Temperature T_inf&quot;Ambient temperature&quot;;</span><br><span class="line">Temperature T &quot;Temperature&quot;;</span><br><span class="line"></span><br><span class="line">initial equation</span><br><span class="line">  T=T0&quot;Specify initial value for T&quot;;</span><br><span class="line">equation</span><br><span class="line">  if time&lt;=0.5 then</span><br><span class="line">    T_inf=298.15&quot;Constant temperature when time &lt;=0.5&quot;;</span><br><span class="line">  else</span><br><span class="line">    T_inf=298.15-20*(time-0.5)&quot;Otherwise,increasing&quot;;</span><br><span class="line">  end if;</span><br><span class="line">  m*c_p*der(T)=h*A*(T_inf-T)&quot;Newton&#x27;s law of cooling&quot;;  </span><br><span class="line"></span><br><span class="line">end NewtonCooling;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>问题：0x000002错误</p><p>另：可以用初始方程，方程从平衡态开始</p><blockquote><p>if表达式代替if语句</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/06/hello-world/"/>
      <url>/2023/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS - 计算机操作系统复习思维导图</title>
      <link href="/2023/11/06/ComputerSysMind/"/>
      <url>/2023/11/06/ComputerSysMind/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系-基础-思维导图"><a href="#操作系-基础-思维导图" class="headerlink" title="操作系-基础-思维导图"></a>操作系-基础-思维导图</h2>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网 - 计算机网络复习思维导图</title>
      <link href="/2023/11/06/ComputerNetMind/"/>
      <url>/2023/11/06/ComputerNetMind/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="计算机网络-中间三层协议-思维导图"><a href="#计算机网络-中间三层协议-思维导图" class="headerlink" title="计算机网络-中间三层协议-思维导图"></a>计算机网络-中间三层协议-思维导图</h1><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_0.png"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_1.png"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_2.png"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_3.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_4.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>计算机网络第七版- 谢希仁</li><li><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&vd_source=e249eb5e70a068ab71d1537db21d292b">https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e249eb5e70a068ab71d1537db21d292b</a></li><li><a href="https://xiaolincoding.com/network/5_learn/learn_network.html">https://xiaolincoding.com/network/5_learn/learn_network.html</a></li><li>网络是怎样连接的 - 户根勤</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
