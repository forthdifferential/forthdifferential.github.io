<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法 - 基础算法</title>
      <link href="/2023/11/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h1><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1. 快排"></a>1. 快排</h3><p>分治，选一个数，左边都小于等于数，右边都大于等于数，换完之后x不一定在分界点</p><ul><li>难点是划分</li><li>scanf比流输入快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = IntStream.range(<span class="number">0</span>, n).map(i -&gt; in.nextInt()).toArray();</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, n).mapToObj(i -&gt; arr[i] + <span class="string">&quot; &quot;</span>).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l ,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l -<span class="number">1</span>, j = r +<span class="number">1</span>, x = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; x)&#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; x)&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quick_sort(arr, l, j);</span><br><span class="line">        quick_sort(arr,j+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l ,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j-- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j ) <span class="built_in">swap</span> (q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-归并"><a href="#2-归并" class="headerlink" title="2. 归并"></a>2. 归并</h3><ol><li>[L,R]-&gt;[L, mid], [mid + 1, R]</li><li>递归排序[L, mid], [mid + 1, R]</li><li>归并，将左右两个有序序列合并为一个有序序列</li></ol><ul><li>重点是合二为一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N], temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先划分</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(p, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(p, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt;= p[j]) temp[k++] = p[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++] = p[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) temp[k++] = p[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) temp[k++] = p[j++];</span><br><span class="line">    <span class="comment">//还给p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span> ; i&lt;= r; i++, j++) p[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(p, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-求逆序对"><a href="#2-1-求逆序对" class="headerlink" title="2.1 求逆序对"></a>2.1 求逆序对</h4><p>当q[j]加入归并的下一个值时，q[i]之前的数都小于等于q[j],q[i]之后的数都大于q[j]。</p><p>所以此时q[j]加入合并消除的逆序对是q[i]到q[mid]之间的所有的数(之间的数都大于q[j])。</p><p>注意：我之前写错的方式使用了j - i + 1，但是j到mid + 1之间数本来就在j之前，没有消除逆序对，所以正确的应该是mid - i + 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N],temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">merge_sort</span>(p, l, mid) + <span class="built_in">merge_sort</span>(p, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 归并过程</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt;= p[j]) temp[k++] = p[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = p[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>; <span class="comment">// 消除的逆序对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)  &#123;</span><br><span class="line">      temp[k++] = p[i++];</span><br><span class="line">      <span class="comment">// 扫尾不用加上下面这句，因为之前合并的时候mid - i + 1意思是当前i以后的所有数字都大于j，包含了扫尾的那些数，然后每个j都处理了一次，在扫尾的时候就不用重复处理了</span></span><br><span class="line">        <span class="comment">// 这时候i就是mid-1</span></span><br><span class="line">      <span class="comment">// res += mid - i + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) temp[k++] = p[j++];</span><br><span class="line">    <span class="comment">// 物归原主</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) p[i] = temp[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">merge_sort</span>(p, <span class="number">0</span>, n<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-整数二分"><a href="#3-整数二分" class="headerlink" title="3.整数二分"></a>3.整数二分</h3><p>一般有单调性可以二分，有时候没有单调性也能二分。二分的本质不是单调性，是边界性。</p><ul><li><p>分为两个部分，<strong>一半部分满足条件，另一半不满足条件，就能够找到这个边界</strong></p></li><li><p>按照边界是属于左半边还是右半边的条件，可以分为两个模板。两个模板分别要记熟悉，否则边界条件经常错误。</p></li><li><p>注意这里是求得的边界情况是满足check()函数的最后一个边界，也是就是边界情况考虑&lt;&#x3D; 或者 &gt;&#x3D;,因为最后返回的值是l</p></li></ul><blockquote><p>实际做的思路：</p><ol><li><p>先写一个mid &#x3D; l + r &gt;&gt; 1，写一个check函数，把结果控制在边界位置;</p></li><li><p>想一下如何更新l 和 r ,如果l &#x3D; mid 那就要补上加一 mid &#x3D; l + r + 1 &gt;&gt; 1 ，如果 r &#x3D; mid 就不用补上</p></li><li><p>l 和 r 相差 1，这个不变</p></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个大于等于 x 的数</span></span><br><span class="line"><span class="keyword">if</span> (p[mid] &gt;=  x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个小于等于x的数</span></span><br><span class="line"><span class="keyword">if</span> (p[mid] &lt;= x) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-1-求数占的区间"><a href="#3-1-求数占的区间" class="headerlink" title="3.1 求数占的区间"></a>3.1 求数占的区间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q; </span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= a[mid]) r = mid; <span class="comment">// [l, mid]和[mid + 1, r]</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[l] != num) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,l);</span><br><span class="line">        </span><br><span class="line">         l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span> (num &gt;= a[mid]) l = mid; <span class="comment">// [l, mid - 1]和[mid, r]</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[l] != num) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-浮点数二分"><a href="#4-浮点数二分" class="headerlink" title="4.浮点数二分"></a>4.浮点数二分</h3><ol><li>不用怎么考虑边界问题，小到一定的位数1e-6就可以把边界当做答案</li><li>精度问题可以自己调整： 如果题目保留4位小数，精度写1e-6; 5位，1e-7;至少要多2</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-大整数"><a href="#5-大整数" class="headerlink" title="5.大整数"></a>5.大整数</h3><ol><li>存储： 大整数存储一般倒着存到数组中，因为加法可能要进位，在数组尾部加一个数更方面，否则正着放需要全部都往后移</li></ol><h4 id="5-1-高精度加法"><a href="#5-1-高精度加法" class="headerlink" title="5.1 高精度加法"></a>5.1 高精度加法</h4><p>反向存储，输出反向输出 （因为要进位，需要在高位上补数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 别忘了第一位 可能进位</span></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-高精度减法"><a href="#5-2-高精度减法" class="headerlink" title="5.2 高精度减法"></a>5.2 高精度减法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 去掉前置 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A,vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B [i]) <span class="keyword">return</span> A[i] - B[i] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-高精度乘以低精度"><a href="#5-3-高精度乘以低精度" class="headerlink" title="5.3 高精度乘以低精度"></a>5.3 高精度乘以低精度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 要么A没算完，要么t不等于0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-4-高精度除以低精度"><a href="#5-4-高精度除以低精度" class="headerlink" title="5.4 高精度除以低精度"></a>5.4 高精度除以低精度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6. 前缀和"></a>6. 前缀和</h3><p>快速求出一段元素的和</p><ul><li>把边界S[0] &#x3D; 0,然后从S[1]开始往后存，因为要用S[r] - S[l-1]来计算前缀和，所以把边界0先存进去</li></ul><h4 id="6-1-一维前缀和"><a href="#6-1-一维前缀和" class="headerlink" title="6.1 一维前缀和"></a>6.1 一维前缀和</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="6-2-二维前缀和"><a href="#6-2-二维前缀和" class="headerlink" title="6.2 二维前缀和"></a>6.2 二维前缀和</h4><ul><li>注意是x1 - 1， y1 - 1；这个写的时候要想好，别忘了-1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="7-差分"><a href="#7-差分" class="headerlink" title="7. 差分"></a>7. 差分</h3><p>差分和前缀和是逆运算。如果B数组是A数组的前缀和，那么A是B的差分，也就是 a[i] &#x3D; b[i] - b[i-1];</p><ul><li>首先是假想一个B数组是差分数组，使得a &#x3D; f(b)。 b[i] &#x3D; a[i] - a[i-1]; b[1] &#x3D; a[1];</li><li>差分不用考虑差分数组的构造，直接插一遍元素就行insert(i, i, a[i])。因为按照原理，假定a数组最开始全是0，那么一开始b就是a的差分数组，对于每一个a[i]，相当于插入一个数，只不过是插入的范围是 i 到 i。</li><li>这里insert既做了差分的初始化，又做了插入数据的操作。</li></ul><h4 id="7-1-一维差分"><a href="#7-1-一维差分" class="headerlink" title="7.1 一维差分"></a>7.1 一维差分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B是A的差分数组，给区间[l, r]中的A每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><h5 id="7-1-1-差分例题"><a href="#7-1-1-差分例题" class="headerlink" title="7.1.1 差分例题"></a>7.1.1 差分例题</h5><p>向A数组一定区间插入数c，这样的插入有很多组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把插入的操作从O(N) 转到 O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="comment">// 初始化差分数组</span></span><br><span class="line">        <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">// b[i] = a[i] - a[i-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间插入c</span></span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还原A</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = b[i] + a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-二维差分"><a href="#7-2-二维差分" class="headerlink" title="7.2 二维差分"></a>7.2 二维差分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br><span class="line">    </span><br><span class="line">    <span class="number">1.</span><span class="built_in">insert</span>()函数 b[x1][y1] += c, [x1][y2 + <span class="number">1</span>] -= c, b[x2 + <span class="number">1</span>][y1] -=c, b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] +=c;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> 所以还原A矩阵就是a [i][j] = b[i][j]+ a[i<span class="number">-1</span>][j] + a[i][j<span class="number">-1</span>] - a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><h3 id="8-双指针"><a href="#8-双指针" class="headerlink" title="8. 双指针"></a>8. 双指针</h3><ul><li>从暴力的N2变成O(N),利用单调关系</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不满足 j++</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ; <span class="comment">// 右边是 i，左边是j，也就是对于每个i，j最左能到什么情况。而j具有单调性，只能往右走(因为上一次的j就是移动到不满足check(i,j)函数为止)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h3 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9. 位运算"></a>9. 位运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>求n的二进制表示中第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n <span class="comment">// 如果是n是1100，lowbit(n) = 100</span></span><br><span class="line">    <span class="comment">// 原理是 x&amp;-x = x&amp;(~x +1) x取反再加1</span></span><br><span class="line">    <span class="comment">// -x 是 </span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 反转第k位二进制数 k = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2.</span>..</span><br><span class="line">    i^(<span class="number">1</span> &lt;&lt; k); <span class="comment">// 0变1, 1变0.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于有符号整数：</span><br><span class="line">正数的原码符号位是<span class="number">0</span>， 负数的符号位是<span class="number">1</span>，符号位一般是最高位    </span><br><span class="line">正数的反码等于本身，负数的反码除将其绝对值的原码的每一位取反而得到的：用于表示负数</span><br><span class="line">正数的补码等于本身，负数的补码等于绝对值的原码的符号位改为<span class="number">1</span>，然后加<span class="number">1</span>来表示的：计算机中没有减法，减法看做是加法的补码操作</span><br><span class="line">    （在计算机中负数用原码的补码来表示）</span><br><span class="line">    比如  <span class="number">6</span>是<span class="number">00.</span>.<span class="number">.0110</span>， <span class="number">-5</span>是 <span class="number">11.</span>.<span class="number">.1001</span></span><br></pre></td></tr></table></figure><h3 id="10-离散化"><a href="#10-离散化" class="headerlink" title="10.离散化"></a>10.离散化</h3><p>数域跨度很大，实际用到的数个数不大，数很<strong>稀疏</strong>（总不能开个很大的数组求前缀和吧，所以需要用到映射）</p><ul><li><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p></li><li><p>离散化首先需要排序去重：</p></li><li><pre><code class="cpp">1. 排序：sort(alls.begin(),alls.end())2. 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// 离散化，映射到数组a[i]中，下标是离散化后对应的自然数，值是原数</span><br><span class="line">vector&lt;int&gt; alls; // 存储所有待离散化的值</span><br><span class="line">sort(alls.begin(), alls.end()); // 将所有值排序</span><br><span class="line">alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素</span><br><span class="line"></span><br><span class="line">// 二分求出x对应的离散化的值</span><br><span class="line">int find(int x) // 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l = 0, r = alls.size() - 1;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r + 1; // 映射到1, 2, ...n 之后前缀和好处理边界0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>unique()函数底层实现原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>])<span class="comment">//如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];<span class="comment">//每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;<span class="comment">//返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p>把查询左右端点数l,r和之前插入数的下标x都放进去。alls排序、去重</p><p>映射后离散的数组成一个连续的数组，找到l和r对于数组中的位置，前缀和相减就是区间和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">//存储下标</span></span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= alls[mid]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取add</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;c);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 query</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理插入 产生a[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-区间合并"><a href="#11-区间合并" class="headerlink" title="11. 区间合并"></a>11. 区间合并</h3><ul><li>记得先排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>()); <span class="comment">//优先左端点排序，然后右端点排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>; <span class="comment">// 维护一个当前的区间，左端点一定是最小的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;<span class="comment">// 分散的区间，一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); <span class="comment">// 包含两种情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-静态单链表"><a href="#1-静态单链表" class="headerlink" title="1. 静态单链表"></a>1. 静态单链表</h3><blockquote><h4 id="重要性："><a href="#重要性：" class="headerlink" title="重要性："></a>重要性：</h4><p>因为c++中new比较慢，用数组模拟链表，这样的静态链表会比较快。</p><p>而且写出数组写法比较短，之后写邻接表，写图论都用这数组模拟的方法。</p><ol start="2"><li>cpp的编译器会开O2优化（会进行一系列的优化操作，包括但不限于内联函数、循环展开、常量传播、死代码消除和指令调度等。这些优化操作可以使生成的机器代码更加高效，从而提高程序的性能）<br>但是在算法题的时候没有开优化，所以用数组模拟比STL快一些</li></ol><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>用数组模拟要提前设置好 head 或者 左右节点，然后别忘了下标变过了，单链表是从0开始，双链表从2开始，题目给出第i个结点时，注意下标写法。</p></blockquote><ul><li>静态链表因为有idx，更体现第几次插入的之间的顺序关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="comment">// 这里head是一个指针记录的作用，只是存了头结点的下标，区别于dummy节点，那是一个实质节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除下标为k的后面一个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k点后面</span></span><br><span class="line"><span class="comment">// 知道前一个节点的下标后插入才能实现O（1），否则链表需要依次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-静态双链表"><a href="#2-静态双链表" class="headerlink" title="2. 静态双链表"></a>2. 静态双链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-模拟栈-x2F-模拟队列"><a href="#3-模拟栈-x2F-模拟队列" class="headerlink" title="3. 模拟栈 &#x2F; 模拟队列"></a>3. 模拟栈 &#x2F; 模拟队列</h3><p>数组模拟栈的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><h4 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h4></li></ol><p>注意空间的利用 当tt和hh到达N的时候，重新利用之前的数组空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// y总的模板tt是 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算机处理表达式"><a href="#4-计算机处理表达式" class="headerlink" title="4.计算机处理表达式"></a>4.计算机处理表达式</h3><blockquote><ol><li><p>前缀表达式：操作符在操作数的前面，比如 +-543<br><strong>计算过程：</strong>从右向左扫描，遇到数字入栈，遇到运算符，对两数做计算，结果入栈，一直到最左端</p></li><li><p>中缀表达式：操作符在操作数的中间，这也是人类最容易识别的算术表达式 3+4-5</p><p><strong>计算过程：</strong>一般是二元运算，还有（）的问题</p></li><li><p>后缀表达式：操作符在操作数的后面，比如 34+5-<br><strong>计算过程：</strong>从左往右扫描，遇到数字入栈，遇到运算符，对两数做计算，结果入栈，一直到最左端</p></li></ol><ul><li>后缀表达式是树的后续遍历，不需要括号，中缀是中序遍历，需要括号；树的叶子结点是数字，根节点是表达式</li></ul></blockquote><p>中缀表达式：如何判断某颗子树被遍历完 《&#x3D;&#x3D;》 <strong>当前的运算符优先级 &lt;&#x3D; 上一个优先级</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前计算表达式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) x = a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) x = a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) x = a * b;</span><br><span class="line">    <span class="keyword">else</span> x = a / b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">                x = x * <span class="number">10</span> + str[j ++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i = j - <span class="number">1</span>; <span class="comment">// 别忘了更新i</span></span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">             op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;<span class="comment">// 计算时为空 或者 上一步的运算符比这一步等级高 就能进行计算</span></span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c]) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-单调栈"><a href="#5-单调栈" class="headerlink" title="5. 单调栈"></a>5. 单调栈</h3><p>老是忘记写法，多记几次</p><p>左边第一个小的数 i从0开始 维护一个递增的栈</p><p>右边第一个小的数 i从 n-1开始 维护一个递增的栈</p><blockquote><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>在左边或者右边维护一个栈， 栈是单调递增或者递减的</p><h4 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h4><ol><li>先想暴力的，发现有些没有用的数可以删掉，然后发现单调性</li><li>维护单调性，如果求极值就维护左右两端点，如果是求其中值就用二分</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ; <span class="comment">// 维护单调栈</span></span><br><span class="line">    stk[ ++ tt] = i; <span class="comment">// 别忘了插入当前的数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-单调队列"><a href="#6-单调队列" class="headerlink" title="6. 单调队列"></a>6. 单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p><blockquote><p>单调队列解决滑动窗口，不仅处理尾部来保证单调性，而且要处理窗口滑动导致的极值消失问题</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-KMP"><a href="#7-KMP" class="headerlink" title="7. KMP"></a>7. KMP</h3><p>求出模式串 P 在字符串 S 中所有出现的位置的起始下标</p><blockquote><p>想一个ne数组，就是前缀和后缀相同的最大长度。这样，当前位置不匹配的时候，就可以直接下移到ne[j]的位置匹配了。</p><ol><li>求得这个ne数组，和以下的kmp类似</li><li>搜索kmp，不匹配就退到ne[j]，匹配就j++，如果整个子串都匹配完了就输出出来，然后再退到ne[j];</li></ol></blockquote><p>求ne，就是自己和自己匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"></span><br><span class="line">求!!!模式串(子串)!!!的Next数组：</span><br><span class="line">    <span class="comment">// i从2开始 , 因为ne[1] = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// j 没有退回起点，并且当前的s[i]不能和p[j+1]匹配(这个j是从0开始的)</span></span><br><span class="line">    <span class="comment">// j表示的是退回的坐标点， j = 0表示退回到起点，下一个是第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j]; <span class="comment">//尝试失败，退一步</span></span><br><span class="line">    <span class="comment">// 如果能匹配了，则更新j到j + 1</span></span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="comment">// 不管这样，都要设置ne[i]</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 注意i从1开始读取</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// j 没有退回起点，并且当前的s[i]不能和p[j+1]匹配(这个j是从0开始的)</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">// 字母可以往匹配，往后一个</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="comment">// 整个p都能匹配,匹配成功一个子串</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Trie树-字典树"><a href="#8-Trie树-字典树" class="headerlink" title="8. Trie树 字典树"></a>8. Trie树 字典树</h3><p>高效地存储和查找<strong>字符串集合</strong>的数据结构；</p><p>一般字母类型不会很多，把单词存起来成为一棵树，然后可以用于查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// son[][] 存储树的每个结点的子节点 也就是每行是一个节点，列是26个字母</span></span><br><span class="line"><span class="comment">// cnt[] 存储每个节点结尾的单词数量</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 往下找子节点，如果不存在就添加子节点</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; </span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 某一结点没找到，返回</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-并查集"><a href="#9-并查集" class="headerlink" title="9. 并查集"></a>9. 并查集</h3><blockquote><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol><li>讲两个集合合并</li><li>询问两个元素是否在一个集合中 （判断是否连通，是否在一个连通子集中）</li></ol><h3 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h3><p>搜索是O(1)很快</p><p>每个集合用一颗树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><ol><li><p>如何判断树根 if (p[x] &#x3D;&#x3D; x)</p></li><li><p>如何求x的集合编号 while (p[x] !&#x3D; x) x &#x3D; p[x];</p></li><li><p>如何合并两个集合，p[x]是x的集合编号，p[y]是y的集合编号，p[x] &#x3D; y</p></li></ol><h3 id="记："><a href="#记：" class="headerlink" title="记："></a>记：</h3><ol><li>记find函数写法（初始化）</li><li>其他额外维护的size[]和distance[]的维护，额外去想</li></ol></blockquote><h4 id="1-朴素并查集"><a href="#1-朴素并查集" class="headerlink" title="1) 朴素并查集"></a>1) 朴素并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// p[x] = find(p[x]);是路径压缩，把非根节点的p[x]都指向祖宗节点</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); </span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h4 id="2）-维护size的并查集"><a href="#2）-维护size的并查集" class="headerlink" title="2） 维护size的并查集"></a>2） 维护size的并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> p[N], size[N];</span><br><span class="line">   <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">       <span class="keyword">return</span> p[x];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">       p[i] = i;</span><br><span class="line">       size[i] = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line"><span class="keyword">if</span> (find[a] != find[b])</span><br><span class="line">   &#123;</span><br><span class="line">       size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">   p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3）-维护到祖宗节点距离的并查集"><a href="#3）-维护到祖宗节点距离的并查集" class="headerlink" title="3） 维护到祖宗节点距离的并查集"></a>3） 维护到祖宗节点距离的并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">   <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回x的祖宗节点 ；顺便做了路径压缩并且得到x到祖宗的距离</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">           d[x] += d[p[x]]; <span class="comment">// 递归p[x]，最终得到x到根节点的距离</span></span><br><span class="line">           p[x] = u;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> p[x];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">       p[i] = i;</span><br><span class="line">       d[i] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">   p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">   d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-堆"><a href="#10-堆" class="headerlink" title="10. 堆"></a>10. 堆</h3><blockquote><h3 id="手写一个堆"><a href="#手写一个堆" class="headerlink" title="手写一个堆:"></a>手写一个堆:</h3><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><ul><li>堆是一个完全二叉树，除了最后一层都是满的；</li><li>（小根）堆的每个店都小于等于两个子节点，根节点是堆的最小值；</li></ul><h3 id="存储："><a href="#存储：" class="headerlink" title="存储："></a>存储：</h3><p>一维数组存储堆，左二子是2x，右儿子是2x+1</p><ul><li>2*0&#x3D;0，建堆从1开始做</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置 ph[j] = k, hp[k] = j</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里a b是堆位置输入的，所以hp[a]才有意义，ph[a]没什么意义</span></span><br><span class="line">    <span class="comment">// 这里把两个数组都swap一下，对应映射交换</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和左节点和右节点更小的点交换，递归down</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和父节点交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-模拟堆操作"><a href="#1-模拟堆操作" class="headerlink" title="1) 模拟堆操作"></a>1) 模拟堆操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], cnt, m;</span><br><span class="line"><span class="type">int</span> hp[N], ph[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里a b是堆位置输入的，所以hp[a]才有意义，ph[a]没什么意义</span></span><br><span class="line">    <span class="comment">// 这里把两个数组都swap一下，对应映射交换</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[t] &gt; h[<span class="number">2</span> * u]) t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[t] &gt; h[<span class="number">2</span> * u + <span class="number">1</span>]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>, u);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k]; <span class="comment">// 执行heap_swap后的ph[k]可能就是不原来的ph[k]了,所以先存一个ph[k]</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-哈希"><a href="#11-哈希" class="headerlink" title="11. 哈希"></a>11. 哈希</h3><h4 id="1）-拉链法"><a href="#1）-拉链法" class="headerlink" title="1） 拉链法"></a>1） 拉链法</h4><p>N取<code>质数</code>，减少哈希冲突</p><p>初始化记得把主链全部初始化为-1 memset(h, -1, sizeof h)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）-开放寻址法"><a href="#2）-开放寻址法" class="headerlink" title="2） 开放寻址法"></a>2） 开放寻址法</h4><p>需要提前设置null为不在N范围内的值，作为初始值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-字符串哈希"><a href="#12-字符串哈希" class="headerlink" title="12. 字符串哈希"></a>12. 字符串哈希</h3><p>用O(1) 快速比较两个字符串相等</p><p>这种做法假装忽略哈希冲突</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line">N取<span class="number">2</span><span class="number">-3</span>倍的量级，质数</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-STL技巧"><a href="#13-STL技巧" class="headerlink" title="13. STL技巧"></a>13. STL技巧</h3><p>vector, 变长数组，倍增的思想： 系统为某一个程序分配空间时，所需时间与空间大小无关，与申请次数有关<br>    size()  返回元素个数<br>    empty()  返回是否为空<br>    clear()  清空<br>    front()&#x2F;back()<br>    push_back()&#x2F;pop_back()<br>    begin()&#x2F;end()<br>    []<br>    支持比较运算，按字典序</p><p>pair&lt;int, int&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    <strong>支持比较运算</strong>，以first为第一关键字，以second为第二关键字（字典序）</p><p>string，字符串<br>    size()&#x2F;length()  返回字符串长度<br>    empty()<br>    clear()<br>    substr(起始下标，**(子串长度)**)  返回子串<br>    c_str()  返回字符串所在字符数组的起始地址</p><p>queue, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    front()  返回队头元素<br>    back()  返回队尾元素<br>    pop()  弹出队头元素</p><p>priority_queue, 优先队列，<strong>默认是大根堆</strong><br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;</p><p>stack, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素</p><p>deque, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()&#x2F;back()<br>    push_back()&#x2F;pop_back()<br>    push_front()&#x2F;pop_front()<br>    begin()&#x2F;end()<br>    []</p><p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()&#x2F;end()<br>    ++, – 返回前驱和后继，<strong>时间复杂度 O(logn)</strong></p><p>​    set&#x2F;multiset<br>​        insert()  插入一个数<br>​        find()  查找一个数<br>​        count()  返回某一个数的个数<br>​        erase()<br>​            (1) 输入是一个数x，删除所有x   O(k + logn)<br>​            (2) 输入一个迭代器，删除这个迭代器<br>​        <strong>lower_bound()&#x2F;upper_bound()</strong><br>​            lower_bound(x)  返回大于等于x的最小的数的迭代器<br>​            upper_bound(x)  返回大于x的最小的数的迭代器<br>​    map&#x2F;multimap<br>​        insert()  插入的数是一个pair<br>​        erase()  输入的参数是pair或者迭代器<br>​        find()<br>​        []  注意multimap不支持此操作。 时间复杂度是 O(logn)<br>​        lower_bound()&#x2F;upper_bound()</p><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的<strong>时间复杂度是 O(1)</strong><br>    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，–</p><p><code>bitset</code>, 圧位 代替布尔数组，用位判断<br>    bitset&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    &#x3D;&#x3D;, !&#x3D;<br>    []</p><p>​    count()  返回有多少个1</p><p>​    any()  判断是否至少有一个1<br>​    none()  判断是否全为0</p><p>​    set()  把所有位置成1<br>​    set(k, v)  将第k位变成v<br>​    reset()  把所有位变成0<br>​    flip()  等价于~<br>​    flip(k) 把第k位取反</p><h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><h3 id="1-树和图的存储"><a href="#1-树和图的存储" class="headerlink" title="1. 树和图的存储"></a>1. 树和图的存储</h3><p>树是无环连通图。树是一种特殊的图，与图的存储方式相同。</p><p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p><p>因此我们可以只考虑有向图的存储。</p><p>(1) 邻接矩阵：g[a][b] 存储边a-&gt;b <strong>一般处理稠密图</strong></p><p>(2) 邻接表： <strong>一般处理稀疏图</strong> 多用邻接表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="comment">// 如果是无向边 需要开M = N * 2；e[M], ne[M], 因为要add两次</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 权重 w[N];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    <span class="comment">// 权重 w[idx] = c;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><p>动态内存开图用 vector<int> obj[N];</p><h3 id="2-树与图的遍历"><a href="#2-树与图的遍历" class="headerlink" title="2. 树与图的遍历"></a>2. 树与图的遍历</h3><p>时间复杂度 O(n+m), n 表示点数，m 表示边数</p><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th>特点</th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(h)</td><td>思路比较怪或者空间要求高 爆搜</td></tr><tr><td>BFS</td><td>queue</td><td>O(2^h)</td><td>最短路性质，按层搜索所以第一个搜到的结果是最短路</td></tr></tbody></table><ul><li>h为深度</li></ul><h4 id="1）-DFS"><a href="#1）-DFS" class="headerlink" title="1） DFS"></a>1） DFS</h4><p>相当于进行递归。 没什么模板，主要的是思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前层 做选择</span></span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里经常写错。</span></span><br><span class="line"><span class="comment">        首先u是节点编号，h[u]是u节点的下标idx，e[idx]就是idx对应的节点，</span></span><br><span class="line"><span class="comment">        每次要往下找节点的ne[i]，所以需要用到下标i，判断节点是否遍历st[j]到要用到节点编号，所以用到j</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> j = e[i]; </span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销当前层</span></span><br><span class="line">    st[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="回溯操作"><a href="#回溯操作" class="headerlink" title="回溯操作"></a>回溯操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~~~cpp</span><br><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">if 满⾜结束条件:</span><br><span class="line">result.add(路径)</span><br><span class="line">return</span><br><span class="line">for 选择 in 选择列表:</span><br><span class="line">做选择</span><br><span class="line">backtrack(路径, 选择列表)</span><br><span class="line">撤销选择</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure><h5 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 判断有效性 比如N皇后问题中的有效性数组</span><br><span class="line">2. 判断最优性，如果比之前的最优解差就剪枝</span><br></pre></td></tr></table></figure><h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2) BFS"></a>2) BFS</h4><p>最短路问题，只有边权都是1时，用BFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最短路还需要定义距离d[N],设置 memset(d, -1, sizeof d) ;d[1] = 0 表示第一个点的距离0 ，其余-1作为未被遍历过条件</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 第一次bfs到的作为最短答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            <span class="comment">// d[j] = d[t] + 1;</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常常求最短次数，那就用一个数组或者哈希记录次数，只记录bfs第一次得到的数据</li></ul><h3 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3. 拓扑排序"></a>3. 拓扑排序</h3><p>若一个由图中所有点构成的序列 AA 满足：对于图中的每条边 (x,y)(x,y)，xx 在 AA 中都出现在 yy 之前，则称 AA 是该图的一个拓扑序列。也就是有向边都是从前指向后。</p><p><strong>一个有向无环图（拓扑图），存在拓扑序列</strong></p><p>入度：一个点有几条边进来</p><p>出度：一个点有几条边出去</p><p>证明：一个有向无环图，必定至少有一个入度为 0 的点</p><p><strong>原理：</strong> </p><ol><li>每次轮到入度为0的数作为起点，往后获取后继；后继入度–，当入度 &#x3D;&#x3D; 0，轮到这个节点</li><li>入队q的顺序，恰好是拓扑序</li><li>拓扑序的顺序不唯一</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;<span class="comment">// 出队只是把指针往后移，没有清除，且恰好是拓扑序。需要拓扑序直接遍历q就行</span></span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最短路问题"><a href="#4-最短路问题" class="headerlink" title="4.最短路问题"></a>4.最短路问题</h3><p>分为：   单源最短路 ：一个起点，到一个终点</p><p>​多源汇最短路 ：多个起点</p><p>n 表示点的数量；m 表示边的数量</p><p>所以边稀疏的时候用堆优化的Dijkstra算法，稠密图用朴素的Dijkstra算法</p><p><strong>难点：</strong>建图，抽象转化为最短路问题，侧重于实现</p><h4 id="1）-朴素Dijkstra算法"><a href="#1）-朴素Dijkstra算法" class="headerlink" title="1） 朴素Dijkstra算法"></a>1） 朴素Dijkstra算法</h4><p>O(N^2)</p><p><strong>用于稠密图</strong>， m比较大的，边多的题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每个循环确定一个点的最小距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 这便是n-1，因为第一个点已经确定最短距离是0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*不在st中的，距离最近的点*/</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"><span class="comment">/*t加入st中*/</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*用t更新其他点的距离*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）-堆优化的Dijkstra算法"><a href="#2）-堆优化的Dijkstra算法" class="headerlink" title="2） 堆优化的Dijkstra算法"></a>2） 堆优化的Dijkstra算法</h4><p>O(mlogn + m)</p><p>用于稀疏图，m比较小的。 </p><p>原理： 用堆压缩每次查找不在st中的距离最短的点，压缩到n；但是更新其他点的距离需要维护堆，mlogn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3）-Bellman-Ford算法"><a href="#3）-Bellman-Ford算法" class="headerlink" title="3） Bellman-Ford算法"></a>3） Bellman-Ford算法</h4><p>一般只处理k次边，边权是负数的问题。 其他就用spfa</p><p>O(mn)</p><p>处理有负权边的图中最短路问题；</p><p>有负权回路的图，可能没有最短路，因为如果环的总数是负数，那最短路可能是负无穷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="comment">// 松弛所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 每次备份dis数组，使得一条边只松弛一次，避免串联。避免上一条松弛完结果松弛下一条</span></span><br><span class="line">        <span class="built_in">memcpy</span>(last, dis, <span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dis[e.b] = <span class="built_in">min</span> (dis[e.b], last[e.a] + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 不能用==, 因为负权边存在，导致正无穷被减了</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）-spfa算法"><a href="#4）-spfa算法" class="headerlink" title="4） spfa算法"></a>4） spfa算法</h4><p>队列优化的Bellman-Ford算法。 </p><p>平均O(m), 最坏O(nm)</p><blockquote><p>spfa算法还可以都处理正负权边，一般情况比Dijkstra算法还快，但是出题人可能会卡最坏情况，那就需要用堆优化的Dijkstra</p></blockquote><p>长的有点像Dijkstra算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中，重复存队列是无意义的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只有dis[j]更短了，才需要加到q中，以接着更新临边的dist[]</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-spfa判断图中是否存在负环"><a href="#5-spfa判断图中是否存在负环" class="headerlink" title="5)  spfa判断图中是否存在负环"></a>5)  spfa判断图中是否存在负环</h4><p>时间复杂度是  O(nm)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组并且把点全放到q中：dist数组是0，只会更新小于0的权边，也就是负权边，当存在负权环的时候，会不停的更新，此时输出true</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-floyd算法"><a href="#6-floyd算法" class="headerlink" title="6) floyd算法"></a>6) floyd算法</h4><p>O(N^3) 求解多源最短路问题</p><p>一般是多次多点查询，查任意d[a][b]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5. 最小生成树"></a>5. 最小生成树</h3><p>最小生成树：连接一个连通无向图的所有顶点和边的树，且权值之和最小的树</p><p>稠密图一般用朴素Prim， 稀疏图用Kruskal</p><h4 id="1）-朴素Prim算法"><a href="#1）-朴素Prim算法" class="headerlink" title="1） 朴素Prim算法"></a>1） 朴素Prim算法</h4><p>朴素 稠密 邻接矩阵</p><blockquote><p>dist[i]  无穷&lt;– dist[1] &#x3D; 0</p><p>for （int i &#x3D; 0；i &lt; n; i++)</p><p>找到集合外距离最近的点t</p><p>用t更新其他点到<code>集合</code>的距离</p><p>st[t] &#x3D; true; </p></blockquote><ul><li>和Dijkstra有点像，但是更新的到集合的距离</li></ul><p>时间复杂度是 O(n^2+m), nn 表示点数，mm 表示边数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;<span class="comment">/*获取集合外最小距离点*/</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"><span class="comment">/*加入集合*/</span> </span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">// 如果没有连通的点，impossible</span></span><br><span class="line">        res += dist[t]; <span class="comment">// 先更新res，防止之后被更新的了dist[t]</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*更新其他边*/</span> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Kruskal算法"><a href="#2-Kruskal算法" class="headerlink" title="2)  Kruskal算法"></a>2)  Kruskal算法</h4><p>堆优化的Prim算法 写起来复杂，且没有Kruskal算法好，一般不用，不记</p><blockquote><ol><li><p>将所有边按权重从小到大排序 O(mlogm)</p></li><li><p>枚举每条边a, b, w； </p><p>if a, b不连通</p><p>​将这条边加入到集合中</p></li></ol></blockquote><p>就是每次加小权重边的贪心思想</p><p>时间复杂度是 O(mlogm), nn 表示点数，mm 表示边数时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-染色法判别二分图"><a href="#6-染色法判别二分图" class="headerlink" title="6. 染色法判别二分图"></a>6. 染色法判别二分图</h3><p>二分图（Bipartite Graph），又称作二部图，是一种图论中的特殊图，可以将图中的顶点分为两个互不相交的集合，使得同一集合内的顶点没有边相连。</p><p>二分图 当且仅当 图中不存在奇数环</p><p>O(n + m) , n表示点数，m表示边数</p><p>原理： dfs对所有点染色，如果下一个点 已经被染色 并且 和上一个同色，false</p><p>由于图中不含奇数环，所以染色过程中一定没有矛盾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="comment">// 如果下一个点 已经被染色 并且 和上一个同色，false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 染色法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历所有点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="comment">// 从这个点出发 染色相连的点</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-二分图的最大匹配-匈牙利算法"><a href="#7-二分图的最大匹配-匈牙利算法" class="headerlink" title="7. 二分图的最大匹配 匈牙利算法"></a>7. 二分图的最大匹配 匈牙利算法</h3><p>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p><p>O(nm)，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) <span class="comment">// 没有匹配男生，或者那个男的可以找到下家</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="1-质数"><a href="#1-质数" class="headerlink" title="1. 质数"></a>1. 质数</h3><h4 id="试除法-判断质数"><a href="#试除法-判断质数" class="headerlink" title="试除法 判断质数"></a>试除法 判断质数</h4><p>O(sqrt(n))</p><p><strong>原理</strong>：i能整除n，那么n&#x2F;i也能整除n，都是成对出现的，那只需要枚举小的那个数</p><p>只需要枚举到根号n就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 不要写成根号n，比较慢；也不要写i*i &lt; n可能存在int移除</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="试除-分解质因数法"><a href="#试除-分解质因数法" class="headerlink" title="试除 分解质因数法"></a>试除 分解质因数法</h4><p>O(sqrt(n))</p><p><strong>原理</strong>：n中最多只包含一个大于sqr(n)的质因子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 从小到大分解质因子，修改x</span></span><br><span class="line">        <span class="comment">// i 一定是质数 ： </span></span><br><span class="line">        因为如果i能被<span class="number">2</span>到i<span class="number">-1</span>的数整除，那么n一定能被<span class="number">2</span>到i<span class="number">-1</span>中的数整除，因为n是i的倍数（n能被i整除）</span><br><span class="line">        因为在枚举到i之前已经把n中<span class="number">2</span>到i<span class="number">-1</span>的质因子除干净了，此时n中不含<span class="number">2</span>到i<span class="number">-1</span>的质因子，由于n为i的倍数，所以i中也不包含<span class="number">2</span>到i<span class="number">-1</span>的质因子</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="comment">// 最多只有一个大于根号n的质因子</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="朴素筛法-求范围内所有素数"><a href="#朴素筛法-求范围内所有素数" class="headerlink" title="朴素筛法 求范围内所有素数"></a>朴素筛法 求范围内所有素数</h4><p>O(Nlog(N)) 不管是素数还是合数，都筛掉他的倍数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把素数存起来</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i; <span class="comment">// [2, p-1]都没有被筛掉，所以是素数</span></span><br><span class="line">        <span class="comment">// 不管是素数还是合数，都筛掉他的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) </span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="诶氏筛法-求范围内所有素数"><a href="#诶氏筛法-求范围内所有素数" class="headerlink" title="诶氏筛法 求范围内所有素数"></a>诶氏筛法 求范围内所有素数</h4><p>O(Nlog(log（N)) 只用素数，都筛掉所有的合数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;<span class="comment">// 把素数存起来</span></span><br><span class="line">            primes[cnt ++ ] = i; <span class="comment">// [2, p-1]都没有被筛掉，所以是素数</span></span><br><span class="line">            <span class="comment">// 只用素数，都筛掉所有的合数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) <span class="comment">// 把每个数的倍数删掉 : i 是一个质数， i的倍数都筛掉</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法-求范围内所有素数"><a href="#线性筛法-求范围内所有素数" class="headerlink" title="线性筛法 求范围内所有素数"></a>线性筛法 求范围内所有素数</h4><p>O(N) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 用最小质因子去筛合数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]一定是小于i的最小质因子,所以primes[j]*i的最小质因子就是primes[j];</span></span><br><span class="line">            <span class="comment">//2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是prime[j]，</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了。因为i有最小质因子primes[j]&lt;primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，</span></span><br><span class="line">            <span class="comment">// 此时应该退出循环，增加i，然后把primer[j]重新从小开始</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-约数"><a href="#2-约数" class="headerlink" title="2. 约数"></a>2. 约数</h3><p>和求质因数一样，约数也是成对出现，遍历到根号n，只遍历较小的约数就行，顺便把不同的另一个约数也插入</p><h4 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数个数-和-约数之和"><a href="#约数个数-和-约数之和" class="headerlink" title="约数个数 和 约数之和"></a>约数个数 和 约数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck // 分解质因子</span><br><span class="line">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="line">约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) //可以用while (a--) t = (t*p + 1) % mod;</span><br></pre></td></tr></table></figure><p>这些p取质数</p><h5 id="给定-n-个正整数-ai，请你输出这些数的乘积的约数之和，答案对-1e9-7-取模。"><a href="#给定-n-个正整数-ai，请你输出这些数的乘积的约数之和，答案对-1e9-7-取模。" class="headerlink" title="给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 1e9+7 取模。"></a>给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 1e9+7 取模。</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line">    <span class="comment">// 每个数约数及其次数，总乘数的约束及其次数</span></span><br><span class="line">    <span class="keyword">while</span> ( n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, primes[i] ++;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公式</span></span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = prime.first, a = prime.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a--) t = (t*p + <span class="number">1</span>) % mod;</span><br><span class="line">        res =  res * t % mod;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="辗转相除法-求最大公约数"><a href="#辗转相除法-求最大公约数" class="headerlink" title="辗转相除法 求最大公约数"></a>辗转相除法 求最大公约数</h4><p>欧几里得算法 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：（）表示最大公约数，</p><ol><li><p>首先(a, b) &#x3D; (a, ka + b), 那么可以用辗转相减法求（a,b) :基本上思路就是大数减去小数，<strong>一直减到能算出来为止</strong></p></li><li><p>由(78，14)到(8，14)完全可以一步到位，因为(78，14)&#x3D;(14×5+8，14)&#x3D;(8，14)，由此就诞生出我们的辗转相除法.</p></li></ol><p>​即：(a， b) &#x3D; (a % b， b) &#x3D; （b, a %b）</p><p>相当于每一步都把数字进行缩小，等式右边就是每一步对应的缩小结果。</p><p>对（a， b）连续使用辗转相除，直到小括号内右边数字为0，小括号内左边的数就是两数最大公约数</p><h3 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3. 欧拉函数"></a>3. 欧拉函数</h3><h4 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h4><p>互质： 公约数只有1的两个数</p><p>欧拉函数：1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h4><p>借用线性筛素数的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            <span class="comment">// 质数的欧拉函数 i-1</span></span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">             <span class="comment">// primes[j]是i的最小质因子, 也是rimes[j] * i的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将基数NN修正为primes[j]倍，最终结果为phi[i] * primes[j]</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// primes[j]不是i的质因子，只是primes[j] * i的最小质因子，因此不仅需要将基数NN修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)</span></span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速幂"><a href="#4-快速幂" class="headerlink" title="4. 快速幂"></a>4. 快速幂</h3><p>O(n∗logb)</p><p>求 m^k mod p，时间复杂度 O(logk)。</p><p>把m^k 转化为 m^（2^0 + 2^1 + 2^2 +…)，</p><p>如何预处理 m^（2^b) mod p这些值， 每个数就是前面的数 平方 再mod p</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * m % p;</span><br><span class="line">        <span class="comment">// 下一个底数和次数 m^（2^b) , 下一个 k</span></span><br><span class="line">        a = a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><p><strong>逆元：</strong>a &#x2F; b ≡ a * x (mod n)，则x是b的逆元。 数b与逆元x的关系 1 ≡ b * x (mod n)</p><p><strong>费马小定理：</strong>当n为质数时b ^ (n - 1) ≡ 1 (mod n)</p><p>拆一个b出来可得 b * b ^ (n - 2) ≡ 1 (mod n)<br>故当n为质数时，b n 互质，b的乘法逆元 <code>b的乘法逆元 = b ^ (n - 2) mod n</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> % c;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);</span><br><span class="line">        <span class="comment">// 题目中限定了 p 一定是质数，所以如果ab不互质，即 a 和 p 有公因子，那么 a 就一定是 p 的倍数</span></span><br><span class="line">        <span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">qmi</span>(a, p<span class="number">-2</span>, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-扩展欧几里得算法"><a href="#5-扩展欧几里得算法" class="headerlink" title="5.扩展欧几里得算法"></a>5.扩展欧几里得算法</h3><h4 id="裴蜀定理："><a href="#裴蜀定理：" class="headerlink" title="裴蜀定理："></a>裴蜀定理：</h4><p>有一对任意正整数a, b, 那么一定存在整数系数x, y, 使得ax + by &#x3D; (a, b) 。()表示最大公约数</p><p>而且这个（a,b）是a和b能凑出来的最小的数</p><p>证明： </p><ol><li><p>因为a b能凑出来的数一定是（a,b）的倍数，所以最小的数是(a,b)</p></li><li><p>求出系数 x y</p></li></ol><h4 id="扩展欧几里得算法求-系数x-y"><a href="#扩展欧几里得算法求-系数x-y" class="headerlink" title="扩展欧几里得算法求 系数x, y"></a>扩展欧几里得算法求 系数x, y</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exgcd-解线性同余方程"><a href="#exgcd-解线性同余方程" class="headerlink" title="exgcd 解线性同余方程"></a>exgcd 解线性同余方程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x= <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b *x; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        <span class="comment">// b 是(a, m)的倍数 才有解</span></span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="comment">// 结果需要扩大 b/d 倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>) x * (b/d) % m);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高斯消元-求解线性方程组"><a href="#6-高斯消元-求解线性方程组" class="headerlink" title="6. 高斯消元 求解线性方程组"></a>6. 高斯消元 求解线性方程组</h3><p>O(N^3)</p><p>划成上三角矩阵，然后判断解的情况：唯一解、 无解、 去穷多解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="comment">// 按照每列遍历</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到该列最大值的行</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line">        <span class="comment">// 如果最大是0，已经完成变换        </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 把绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line">        <span class="comment">// 把当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--) a[r][i] /= a[r][c];</span><br><span class="line">        <span class="comment">// 用当前行将下面所有列消0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j-- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++)</span><br><span class="line">            <span class="comment">// 如果存在0 = 非0 无解 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 无穷多解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="comment">// 消掉除了对角线的项，最后化成 xi = 常数项</span></span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-组合数"><a href="#7-组合数" class="headerlink" title="7. 组合数"></a>7. 组合数</h3><h4 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h4><p>组合数的递推式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="comment">/* 考虑边界情况：</span></span><br><span class="line"><span class="comment">        1.c[0][j] = 0 </span></span><br><span class="line"><span class="comment">        2.c[i][0] = 1</span></span><br><span class="line"><span class="comment">        3. i &lt; j 时，0 不存在</span></span><br><span class="line"><span class="comment">        4. i = j 是，1 </span></span><br><span class="line"><span class="comment">    */</span> </span><br></pre></td></tr></table></figure><h4 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span><br><span class="line">如果取模的数是质数，可以用费马小定理求逆元</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-NIM游戏"><a href="#8-NIM游戏" class="headerlink" title="8. NIM游戏"></a>8. NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An !&#x3D; 0</p><p>异或： 结果是0 ，则每个位上的1数量是偶数</p><p>先手必败态：走不到任何一个必败状态，</p><p>先手必胜状态： 可以走到某个必败状态</p><p>扩展：k-NIM游戏，每次最多拿k个</p><h4 id="公平组合游戏ICG"><a href="#公平组合游戏ICG" class="headerlink" title="公平组合游戏ICG"></a>公平组合游戏ICG</h4><p>若一个游戏满足：</p><ol><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        res ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>&lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h4><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h4 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h4><p>设S表示一个非负整数集合.定义mex(S)为求出不属于集合S的最小非负整数运算,即:<br>mes(S)&#x3D;min{x};<br>例如:S&#x3D;{0,1,2,4},那么mes(S)&#x3D;3;</p><h4 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h4><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) &#x3D; mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。</p><h4 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h4><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br><strong>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：</strong><br><strong>SG(G) &#x3D; SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</strong></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p><strong>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。</strong><br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p><p>终点定义为0，其他的SG(x)定义为，不能走到的最小的整数</p><p> 集合-Nim游戏 只能取 集合s[N]中任意值的数量石子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出每一堆的sg</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] !=  <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="comment">// 每个节点的往下子节点的值存在set中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要用递归的话，最好定义局部变量，防止改变原值</span></span><br><span class="line">        <span class="type">int</span> sum = s[i];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= sum) S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x - sum));</span><br><span class="line">        <span class="comment">// 延伸到终点的sg值后，再从后往前排查出所有数的sg值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小的没有出现的自然数的操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ;i ++)</span><br><span class="line">        <span class="keyword">if</span> (!S.<span class="built_in">count</span>(i))</span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cin &gt;&gt; s[i];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        res ^= <span class="built_in">sg</span>(x); <span class="comment">// 所有堆的sg异或起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h4 id="考虑Dp问题角度："><a href="#考虑Dp问题角度：" class="headerlink" title="考虑Dp问题角度："></a>考虑Dp问题角度：</h4><ol><li><p>状态表示 f(i,j) ,如何表示当前状态。<br>1）表示的集合是什么  2）f(i,j)这个值 表示集合的属性是什么（最大值、最小值、数量等</p></li><li><p>状态计算，如何一步步计算到需要的结果</p><p>主要是把集合划分</p></li></ol><p>化零为整，化整为零</p><h4 id="Dp优化："><a href="#Dp优化：" class="headerlink" title="Dp优化："></a>Dp优化：</h4><p>一般是对DP的代码或者方程做一个等价变形；</p><p>需要先把基本的方程写出来，</p><h4 id="一维优化："><a href="#一维优化：" class="headerlink" title="一维优化："></a>一维优化：</h4><p>背包问题中，如果状态转移用到的是上一层的则是由大到小遍历，如果用的是本层的，就是由小到大遍历</p><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h3><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>dp[i][w] 表示对于前i个物品，容量为w的背包的最大价值</p><ol><li>按照状态找：<br>dp[i][w] 表示对于前i个物品，容量为w的背包的最大价值<br>dp[i][w] &#x3D; max(dp[i-1][w],  dp[i-1][w-wt[i-1]] + val[i-1]);</li><li>到达当前dp[i][w]状态的情况综合，放入第i个物品，或者不放第i物品</li><li>先凑答案就是dp[N][W]的情况，这时候dp的下标是比单个val和wt的下标大一个的，因为前者是size,后者是下标</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> n, m;</span><br><span class="line"> cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="number">1.</span> y总</span><br><span class="line">         <span class="comment">//f[i][j] = f[i -1][j];</span></span><br><span class="line">         <span class="comment">//if (j &gt;= v[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);</span></span><br><span class="line"><span class="number">2.</span> 我的分类讨论，集合划分为装第i件和不装第i件。</span><br><span class="line">             <span class="comment">// 前置条件 j-v[i]不能小于0，也就是存不下第i个,那只能选不存第i个的情况</span></span><br><span class="line">         <span class="keyword">if</span> (j &lt; v[i])</span><br><span class="line">         &#123;</span><br><span class="line">             f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">         &#125;<span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j- v[i]] + w[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ol start="4"><li>一维优化： 因为每次更新f[i][] 只用到了 f[i-1][]这两层， 可以用滚动数组优化。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">         <span class="comment">// 这里更新使用的是f[i -1][j - v[i]]，所以要在f[j - v[i]]还表示f[i -1][j - v[i]]时，还没有更新到f[i][j - v[i]]。j从大到小遍历，求解 f[j] 的时候，还没有更新f[j - v[i]],也就是 f[j - v[i]]是上一层 i -1的原值</span></span><br><span class="line">        <span class="comment">// 这里 j &gt;= v[i]保证了更新条件</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><p>每种物品都有无限件可用</p><ol><li>状态计算： <code>f[i,j] = max (f[i - 1][j - v[i]*k] + w[i] * k)</code></li></ol><p>10^9 TLE </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span> (f[i][j], f[i <span class="number">-1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>两重for之后，要存第i类物品，是需要看还剩下多少空间的，要看之前缺 i 元的情况数</p><p>或者用数学推导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// f[i][j] = f[i-1][j] + f[i-1][j-v[i]] + f[i-1][j-v[i]*2] + ...+f[i-1][j-v[i]*s];</span><br><span class="line">// f[i][j-v[i]] =        f[i-1][j-v[i]] + f[i-1][j-v[i]*2] + ...+f[i-1][j-v[i]*s];</span><br><span class="line"></span><br><span class="line">所以f[i][j] = f[i-1][j] + f[i][j-v[i]];</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span> (f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>一维优化</li></ol><blockquote><p> 最终发现 完全背包问题和01背包问题的差别就是j层遍历的顺序不一样。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m ; j++)</span><br><span class="line">        <span class="comment">// 这里从小到大遍历，和原先的f[i][j] = max (f[i][j], f[i][j - v[i]] + w[i]);一致</span></span><br><span class="line">            f[j] = <span class="built_in">max</span> (f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3. 多重背包问题"></a>3. 多重背包问题</h3><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><ol><li>朴素做法还是 <code>f[i,j] = max (f[i - 1][j - v[i]*k] + w[i] * k)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ).</span><br><span class="line">                f[i][j] = <span class="built_in">max</span> (f[i][j], f[i <span class="number">-1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二进制优化</li></ol><p>把NVS转化为NVlogS复杂度。</p><p>把一种物体按照2进制打包，成为2不同次数量的包，加上一个余数c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12000</span>, M = <span class="number">2010</span>; <span class="comment">// N = 1000 * (log(2000)/log(2))</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="comment">// 二进制优化，从1开始分（1,2,4,8.16.....比s小的2倍数，c（余数））</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">                f[j]= <span class="built_in">max</span> (f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-分组背包问题"><a href="#4-分组背包问题" class="headerlink" title="4. 分组背包问题"></a>4. 分组背包问题</h3><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i是组号，j是组内编号。</p><ul><li>每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；</li><li>每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">1</span><br><span class="line">3 4</span><br><span class="line">1</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 按组读取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j ++) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按组更新，分组01背包，大到小遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span> (j  &gt;= v[i][k]) f[j] = <span class="built_in">max</span> (f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-线性dp"><a href="#5-线性dp" class="headerlink" title="5. 线性dp"></a>5. 线性dp</h3><p>一维 二维 状态表示 </p><h3 id="6-区间dp"><a href="#6-区间dp" class="headerlink" title="6. 区间dp"></a>6. 区间dp</h3><p>状态用区间表示</p><h3 id="7-计数类dp-数位统计dp"><a href="#7-计数类dp-数位统计dp" class="headerlink" title="7. 计数类dp 数位统计dp"></a>7. 计数类dp 数位统计dp</h3><h3 id="8-状态压缩dp"><a href="#8-状态压缩dp" class="headerlink" title="8. 状态压缩dp"></a>8. 状态压缩dp</h3><p>用一个数来表示一个状态，减少复杂度</p><h4 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h4><p>状态压缩dp： 把状态用二进制数表示: </p><p>f[i, j]是前面i-1列已经摆好，且从第i-1列伸到i列的所有方案的状态是j(二进制表示) ，属性是个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先放横着的，再放竖着的。</span></span><br><span class="line"><span class="comment">// 总方案数就是脂肪横着的小方块的方案数</span></span><br><span class="line"><span class="comment">// f[i, j]是前面i-1列已经摆好，且从第i-1列伸到i列的所有方案的状态是j(二进制表示) ，属性是个数</span></span><br><span class="line"><span class="comment">// 判断合法： 所有连续空着的位置的长度必须是偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态压缩dp： 把状态用二进制表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL f[N][M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 预处理，状态不能有奇数个连续的0</span></span><br><span class="line">        <span class="comment">// i &lt; 1 &lt;&lt; n ，比如行数是3，则000 - 111 也就是0 - (1 &lt;&lt; n - 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果这个位的值是1，那查看之前0的数目是多少</span></span><br><span class="line">                <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 奇数个0 转态不合法</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后几个0</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;</span><br><span class="line">            st[i] = is_valid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理，i-1到i伸出来 的 和i-2到i-1伸出来的 不能有冲突, 不在同一行存在i-1和i-2两次伸出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 伸出来部分不能有冲突，位置上不能有两个1</span></span><br><span class="line">            <span class="comment">// 2. 状态不能有奇数个连续的0,两个都填充了一个列后，列的状态也需要是合法的</span></span><br><span class="line">            <span class="comment">// 初始化 因为while</span></span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])</span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 因为while</span></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈密顿距离"><a href="#哈密顿距离" class="headerlink" title="哈密顿距离"></a>哈密顿距离</h4><p>二进制数表示状态，经过的点1，没经过的点0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] 表示0到j点，经过状态i的路径，属性是路径最小值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="comment">// 从0走到0</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) <span class="comment">// 到达j点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span> ((i &gt;&gt; k) &amp; <span class="number">1</span>) <span class="comment">// 需要包含k点</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-(<span class="number">1</span> &lt;&lt; j)][k]+ w[k][j]);<span class="comment">// 使用不经过j点后到达的k点的方案</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-树形dp"><a href="#9-树形dp" class="headerlink" title="9. 树形dp"></a>9. 树形dp</h3><p>dfs结合</p><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h4><p>f[i][0] 不选择节点i的子树的happy值和， f[i][1] 选择节点i的子树happy值的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N],idx;</span><br><span class="line"><span class="comment">// f[i][0] 不选择节点i的子树的happy值和， f[i][1] 选择节点i的子树happy值的和</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>]; </span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">bool</span> has_father[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span> (f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; happy[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        has_father[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (has_father[root]) root ++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-记忆化搜索"><a href="#10-记忆化搜索" class="headerlink" title="10. 记忆化搜索"></a>10. 记忆化搜索</h3><h4 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h4><p>单纯用暴搜，因为每个格子作为起点的往后能走几步是一定的，所以dfs有很多重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>], ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &lt; a[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">            num += t ;</span><br><span class="line">            res = <span class="built_in">max</span>(res, num);</span><br><span class="line">            num -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            len = <span class="built_in">max</span>(len, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dp-记忆化搜索"><a href="#dp-记忆化搜索" class="headerlink" title="dp 记忆化搜索"></a>dp 记忆化搜索</h5><p>用dp记录了每个格子作为起点的往后能走几步。减少了复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], f[N][N];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学一下这种写法，dp(x, y)递归的写法</span></span><br><span class="line"><span class="comment">// 此时不知道dp[x][y]有没有求过，初始化为-1作为判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>], ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &lt; a[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">dp</span>(nx, ny);</span><br><span class="line">            v = <span class="built_in">max</span>(v, t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            len = <span class="built_in">max</span>(len, <span class="built_in">dp</span>(i, j));</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>没有固定的模板，按步骤贪心，选择当前最好的情况，举一些例子试试贪心想法对不对，证明比较难</p><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h4><p>给定 N 个闭区间 [ai,bi][ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p><p>右端点排序</p><p>证明： AnS &lt;&#x3D; cnt &amp;&amp; Ans &gt;&#x3D;cnt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照右端点进行排序，左端点比上一个右端点大，就说明需要新增点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;w) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先定一个无限小的ed，这种把第一个区间res+1的技巧</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (range[i].l &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大不相交区间"><a href="#最大不相交区间" class="headerlink" title="最大不相交区间"></a>最大不相交区间</h4><p>给定 N 个闭区间 [ai,bi][ai,bi]，在数轴上选择若干区间，使得选中的区间之间互不相交</p><p>这题也是证明难，按照前一题的证明思路</p><p>证明： AnS &lt;&#x3D; cnt &amp;&amp; Ans &gt;&#x3D;cnt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range&amp; w) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; range[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h4><p>给定 N 个闭区间 [ai,bi][ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小</p><ol><li>枚举到一个区间，和前面所有组都有交集，只能新开一个组； 这次以<strong>左端点</strong>排序</li></ol><p>2。 判断满足所有组的Max_r是不是小于新添加区间的L[i],可以用小根堆维护，只要最小的Max_r小于L[i]，则可以放，不需要开新组，就放到最小组中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100030</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r ;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;w) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;  i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= r.l) heap.<span class="built_in">push</span>(r.r); <span class="comment">// 连最小的组都不能加入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 把区间加入最小的组</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h4><p>给定 N 个闭区间 [ai,bi][ai,bi] 以及一个线段区间 [s,t][s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span> (range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r, range[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="comment">// 找不到覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; st)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找完全覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= ed)</span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Huffam树"><a href="#Huffam树" class="headerlink" title="Huffam树"></a>Huffam树</h3><h4 id="合并果园"><a href="#合并果园" class="headerlink" title="合并果园"></a>合并果园</h4><p>核心思想是让权值大的叶子离根最近</p><p>经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。</p><ol><li>最小的两个点，深度一定是最深，且可以互为兄弟</li><li>最小的两个点合并能得到最优解， 再往后求n-1哈夫曼树的问题，继续合并最小两个点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次合并权值最小的两个点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="comment">// 每次合并权值最小的两个点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += b + a;</span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += b + a;</span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h3><h4 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大排队</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(t, t + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res += t[i] * (n - i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h3><h4 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h4><p>在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN</p><p>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><p>一维的选址问题就是求中间点，二维的选址问题求曼哈顿距离的话就是分别求xy，如果是欧几里得问题就是求费马点没有高效的算法用一些随机方法试试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res += <span class="built_in">abs</span>(a[i] - a[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h3><h4 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h4><p>这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。</p><p>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span> , <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII cow[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);</span><br><span class="line">        cow[i] = &#123;w + s, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(cow, cow + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2e9</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w = cow[i].second, s = cow[i].first - cow[i].second;</span><br><span class="line">        res = <span class="built_in">max</span> (res, sum - s);</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网 - 网络是怎样连接的</title>
      <link href="/2023/11/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E9%93%BE%E6%8E%A5%E7%9A%84/"/>
      <url>/2023/11/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E9%93%BE%E6%8E%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h1><h2 id="探索浏览器内容"><a href="#探索浏览器内容" class="headerlink" title="探索浏览器内容"></a>探索浏览器内容</h2><h3 id="生成HTTP请求消息"><a href="#生成HTTP请求消息" class="headerlink" title="生成HTTP请求消息"></a>生成HTTP请求消息</h3><p>URL(uniform resource locator)统一资源定位符<br>FTP (file transfer protocol)文件传送协议<br>HTTP(hypertext transfor protocol) 超文本传送协议<br>TCP（transmission control protocol）传输控制协议<br>UDP（user datagram protocol）用户数据报协议<br>IP（internet protocol）网络互联协议</p><p>浏览器是综合性的客户端软件，需要不同的URL来判断使用哪个功能<br>URL开头部分指明了访问方法(协议)；</p><h4 id="HTTP定义了客户端与服务器之间交互的消息内容和步骤："><a href="#HTTP定义了客户端与服务器之间交互的消息内容和步骤：" class="headerlink" title="HTTP定义了客户端与服务器之间交互的消息内容和步骤："></a>HTTP定义了客户端与服务器之间交互的<strong>消息内容</strong>和<strong>步骤</strong>：</h4><p>内容包括：<br>URI(identifier)：存放网页数据的文件名或者CGI程序的文件名<br>其中CGI(common gateway iterface)通用网关接口 ：web服务器调用其他程序的规则<br>方法：<br>GET POST HEAD OPTIONS PUT DELETE TRACE CONNECT</p><p>Web服务器对其中内容进行解析，完成工作后，结果存放在响应消息中，包括状态码、头字段、网页数据</p><h3 id="向DNS服务器查询Web服务器的IP地址"><a href="#向DNS服务器查询Web服务器的IP地址" class="headerlink" title="向DNS服务器查询Web服务器的IP地址"></a>向DNS服务器查询Web服务器的IP地址</h3><p>TCP&#x2F;IP结构 用集线器链接的计算机形成子网，通过路由器连接成一个大的网络；<br>数据以包的形式传送；</p><p>IP地址： 网络号和主机号；共32位，8比特为一组，十进制表示，圆点隔开；<br>子网掩盖码：写在IP地址右侧，表示IP地址的结构，也可以用网络号的位数表示‘</p><p>DNS(dommain name system)域名服务器系统：用于为各种信息关联相应的名称；<br>DNS解析器用于域名解析，包含在 操作系统的Socket库（操作系统中用于调用网络功能的程序组件几何）中；</p><h3 id="DNS服务器大接力"><a href="#DNS服务器大接力" class="headerlink" title="DNS服务器大接力"></a>DNS服务器大接力</h3><p>控制流程转移；web浏览器——》Socket向DNS查询IP地址——》操作系统内部协议栈；</p><p>DNS接受客户端的查询信息：域名  、Class 、记录类型（A表示IP地址，MX表示邮件服务器）；</p><h4 id="域名层次结构："><a href="#域名层次结构：" class="headerlink" title="域名层次结构："></a>域名层次结构：</h4><ol><li>内部网络服务器数量有限的情况下，可以都保存在一台DNS服务器中；</li><li>多台DNS服务器接力,分层次从后往前缩小，最下层的www为服务器名<br>com的上一层为根域，写法可以省略，根域的IP地址只有13个且不变，一般已经配置在DNS服务器程序中了</li></ol><h4 id="客户端查询过程："><a href="#客户端查询过程：" class="headerlink" title="客户端查询过程："></a>客户端查询过程：</h4><p>最近的DNS服务器——》没有则从根目录自顶向下查找；<br>如果有域名缓存，可以从缓存位置向下查找；</p><p>缓存：使用过的数据存放在离使用该数据较近的高速存储装置中，以提高后续访问速度</p><h4 id="收发数据的操作："><a href="#收发数据的操作：" class="headerlink" title="收发数据的操作："></a>收发数据的操作：</h4><ul><li>1.创建套接字（调用socket）、2.接管道连接到服务器端的套接字上、3.收发数据、4.断开管道并删除套接字；</li></ul><ol><li>创建套接字完成后系统返回 <strong>描述符</strong>，应用程序通过描述符来识别套接字；</li><li>connect连接用到：描述符（应用程序用来识别套接字的机制）、服务器IP地址、端口号（这两个是服务器和客户端实现互相识别对方套接字的机制）</li><li>write和read：接收缓存区</li><li>close：客户端和服务器一端先断开，然后断开操作传到另一端</li></ol><h2 id="用电信号传输TCP-x2F-IP数据——协议栈和网卡"><a href="#用电信号传输TCP-x2F-IP数据——协议栈和网卡" class="headerlink" title="用电信号传输TCP&#x2F;IP数据——协议栈和网卡"></a>用电信号传输TCP&#x2F;IP数据——协议栈和网卡</h2><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908192019506.png" alt="image-20220908192019506"></p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>应用程序——Socket库和解析器——<em>操作系统中的TCP、UDP、IP</em>——网卡驱动程序——硬件网卡</p><p>浏览器、邮件等一般应用程序收发数据时用TCP，DNS查询等收发较短的控制数据时用UDP；<br>网络包：网络中数据的小包（几十到几千字节）；<br>IP协议将网络包发送给通信对象</p><p>套接字作用：记录了用于控制通信操作的各种控制信息，协议栈根据这些信息判断下一步的行动；<br>processID：操作系统为了标识应用程序分配的编号；</p><p>应用程序调用socket创建套接字，协议栈首先分配内存空间，然后写入初始状态，返回描述符给应用程序</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>TCP头部大概有<strong>双方的端口号、初始序号、窗口大小、ACK号、校验、头部长度、控制位</strong>等信息</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193526768.png" alt="image-20220908193526768"></p><p>连接：通信双方交换控制信息，在套接字中记录这些信息并准备数据收发的一连串操作；<br>控制信息：头部中记录的信息和套接字中记录的信息<br>A发送SYN为1的TCP包、创建数据的初始序号、需要的窗口大小——》B返回SYN为1的TCP包、初始序号、窗口大小、返回收到包的ACK号——》B返回收到的ACK号</p><p>TCP模块创建连接控制信息的头部——》找到套接字——》修改状态为正在连接</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>应用程序调用write将数据交给给协议栈，协议栈执行发送操作；</p><ul><li>积累多少数据发送出去判断标准:<strong>1,MTU 2,时间</strong><br>MTU（maximum transmission unit）最大传输单元：每个<strong>网络包</strong>所能容纳的最大长度；一般是1500字节<br>MSS（maximum segment size）最大分段大小：MTU减去头部的长度；也就是实际缓冲区能放的数据量<br>时间主要是看频率，协议栈内部有一个计时器；</li></ul><ol><li>以上两个要素时矛盾的，需要综合考虑，可以指定直接发送</li><li>数据块较大的需要按照MSS拆分</li></ol><ul><li><p>序号和ACK号使用方法——<strong>确认对方是否收到网络包</strong>：<br>连接时将SYN设置为1，并告知初始序号；<br>计算数据长度后发送ACK号，并设置比特为1，表示ACK号有效<br>在返回ACK号确认之前，包都保存在缓冲区，可以重写发送</p></li><li><p>客户端和服务器端双向传输过程</p></li><li><p>网络的错误检测和补偿机制非常复杂；</p></li><li><ol><li>按照ACK返回时间动态调整等待时间；</li><li>滑动窗口管理ACK：接收方通过TCP头部的窗口字段将缓冲区余量告知发送方；发送方在等待ACK返回时继续发送下一个包，但需要在缓冲区余量内。<br>最大数据量称为<strong>窗口大小</strong>：一般就是接收方缓冲区的大小</li><li>ACK和窗口合并，多个ACK时只需要发最后一个以告知接收数据的最后位置——都是为了减少包</li></ol></li><li><p><strong>协议栈接受数据的基本操作</strong>：检查收到的数据库和TCP头部，没有数据确实则返回ACK，将数据放在缓存区，数据拼接为原始数据并交给应用程序（复制到程序的内存空间），最后向发送方发送窗口更新</p></li></ul><h3 id="服务器断开并删除套接字"><a href="#服务器断开并删除套接字" class="headerlink" title="服务器断开并删除套接字"></a>服务器断开并删除套接字</h3><p>例子：服务器端调用Socket库中close程序，协议栈生成包含断开的TCP头部（控制为<strong>FIN设为1</strong>），委托IP模块向客户端发送数据，同时服务端套接字记入断开信息；客户端收到收到TCP头部，协议栈将套接字进入断开状态，并返回给服务器端<strong>ACK号</strong>；协议栈就可以等应用程序取数据了。应用程序read数据，这是协议栈告知应用程序数据收到完成。客户端应用close关闭生成<strong>FIN为1</strong>发送为服务端，服务端<strong>返回ACK</strong>，通信结束。</p><ul><li>删除套接字：需要等待时间以方便重新发送FIN</li></ul><p>总结TCP整体流程：</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908104715535.png" alt="总结TCP整体流程"></p><h3 id="IP和以太网的包收发操作"><a href="#IP和以太网的包收发操作" class="headerlink" title="IP和以太网的包收发操作"></a>IP和以太网的包收发操作</h3><p>mac头部——集线器——子网中的以太网协议（可以更换成其他网络如无线局域网）<br><strong>凡是局域网使用的头部豆角MAC头</strong></p><p>IP头部——IP协议——路由器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193611154.png" alt="image-20220908193611154"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193629305.png" alt="image-20220908193629305"></p><h4 id="包收发操作"><a href="#包收发操作" class="headerlink" title="包收发操作"></a>包收发操作</h4><ol><li>IP模块（包传输过程的入口）：TCP模块委托IP模块发送包，即加上IP头，MAC头，包就封装好了；</li><li>封装好的包交给硬件网卡，将数字信息转换为光电信息，通过集线器、路由器等传递到接收方；</li><li>接收方拿到后做出相应，返回的包被转换为数字信息，加上TCP头部</li></ol><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908145444278.png" alt="image-20220908145444278"></p><p>Gateway网关：在TCP&#x2F;IP中指的是路由器；<br>通过路由表来匹配该把包发给哪个网卡的IP地址；</p><h4 id="以太网内MAC地址查询："><a href="#以太网内MAC地址查询：" class="headerlink" title="以太网内MAC地址查询："></a>以太网内MAC地址查询：</h4><p>ARP（address resolution protocol）地址解析协议：一种地址广播的方法，能返回子网内相应IP地址的MAC地址；</p><p>MAC地址长度为48比特，IP地址长度32比特，也就是6部分，一字节一部分，用-或者：分开，十进制和十六进制表示；<br>media access control</p><p>目前常用的是交换式集线器：信号会更具MAC地址流到指定的设备</p><ul><li><p>以太网特性：</p><ol><li>将包发送到MAC头的接收方MAC地址所代表的的目的地；</li><li>用发送方的MAC地址识别发送方；</li><li>用以太类型识别包类型</li></ol><p>说明：无线局域网也有1和2的特点，所以用来替代以太网</p></li></ul><h4 id="网卡将IP包转化成光电信号（没看）"><a href="#网卡将IP包转化成光电信号（没看）" class="headerlink" title="网卡将IP包转化成光电信号（没看）"></a>网卡将IP包转化成光电信号（没看）</h4><p>网卡中的ROM保存唯一的MAC地址，生产时就写入的，网卡驱动初始化后生效；</p><p>返回接收包：对应MAC地址的包放入缓存区——》产生中断信号，中断控制器，CPU暂时挂起切换到中断程序——》调用网卡驱动执行操作<br>——》从缓冲区中取出包，通过MAC头部中以太类型判断包类型（协议类型）</p><p>接收——》检查IP头部——》如果不一致，返回错误ICMP（查表）</p><h3 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h3><p>TCP复杂是为了实现高效和可靠：缺失部分包的时候只需要发送出错的部分，避免了重发已经送达的包；<strong>（数组在多个包的情况）</strong></p><p>UDP没有连接和断开阶段，只要加上UDP头部，交给IP发送就行了；接收按照IP头部和接收方的地址，UDP头部端口号<strong>（在一个包大小范围内解决）</strong></p><ol><li>UDP只负责单纯发送，不会监控，所以协议栈也不知道有没有错误；</li><li>最大数据长度为IP包减去UDP头部</li><li>音频和视频会使用UDP，确实部分包会失真，但是用TCP要额外的几倍带宽</li></ol><h2 id="网线到网络设备——集线器、交换机、路由器"><a href="#网线到网络设备——集线器、交换机、路由器" class="headerlink" title="网线到网络设备——集线器、交换机、路由器"></a>网线到网络设备——集线器、交换机、路由器</h2><h3 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h3><p>每个包都是独立传输的；</p><p>传输过程：网卡中PHY（MAU）模块将包转化为电信号——》通过RJ-45进入双绞线——》信号流入网线——》集线器的接口；<br>（传输过程中信号会衰减，波形会失真；用<strong>双绞线</strong>来抑制衰减，阻隔噪声措施等）</p><p>——》集线器将信号发送给所有连接在他上面的线路（<strong>原封不动广播</strong>）</p><h3 id="交换机的包转发"><a href="#交换机的包转发" class="headerlink" title="交换机的包转发"></a>交换机的包转发</h3><p>PHY模块接收网线中信号转化为通用格式——》MAC模块将信号转化为数字信号——》包尾部检查FCS——》没异常所有包放到缓冲区——》查询MAC地址表(MAC地址和端口的对应表)——》将信号发送到相应的端口</p><ul><li>交换机的MAC模块不具有MAC地址</li><li>MAC地址表会自动维护，异常时重启交换机重置地址表就行</li><li>全双工模式是交换机特有，可以同时发送和接收操作</li><li>全&#x2F;半双工切换的问题，自动协商功能</li><li>交换机可以同时执行多个转发操作，转发能力强</li></ul><h3 id="路由器的包转发"><a href="#路由器的包转发" class="headerlink" title="路由器的包转发"></a>路由器的包转发</h3><p>路由器是基于IP设计，交换机是基于以太网设计</p><h4 id="路由器转发包过程："><a href="#路由器转发包过程：" class="headerlink" title="路由器转发包过程："></a>路由器转发包过程：</h4><p>通过委托端口接受包（取决于端口通信技术）——转发模块根据接受包的IP头部中记录接收方IP地址，在路由表中查询——》委托端口模块转发包</p><ul><li>端口模块以实际的接收方&#x2F;发送方的身份来收发网络包</li><li>路由器的以太网端口<strong>有MAC地址</strong>，路由器的IP端口<strong>有IP地址</strong></li><li>路由器的子网掩盖码值表示在匹配网络包目标地址时需要对比的比特数，有可能路由聚合合并为一个子网</li></ul><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220909144520902.png" alt="image-20220909144520902"></p><h5 id="路由器接受包"><a href="#路由器接受包" class="headerlink" title="路由器接受包"></a>路由器接受包</h5><ol><li>转化为数字信息，检查MAC地址是否匹配；</li><li>接受操作后包的MAC头部被丢弃（<strong>MAC头部的作用就是将包传递到路由器</strong>）</li></ol><h5 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h5><ol><li>按照IP头部转发，子网掩码配合IP地址，确定候选转发目标</li><li>最长匹配原则</li></ol><h5 id="找不到匹配路由时选择默认路由"><a href="#找不到匹配路由时选择默认路由" class="headerlink" title="找不到匹配路由时选择默认路由"></a>找不到匹配路由时选择默认路由</h5><ol><li>子网掩码<strong>0.0.0.0</strong>，不需要匹配，默认路由，这样配置的网关地址被称为<strong>默认网关</strong></li><li>在找不到其他匹配路由，选择默认路由</li></ol><h5 id="路由器相关工作"><a href="#路由器相关工作" class="headerlink" title="路由器相关工作"></a>路由器相关工作</h5><ul><li><p>TTL：在IP头部，表示保底有效期，经过一个路由器减1,为0就是超过有效期。<br>一般设置为64&#x2F;128，防止信息错误或者路由混乱</p></li><li><p>分片功能拆分大网络包:<br>原因：不同类型线路传输的最大包长度不同；<br>操作：用IP协议中定义的分片功能，对整个包拆分<br>前提：检查MTU，检查IP头部标志字段是否能拆</p></li></ul><blockquote><p>不同于TCP拆分，TCP是在数据拆好后放到包中，也就是一个数据块刚好是包的大小</p></blockquote><h5 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h5><p>判断下一个转发目标：<br>    如果网关列表内容为IP地址，该地址为下一个转发目标；<br>    网关列表为空，则IP头部中的接收方IP地址为下一个转发目标；<br>路由器也会用ARP查询下一个转发目标的MAC地址；         </p><h4 id="路由器和交换机"><a href="#路由器和交换机" class="headerlink" title="路由器和交换机"></a>路由器和交换机</h4><p>所说的加上MAC头，实际是上将IP包装进以太网包的数据部分，委托以太网传输数据，i.e. 路由器把包的传输工作委托给交换机；</p><p><strong>IP（路由器）负责将包发送给通信对象整个过程；</strong></p><p><strong>以太网（交换机）将包传输到下一个路由器；</strong></p><h3 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h3><p>为了解决地址不足分为<strong>私有地址(golbally unique address)，公有地址(public address)</strong></p><p>私有地址是公有地址还没有分配的范围</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220909172640673.png" alt="image-20220909172640673"></p><p>但是公司内部的私有地址不能和互联网直接进行通信，需要通过地址转换机制</p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>地址转换设备（路由器）</p><p>改写端口号，提高公有地址的利用率</p><h2 id="接入网和网络运营商"><a href="#接入网和网络运营商" class="headerlink" title="接入网和网络运营商"></a>接入网和网络运营商</h2><h3 id="ADSL接入网的结构和工作方式"><a href="#ADSL接入网的结构和工作方式" class="headerlink" title="ADSL接入网的结构和工作方式"></a>ADSL接入网的结构和工作方式</h3><p>互联网上万台路由器，按照接收方IP地址判断，将包转发出去；<br><strong>距离的不同和路由的维护方式</strong>不同，就是互联网与家庭、公司网络之间最初主要的两个不同点；</p><p>接入网：连接互联网与家庭、公司网络的通信线路（ADSL、FTTH、CATV、电话线、ISDN等）；<br>ADSL（asymmetric digital subscriber line）不对称数字用户线</p><p>ADSL modem 调制解调器：将包拆分成信元，并且转化为电信号发送给分离器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911135603820.png" alt="image-20220911135603820"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911140104023.png" alt="image-20220911140104023"></p><p>BAS（broadband access server）宽带接入服务器 ，一种<strong>路由器</strong>（不同与普通，具有身份认证，向客户端下发IP地址等配置信息的功能）：1.用户认证的窗口，2.隧道方式传输网络包</p><p>PPP （point to point protocol）点到点协议。电话线、ISDN等通信路线所用的一种协议</p><p>ATM （asynchronous transfer mode）异步传输 ，电话线为载体的通信方式，以“信元”为单位进行。</p><p>FTTH （Fibre (Fiber) To The Home）基于光线的接入网技术：用光纤代替ADSL将用户端接入路由器和运营商的BAS连接起来的接入方式</p><h4 id="分离器的作用"><a href="#分离器的作用" class="headerlink" title="分离器的作用"></a>分离器的作用</h4><p>ADSL modem将信元转化为电信号后，通过分离器，但没作用；（电话和ADSL信号同时流入线路）<br>信号从电话线传入时，分离电话和ADSL信号，防止ADSL成为电话的噪音：<br>        对于电话：分离器过滤掉高频的ADSL；<br>        对ADSL：ADSL modem内部就有信号过滤功能；<br>分离器也可以房子电话对ADSL传输方式的干扰</p><p>分离器——》电话线——》总配线架——》电话局——》DSLAM（转回数字信号 信元）——》BAS（将ATM信元转化为原始的包）</p><h3 id="光纤接入网"><a href="#光纤接入网" class="headerlink" title="光纤接入网"></a>光纤接入网</h3><p>光线的工作原理。。</p><h4 id="FTTH技术"><a href="#FTTH技术" class="headerlink" title="FTTH技术"></a>FTTH技术</h4><ol><li>直连：一种是光纤直接从用户端连接到最近的电话局：以太信号——》光信号——》DSLAM——》BAS转化为电信号，将包转发到互联网内部——》到达互联网后，服务器响应——》响应包的光信号沿着光纤返回</li></ol><p>​光线中波分复用，区别上行和下行信号</p><ol start="2"><li>分路：分光器设备，让光纤分录，同时连接多个用户：OLT和ONU避免碰撞；</li></ol><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911154100876.png" alt="image-20220911154100876"></p><h3 id="接入网中使用的PPP和隧道"><a href="#接入网中使用的PPP和隧道" class="headerlink" title="接入网中使用的PPP和隧道"></a>接入网中使用的PPP和隧道</h3><p>PPPoE（Point to Point Protocol  over Ethernet）以太网的点对点协议：将PPP消息装入以太网包进行传输的方式；</p><p>包原封不动的搬运到另一端，原理上就可以看成建立隧道；</p><p>互联网接入路由器通过PPPoE的发现机制查询BAS的MAC地址（相当于拨号上网中拨号）</p><ul><li>地址转换：是否BAS向计算机下发了TCP&#x2F;IP配置，没下发需要在路由器中转化为公有地址</li></ul><h3 id="网络运营商的内部"><a href="#网络运营商的内部" class="headerlink" title="网络运营商的内部"></a>网络运营商的内部</h3><p>POP(Point of Presense)接入点：ADSL、FTTH等接入网的连接点，互联网的入口在这里</p><p>NOC（Network Operation Center）网络运行中心，（扩大版、高性能的POP）</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911155250806.png" alt="image-20220911155250806"></p><p>按照不同类型的接入网分别使用不同类型的路由器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911160108080.png" alt="image-20220911160108080"></p><h3 id="跨越运营商的网络包"><a href="#跨越运营商的网络包" class="headerlink" title="跨越运营商的网络包"></a>跨越运营商的网络包</h3><p>BGP（border gateway protocol） 边界网关协议：路由信息交换的过程；</p><p>运营商之间所有路由器平等交换，多路判断优先级，收费；</p><p>IX(internet eXchange)互联网交换中心：将运营商汇聚在一起，设置中信设备，减少线路数量；具有高速以太网端口的二层交换机</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911162156742.png" alt="image-20220911162156742"></p><h2 id="服务器端的局域网"><a href="#服务器端的局域网" class="headerlink" title="服务器端的局域网"></a>服务器端的局域网</h2><p>在服务器前部署一个防火墙：只允许发往特定服务器中的特定应用程序的包通过，屏蔽其他的包；常用的是包过滤方式</p><h4 id="包过滤方式（主流防火墙方式）"><a href="#包过滤方式（主流防火墙方式）" class="headerlink" title="包过滤方式（主流防火墙方式）"></a>包过滤方式（主流防火墙方式）</h4><ul><li>设置允许通过的<strong>接收方IP和发送方IP</strong>（注意应答机制，要回复ACK）</li><li>设置端口号限定应用程序，<strong>接收方端口号、发送方端口号</strong></li><li><strong>控制位</strong>判断连接方向（TCP头部的控制位；但是对UDP没有控制位可以设置只能公司内网访问DNS服务器，牺牲便利性）</li><li>对具体数据不能识别风险：一种是持续关注安全漏洞信息并更新软件的版本；一种是在防火墙之外部署用来检查包内容并阻止有害包的设备或软件。</li></ul><p>内网访问公开区域</p><p>外部互联网访问公司内网，默认不能访问，内网到外网的话需要地址转化</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911171030839.png" alt="image-20220911171030839"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911171046135.png" alt="image-20220911171046135"></p><h4 id="通过将请求平均分配给多台服务器来平衡负载"><a href="#通过将请求平均分配给多台服务器来平衡负载" class="headerlink" title="通过将请求平均分配给多台服务器来平衡负载"></a>通过将请求平均分配给多台服务器来平衡负载</h4><p>服务器的访问量上升，需要增加带宽和提高服务器性能；<br>提高服务器性能可以使用多台服务器来分担负载的方法——分布式架构；<br>采用多台Web服务器，减少每台服务器的访问量；<br>用DNS按顺序循环分配多台不同的IP地址——轮询；</p><p>问题：1. 一台宕机了咋办——访问返回失败，尝试下一个IP<br>            2. 有些操作跨多个页面，访问服务器变化则操作无法继续</p><h5 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h5><p>用其IP地址代替Web服务器的实际地址注册到DNS服务器上；</p><p>操作跨多个页面时，请求发送到同一个Web服务器——》判断请求之间的相关性，在HTTP头部加入Cookie<br>其他情况需要定期采集Web服务器的CPU、内存使用率</p><h5 id="缓存服务器"><a href="#缓存服务器" class="headerlink" title="缓存服务器"></a>缓存服务器</h5><p>服务器按照功能划分不同服务器，缓存服务器是一台通过代理机制对数据进行缓存的服务器；<br>代理在Web服务器和客户端之间，Web服务器返回的数据保存在此版中（<strong>缓存</strong>）</p><p>缓存服务器注册到DNS服务器中</p><p>Via: 表示缓存服务器中专的</p><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p>缓存服务器在客户端一侧部署；用作转发过程判断是否允许访问、用作防火墙的实现；</p><ul><li><p>设置时，需要在浏览器的设置窗口的代理服务器中填写正向代理的IP地址</p></li><li><p>有代理时，客户端发送给缓存服务器的请求头不需要直接填写http:&#x2F;&#x2F;这样的完整网址</p></li></ul><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p>服务器端的缓存服务器，将请求消息中URI的吗，目录名与Web服务器进行关联，能转发不带完整网址的请求</p><h5 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h5><p>用包的IP头部中接收方的Ip地址判断访问服务器；</p><p>在消息经过时拦截</p><h3 id="内容分发服务"><a href="#内容分发服务" class="headerlink" title="内容分发服务"></a>内容分发服务</h3><p>缓存服务器放在客户端——降低Web服务器的负载——无法减少互联网的网络流量</p><p>缓存服务器放在Web服务器端——Web服务器无法控制——减少网络流量</p><p>缓存服务器放在互联网的边缘（集合优点，但是互联网都可以访问，部署数量需求多）——服务器运营者能控制——降低网络流量</p><p>内容分发服务：CDN(content delivery network) 或者叫CDS(system)<br>内容分发服务运营商：CDSP(provider)</p><p>提前查询路由器到各个缓存服务器的之间的距离，判断最近的</p><h2 id="请求到达服务器，响应返回浏览器"><a href="#请求到达服务器，响应返回浏览器" class="headerlink" title="请求到达服务器，响应返回浏览器"></a>请求到达服务器，响应返回浏览器</h2><h3 id="服务器的基本信息"><a href="#服务器的基本信息" class="headerlink" title="服务器的基本信息"></a>服务器的基本信息</h3><p>服务器和客户端的协议栈、网卡、Socket库（调用其中的程序组件不一致）等功能一致，TCP&#x2F;IP的功能统一，客户端计算机也可以用作服务器；</p><h5 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h5><p>客户端通信模块一般是与客户端一对一的关系；<br>服务器操作系统具有多任务、多线程功能，同时运行多个程序；<br>：任务作为单个程序，线程是程序的一个部分</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220912222625199.png" alt="image-20220912222625199"></p><p>服务器在调用Socket库上的区别在连接阶段：<br>客户端：用管道连接服务器端的套接字<br>服务器端：1.将套接字设置为等待连接的状态 2. 接受连接</p><p>套接字的确定：客户端IP地址、客户端端口号、服务器IP地址、服务器端口号；</p><p>使用描述符来指代套接字的原因：等待连接的套接字中没有客户端IP地址和端口号、使用描述符比较简单</p><h3 id="服务器接收操作"><a href="#服务器接收操作" class="headerlink" title="服务器接收操作"></a>服务器接收操作</h3><h5 id="服务器接收操作的全过程回顾"><a href="#服务器接收操作的全过程回顾" class="headerlink" title="服务器接收操作的全过程回顾"></a>服务器接收操作的全过程回顾</h5><blockquote><p>网卡（硬件）接收信号，转化为数字信号——》按照包尾部的帧校验符FCS来校验错误——》MAC头部检查接收方的MAC地址——》保存在网卡的缓冲区中</p></blockquote><ul><li>网卡的MAC模块将网络包从信号还原为数字信息，校验FCS并且存入缓冲区</li></ul><blockquote><p>——》CPU处理中断，网卡驱动运行，读取缓冲区的包——》根据MAC头部的以太类型判断协议种类——》调用负责处理该协议的程序（也就是TCP&#x2F;IP协议栈）</p></blockquote><ul><li>网卡驱动按照MAC头部判断协议类型，并且发送个相应的协议栈</li></ul><blockquote><p>——》达到协议栈后，IP模块检查IP头部中接收方IP地址，判断转发——》检查IP头部知道是否分片，如果分片了，现存在内存里，等组装充足后还原为原始包——》检查IP头部的协议号，06则为TCP模块，11为UDP模块</p></blockquote><ul><li>协议栈的IP模块检查IP头部，判断是不是发给自己的，网络包有没有呗切片，对应转发协议栈是TCP还是UDP</li></ul><blockquote><p> ——》TCP模块按照包的内容区别，如果是SYN为1发起连接的包——》检查包的接收方端口号有没有等待连接的套接字——》无则返回ICMP消息，有则创建套接字副本，信息写入套接字生成ACK号，生产TCP头部，委托IP模块发送给客户端——》客户端返回ACK号确认，连接完成——》服务器端及进入调用accept的暂停状态，当将新套接字的描述符转交服务器程序后，服务器恢复运行</p></blockquote><ul><li>TCP模块：根据收到包的发送方&#x2F;接收方的IP地址&#x2F;端口号找到对应的套接字；将数据拼接放在缓冲区；向客户端返回ACK号</li></ul><blockquote><p>——》服务器或者客户端发起，调用Socket库中close，TCP模块生成控制位FIN为1,发送——》客户端或服务器返回一个ACK号，生成FIN为1的TCP头部发送——》服务器或客户端返回ACK号完成</p></blockquote><ul><li>HTTP1.1中，客户端先发起断开；断开操作后，套接字过一段时间被删除</li></ul><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220913140803131.png" alt="image-20220913140803131"></p><h3 id="Web服务程序解释请求消息并做出相应"><a href="#Web服务程序解释请求消息并做出相应" class="headerlink" title="Web服务程序解释请求消息并做出相应"></a>Web服务程序解释请求消息并做出相应</h3><p>最简单的是按照请求方法+URI的HTML文件名获取</p><p>判断访问权限依据：客户端IP地址；客户端域名；用户名和密码</p><h3 id="浏览器接受响应消息并显示内容"><a href="#浏览器接受响应消息并显示内容" class="headerlink" title="浏览器接受响应消息并显示内容"></a>浏览器接受响应消息并显示内容</h3><p>按照Content-Type判断数据类型</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220913142737133.png" alt="image-20220913142737133"></p><p>charset&#x3D;urf-8表示文本编码方式</p><p>Content-Encoding表示压缩格式的具体转换方式</p><p>实际显示是浏览器负责对操作系统发出指令显示的</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>网络是怎样连接的 - 户根勤</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么 你不服气吗？</title>
      <link href="/2023/11/06/test1/"/>
      <url>/2023/11/06/test1/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="怎么-你不服气吗？"><a href="#怎么-你不服气吗？" class="headerlink" title="怎么 你不服气吗？"></a>怎么 你不服气吗？</h1><p><img src="/imgs/$%7Bfiilename%7D/bufuqi.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入信息(退出输入e或exit):&quot;</span>);</span><br><span class="line"><span class="comment">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((s = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;安全退出!!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将读取到的整行字符串转成大写输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt;:&quot;</span> + s.toUpperCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            br.close(); <span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ - 复习STL和泛型</title>
      <link href="/2023/11/06/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/11/06/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一讲：STL和泛型概述"><a href="#第一讲：STL和泛型概述" class="headerlink" title="第一讲：STL和泛型概述"></a>第一讲：STL和泛型概述</h1><h2 id="认识headers、版本、重要资源"><a href="#认识headers、版本、重要资源" class="headerlink" title="认识headers、版本、重要资源"></a>认识headers、版本、重要资源</h2><h4 id="1STL"><a href="#1STL" class="headerlink" title="1STL"></a>1STL</h4><p>1.C++标准库具有6大部件，使用的方法，认识、使用、扩充；</p><p>2.C++SL包括C++STL六大部件和其他零碎的</p><p>3.新式的headers内的组件封装在namespace std</p><h2 id="STL体系架构"><a href="#STL体系架构" class="headerlink" title="STL体系架构"></a>STL体系架构</h2><h4 id="六个部件"><a href="#六个部件" class="headerlink" title="六个部件"></a>六个部件</h4><ol><li>容器containers、分配器allocators、算法algorithms、迭代器iterators、适配器adapters、仿函数Functors</li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221007201443143.png" alt="image-20221007201443143"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大于等于40的数</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>,allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia,ia+<span class="number">6</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),<span class="number">40</span>)));</span><br></pre></td></tr></table></figure><p>not1(bind2nd(less<int>(),40))为一个predicate，谓词</p><ol start="2"><li>复杂度Big-oh 其中n为一个比较大的规模</li></ol><h4 id="“前闭后开”区间用于标准库容器；"><a href="#“前闭后开”区间用于标准库容器；" class="headerlink" title="“前闭后开”区间用于标准库容器；"></a>“前闭后开”区间用于标准库容器；</h4><p>3.1 迭代器定义一<code>contianer&lt;T&gt;::iterator ite =c.begin()</code><br>3.2 <code>for(decl:coll)&#123;statement&#125;</code><br>3.3 <code>for(auto&amp; elem:vec)&#123;elem*=3&#125;;</code></p><h2 id="容器之分类与各种测试"><a href="#容器之分类与各种测试" class="headerlink" title="容器之分类与各种测试"></a>容器之分类与各种测试</h2><h4 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h4><p>sequence contaniners：array、vector 、deque、list、forward_list</p><p>associative contanniers：set&#x2F;multiset、map&#x2F;multimap（STL没有规定怎么实现，一般编译器采用红黑树实现）</p><p>unordered contaniners不定序：unordered_(hash table实现，其用separate chaining创建)</p><ul><li>呼叫时间调用clock()</li><li>全局函数前面加上::，比如<code>::find</code></li><li>容器自身算法有的时候，用容器自身的</li></ul><h4 id="容器扩充"><a href="#容器扩充" class="headerlink" title="容器扩充"></a>容器扩充</h4><p>vector的扩展是两倍扩展，新空间并拷贝原值</p><p>forward_list,一个个扩充</p><p>deque，左右边界满，扩充</p><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>一个类，不建议单独使用，应该用容器本身或者new和delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">allocator&lt;<span class="type">int</span>&gt; alloc1;</span><br><span class="line">p=alloc1.<span class="built_in">allocator</span>(<span class="number">1</span>);</span><br><span class="line">alloc1.<span class="built_in">deallocate</span>(p,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="源代码之分布（VC，GCC）"><a href="#源代码之分布（VC，GCC）" class="headerlink" title="源代码之分布（VC，GCC）"></a>源代码之分布（VC，GCC）</h2><p>2.91源代码的说明</p><h3 id="泛型GP和OOP"><a href="#泛型GP和OOP" class="headerlink" title="泛型GP和OOP"></a>泛型GP和OOP</h3><p>OOP（objective-Oriented programming）企图将date和methods合在一起；</p><p>GP(generic programming)将date和methods分开来</p><ul><li>list不能用sort()，因为不能随机访问，也就不能用二分查找</li></ul><blockquote><p>所有algorithms，其内最终设计元素本身的操作，无非就是比大小；所以类型本身类需要重载比大小操作符</p></blockquote><h3 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h3><ol><li>函数模板 <code>template &lt;typename T&gt;</code></li><li>类模板 <code>template &lt;class T&gt;</code></li><li>成员模板</li></ol><h4 id="类模板中泛化、特化、偏特化"><a href="#类模板中泛化、特化、偏特化" class="headerlink" title="类模板中泛化、特化、偏特化"></a>类模板中泛化、特化、偏特化</h4><h5 id="泛化：操作符重载和模板的复习"><a href="#泛化：操作符重载和模板的复习" class="headerlink" title="泛化：操作符重载和模板的复习"></a>泛化：操作符重载和模板的复习</h5><h5 id="Specialization-特化（全特化）"><a href="#Specialization-特化（全特化）" class="headerlink" title="Specialization 特化（全特化）"></a>Specialization 特化（全特化）</h5><p>在泛化的模板基础上，指定类型</p><p>也就是 <code>class allocator&lt;void&gt;</code> 指定了 _Tp为void类型</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008165726014.png" alt="image-20221008165726014"></p><h5 id="Partial-Specialization-偏特化"><a href="#Partial-Specialization-偏特化" class="headerlink" title="Partial Specialization 偏特化"></a>Partial Specialization 偏特化</h5><p>分为</p><ol><li>数量上（多参数中某些特化）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">People</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类的偏特化 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line">    <span class="comment">// 这句指定了偏特化T2类型到T1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&lt;T1, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(T1 a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>范围上(随意类型到指针 特化为 指针类型 或者const类型)</li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008165747920.png" alt="image-20221008165747920"></p><h1 id="第二讲：STL容器解析"><a href="#第二讲：STL容器解析" class="headerlink" title="第二讲：STL容器解析"></a>第二讲：STL容器解析</h1><h2 id="分配器allocator"><a href="#分配器allocator" class="headerlink" title="分配器allocator"></a>分配器allocator</h2><p>学习目的：理解效率，不要单独用</p><p>operator new()实际上使用malloc（）</p><h5 id="malloc-的理解"><a href="#malloc-的理解" class="headerlink" title="malloc()的理解"></a>malloc()的理解</h5><p>底层都是malloc()和free()使用分配内存;</p><p>malloc()分配时有额外的开销；</p><h5 id="allocators-的两个成员函数"><a href="#allocators-的两个成员函数" class="headerlink" title="allocators()的两个成员函数"></a>allocators()的两个成员函数</h5><p>VC6+中的allocate和deallocate，只是::operator new和::operator delete完成的；</p><p>GC和BC都也是malloc，额外开销有点大；</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器之间的关系"><a href="#容器之间的关系" class="headerlink" title="容器之间的关系"></a>容器之间的关系</h3><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008173455125.png" alt="image-20221008173455125"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008173745929.png" alt="image-20221008173745929"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>实际上里面只有一个指针（G2.9）,G4.9里存了两个指针</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008202939418.png" alt="image-20221008202939418"></p><p>void* 无类型指针：void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void指针赋值。</p><h4 id="简要包括"><a href="#简要包括" class="headerlink" title="简要包括"></a>简要包括</h4><ol><li>一堆typedef</li><li>每个节点的设计</li><li>一些操作符重载</li></ol><h4 id="操作符重载的-符"><a href="#操作符重载的-符" class="headerlink" title="操作符重载的++符"></a>操作符重载的++符</h4><p>前++重载函数无入参；后++一个入参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;node=(link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;<span class="comment">//前++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;self tmp=*<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;<span class="comment">//后++（用后++去调用前++）</span></span><br></pre></td></tr></table></figure><p>C++不允许后++两次；</p><h4 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载*"></a>操作符重载*</h4><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008203508483.png" alt="image-20221008203508483"></p><h4 id="G4-9对G2-9的改进"><a href="#G4-9对G2-9的改进" class="headerlink" title="G4.9对G2.9的改进"></a>G4.9对G2.9的改进</h4><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008203703884.png" alt="image-20221008203703884"></p><h4 id="Iterator需要遵循的原则"><a href="#Iterator需要遵循的原则" class="headerlink" title="Iterator需要遵循的原则"></a>Iterator需要遵循的原则</h4><h6 id="iterator的五种associated-type需要定义出来，以便回答算法调用时的提问；"><a href="#iterator的五种associated-type需要定义出来，以便回答算法调用时的提问；" class="headerlink" title="iterator的五种associated type需要定义出来，以便回答算法调用时的提问；"></a>iterator的五种associated type需要定义出来，以便回答算法调用时的提问；</h6><p>value_type 元素类型</p><p>difference_type距离类型</p><p>iterator_category 迭代器类型：</p><blockquote><p>1、input_iterator：istream独有的迭代器。<br>2、output_iterator：ostream独有的迭代器。<br>3、forward_iterator：继承自input_iterator，单向走的迭代器，只能走一个，不能跳。如forward_list、单向list的hashtable<br>4、bidirectional_iterator：继承自forward_iterator，双向走的迭代器，只能走一个，不能跳。如list、rb-tree、双向list的hashtable<br>5、random_access_iterator：继承自bidirectional_iterator，可以跳的迭代器。如array、vector、deque。</p></blockquote><p>reference</p><p>pointer</p><p>后两种从来没用到</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008205733573.png" alt="image-20221008205733573"></p><h4 id="萃取traits特性"><a href="#萃取traits特性" class="headerlink" title="萃取traits特性"></a>萃取traits特性</h4><p>如果iterator不是一个类，而是指针，不能用typedef咋办？？？？</p><p>方法是增加中间层——萃取机iterator_traits</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008210535103.png" alt="image-20221008210535103"></p><p>第一种是问I，第二种用偏特化区别指针和常量指针</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><strong>实际上是三个指针，大小为12</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008211832130.png" alt="image-20221008211832130"></p><h4 id="容量扩充函数的实现"><a href="#容量扩充函数的实现" class="headerlink" title="容量扩充函数的实现"></a>容量扩充函数的实现</h4><p>当容量不够了，找新空间并两倍成长（有的时候是1.5 看版本），拷贝前部，拷贝后部</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008213508832.png" alt="image-20221008213508832"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008213538716.png" alt="image-20221008213538716"></p><h4 id="traits特性"><a href="#traits特性" class="headerlink" title="traits特性"></a>traits特性</h4><p>G2.9也是依靠萃取机作为中介，区分指针和迭代器类；G4.9也是，只是typedef很多次，评价为乱七八糟</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>没有构造、析构函数</p><p>array&lt;int ,10&gt; myArray;</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011133911387.png" alt="image-20221011133911387"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011134049430.png" alt="image-20221011134049430"></p><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011134328233.png" alt="image-20221011134328233"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ol><li><p>分段连续；</p></li><li><p>扩充时分配新的缓冲区，并且指针指向；</p></li><li><p>iterator有四个元素，node指向控制中心；当cur到达last后，需要通过node指向下一个buffer；</p></li><li><p>控制中心是vector，当缓冲区数量不够的时候，两倍增长；</p></li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011135259752.png" alt="image-20221011135259752"></p><h4 id="简要包括-1"><a href="#简要包括-1" class="headerlink" title="简要包括"></a>简要包括</h4><p>start和finish(iterator)，一个map(T**) ,一个map_type(size_type);其中iterator有四个元素，大小是16；</p><p>总大小是16+16+4+4&#x3D;40；</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011140426560.png" alt="image-20221011140426560"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011141436990.png" alt="image-20221011141436990"></p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>判断指定位置靠近头还是尾&#x3D;》推动原来的元素往前或往后&#x3D;》在指定位置插入新元素</p><h4 id="deque如何模拟连续空间"><a href="#deque如何模拟连续空间" class="headerlink" title="deque如何模拟连续空间"></a>deque如何模拟连续空间</h4><p>全部都是iterator的功劳</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011141645219.png" alt="image-20221011141645219"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142440111.png" alt="image-20221011142440111"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142457558.png" alt="image-20221011142457558"></p><ol><li><p>++调用set_node；–先判断cur</p></li><li><p>后++调用前++</p></li><li><p>+调用+&#x3D;；+&#x3D;的时候，判断有没有超出当前缓冲区，并调整缓冲区位置</p></li><li><p>-调用-&#x3D;；-&#x3D;调用+&#x3D;{return *this +&#x3D; -n;}</p></li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142758686.png" alt="image-20221011142758686"></p><h4 id="G4-9对G2-9的改进-1"><a href="#G4-9对G2-9的改进-1" class="headerlink" title="G4.9对G2.9的改进"></a>G4.9对G2.9的改进</h4><ol><li>deque类继承；</li><li>入参去掉了buffer_size，只有两个了</li></ol><h3 id="queue和stack"><a href="#queue和stack" class="headerlink" title="queue和stack"></a>queue和stack</h3><p>这两个是容器适配器；</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011150245087.png" alt="image-20221011150245087"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011150254672.png" alt="image-20221011150254672"></p><h5 id="一些特性："><a href="#一些特性：" class="headerlink" title="一些特性："></a>一些特性：</h5><ol><li>不允许遍历，不提供iterator；</li><li>包含deque，并且封锁一些接口；这两者实际上list也可以作为底层容器，但是慢；stack也可以用vector作为底层容器，queue不能，因为没有pop()操作；都不能用set和map作为底层；</li></ol><h3 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h3><h4 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h4><p>红黑树是平衡二叉搜索树中常被使用的一种；排序规则有利search和insert，并保持高度平衡；</p><p>红黑树提供遍历和iterators；按照正常规则遍历，就能得到排序状态；</p><p>不应使用iterators改变元素值，但是编程里面有没有禁止此。如此设计，是因为rb_tree即将为set和map服务，map允许元素的date被改变，只有元素的key才是不可改变的；</p><p>红黑树提供两种insertion操作：inset_unique()和insert_equal()</p><h4 id="容器re-tree"><a href="#容器re-tree" class="headerlink" title="容器re_tree"></a>容器re_tree</h4><p>value分为key和date两部分</p><p>模板参数5个</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011154503636.png" alt="image-20221011154503636"></p><p>使用举例</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011155147816.png" alt="image-20221011155147816"></p><h4 id="G4-9对G2-9的修改"><a href="#G4-9对G2-9的修改" class="headerlink" title="G4.9对G2.9的修改"></a>G4.9对G2.9的修改</h4><p>改为容器_Rb_tree</p><p>新版是24个字节</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011155838022.png" alt="image-20221011155838022"></p><h3 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h3><p>内含红黑树，set也是一个container adapter容器适配器</p><p>set的key就是value；</p><p>set的迭代器是const_iterator，不能修改</p><p>inset_unique()和insert_equal()的区别</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011215003032.png" alt="image-20221011215003032"></p><h3 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h3><p>以rb_tree为底层结构，自动排序</p><p>无法用iterators改变元素的key，但是可以改变date；底层实现的iterator就是红黑树的，不做任何约束，但是在模板参数设置时<code>pair&lt;const Key,T&gt; value_type</code>  </p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011221046294.png" alt="image-20221011221046294"></p><p>multimap不能用[]插入</p><blockquote><p>lower_bound二分查找，在有序数列中查找与value相同第一元素的迭代器，如果没有则返回第一个&gt;&#x3D;value的元素的迭代器，再没有就返回end()；也就是说不破坏排序得以安插value的第一个适当的位置;</p></blockquote><p> <strong>既然[]判断元素不存在的时候，也是调用insert，直接调用insert比较快</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011221344136.png" alt="image-20221011221344136"></p><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>散列表比红黑树简单</p><p>如果发送碰撞，用链表串Separate Chaining在一起;但是链表太长（元素个数比桶个数多），要把它打散，就是把桶扩大一倍，并取最近的素数（实际上备选的list中元素已经预选好）作为新的桶个数，所有元素重新计算一遍；</p><p>![image-20221011223731538](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221011223731538.png)</p><p>模板参数6个：Value, Key, HasFcn, ExtractKey, EqualKey, Alloc</p><p>Data大小19(20)：hash(1), equals(1), get_key(1), buckets(12),num_elements(4)</p><p>![image-20221013160407487](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013160407487.png)</p><p>HashFunction的设置</p><p>![image-20221013163528922](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013163528922.png)</p><h3 id="unordered容器"><a href="#unordered容器" class="headerlink" title="unordered容器"></a>unordered容器</h3><p>![image-20221013164353617](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013164353617.png)</p><h1 id="第三讲：STL算法"><a href="#第三讲：STL算法" class="headerlink" title="第三讲：STL算法"></a>第三讲：STL算法</h1><p>算法是模板函数，其他都是模板类；</p><p>算法看不到容器，所有信息都由迭代器告知</p><p>两种形式，包含Cmp和不包含：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Cmp&gt;</span></span><br><span class="line"><span class="function"><span class="title">Algorithm</span><span class="params">(Iterator itr1,Iterator it2,Cmp comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Random Access和不能；双向和单向</p><h3 id="迭代器的分类继承图"><a href="#迭代器的分类继承图" class="headerlink" title="迭代器的分类继承图"></a>迭代器的分类继承图</h3><p>这样的好处是，用萃取提取迭代器的类型是，可以用不同入参的类型重载提取函数</p><p>![image-20221013170117951](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170117951.png)</p><p>![image-20221013170857286](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170857286.png)</p><p>在头文件typeinfo中函数typeid()，能得到编译后的类型名称</p><p>![image-20221013170950813](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170950813.png)</p><h3 id="istream-iterator和ostrean-iteraror"><a href="#istream-iterator和ostrean-iteraror" class="headerlink" title="istream_iterator和ostrean_iteraror"></a>istream_iterator和ostrean_iteraror</h3><p>这两种的iterator_category</p><p>![image-20221013171729243](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013171729243.png)</p><p>![image-20221013171734578](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013171734578.png)</p><h3 id="逆向迭代器reverse-iterator"><a href="#逆向迭代器reverse-iterator" class="headerlink" title="逆向迭代器reverse_iterator"></a>逆向迭代器reverse_iterator</h3><p>调用迭代器适配器</p><p>![image-20221014140726217](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014140726217.png)</p><h3 id="iterator对算法的影响"><a href="#iterator对算法的影响" class="headerlink" title="iterator对算法的影响"></a>iterator对算法的影响</h3><h4 id="distance算法"><a href="#distance算法" class="headerlink" title="distance算法"></a>distance算法</h4><p>：返回值，输入参数</p><ol><li>其中randomaccess类型只需要相减，但是input类型只能一步步操作，差异非常大</li><li>distance()调用子函数_distance()的不同重载，这是常见的处理方法</li></ol><p>![image-20221013190247992](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013190247992.png)</p><h4 id="advance-算法"><a href="#advance-算法" class="headerlink" title="advance()算法"></a>advance()算法</h4><p>与distance不同，这里用iterator_category()函数返回迭代器的类型</p><p>![image-20221013191224717](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013191224717.png)</p><h4 id="copy-算法"><a href="#copy-算法" class="headerlink" title="copy()算法"></a>copy()算法</h4><p>![image-20221013194550327](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013194550327.png)</p><h4 id="destroy-算法"><a href="#destroy-算法" class="headerlink" title="destroy()算法"></a>destroy()算法</h4><p>![image-20221013192424286](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013192424286.png)</p><h4 id="unique-copy-算法"><a href="#unique-copy-算法" class="headerlink" title="unique_copy()算法"></a>unique_copy()算法</h4><p>![image-20221013192928038](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013192928038.png)</p><h4 id="小结对算法的影响"><a href="#小结对算法的影响" class="headerlink" title="小结对算法的影响"></a>小结对算法的影响</h4><p>继承可以翻译为is a</p><p>算法源码对迭代器类型的暗示是通过形参的名字告诉你，但是必须接受所有类型的迭代器；</p><p>![image-20221013194419258](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013194419258.png)</p><h2 id="算法例子剖析"><a href="#算法例子剖析" class="headerlink" title="算法例子剖析"></a>算法例子剖析</h2><p>按照算法的标准样式，区别STL的算法和普通函数</p><h3 id="算法例子11个"><a href="#算法例子11个" class="headerlink" title="算法例子11个"></a>算法例子11个</h3><h4 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate()算法"></a>accumulate()算法</h4><p>第三个参数可以是自定义函数或者仿函数的对象</p><p>![image-20221014135321464](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135321464.png)</p><h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each()算法"></a>for_each()算法</h4><p>![image-20221014135418453](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135418453.png)</p><h4 id="replace-算法"><a href="#replace-算法" class="headerlink" title="replace()算法"></a>replace()算法</h4><p>![image-20221014135440211](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135440211.png)</p><h4 id="count-算法"><a href="#count-算法" class="headerlink" title="count()算法"></a>count()算法</h4><p>迭代器类型非random_access的不能用</p><p>关联容器用自带的快多了</p><p>![image-20221014135546161](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135546161.png)</p><h4 id="find-算法"><a href="#find-算法" class="headerlink" title="find()算法"></a>find()算法</h4><p>迭代器类型非random_access的不能用</p><p>关联容器用自带的快多了</p><p>![image-20221014135744390](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135744390.png)</p><h4 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort()算法"></a>sort()算法</h4><p>关联容器自带排序的</p><p>![image-20221014140156822](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014140156822.png)</p><h4 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search()算法"></a>binary_search()算法</h4><p>调用lower_bound()二分搜寻</p><p>归纳后：</p><p>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>![image-20221014141107968](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014141107968.png)</p><h2 id="仿函数functors"><a href="#仿函数functors" class="headerlink" title="仿函数functors"></a>仿函数functors</h2><p>函数对象，类中重载小括号，STL定义很多仿函数</p><p>![image-20221014143544712](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014143544712.png)</p><h4 id="仿函数可适配的条件"><a href="#仿函数可适配的条件" class="headerlink" title="仿函数可适配的条件"></a>仿函数可适配的条件</h4><p>：需要继承一元和二元仿函数的基类，也就是unary_function或者binary_function其中一个。继承之后，才可回答被仿函数适配器的提问，实参的类型是什么。</p><p>![image-20221014143605807](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014143605807.png)</p><h2 id="适配器Adapters"><a href="#适配器Adapters" class="headerlink" title="适配器Adapters"></a>适配器Adapters</h2><p>改造器，要改造原有的部件的功能，用内含而不是继承的方式包含原有的部件</p><p>存在多种适配器：Contanier Adapters, Functor Adapters, Iterator Adapters</p><p>![image-20221014153946103](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014153946103.png)</p><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>stack,queue内含的deque并且改造函数接口</p><p>![image-20221014153956095](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014153956095.png)</p><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><p>修饰function形成function的样子</p><h4 id="bind2nd-函数和binder2nd函数对象"><a href="#bind2nd-函数和binder2nd函数对象" class="headerlink" title="bind2nd()函数和binder2nd函数对象"></a>bind2nd()函数和binder2nd函数对象</h4><ol><li><p>less<int>()和40被记在binder2nd类的Data中，等之后类内operatpr()调用后再拿出来用；</p></li><li><p>bind2nd()函数返回临时对象binder2nd;</p></li><li><p>适配器操作后，需要询问算法的入参（1或2个参数的类型）和结果（返回值的类型）</p></li><li><p>![image-20221014154005666](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014154005666.png)</p></li></ol><h4 id="新型适配器-，bind来取代原有的"><a href="#新型适配器-，bind来取代原有的" class="headerlink" title="新型适配器 ，bind来取代原有的"></a>新型适配器 ，bind来取代原有的</h4><p>![image-20221014154134036](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014154134036.png)</p><h4 id="not1"><a href="#not1" class="headerlink" title="not1()"></a>not1()</h4><p>一元谓词；</p><p>记录入参，返回<code>!pred</code>，C17已经弃用</p><h4 id="bind-和占位符"><a href="#bind-和占位符" class="headerlink" title="bind()和占位符"></a>bind()和占位符</h4><p>新版STL中取代之前的函数对象和函数</p><ol><li>对于函数，绑定对象，设置占位符以备之后调用函数时作为入参；占位符<code>_1</code>和<code>_2</code>的就是参数的顺序</li><li>还可以改变模板参数，绑定返回类型比如<code>bind&lt;int&gt; (my_divide,10,2)</code>;</li><li>还可以把成员函数，绑定给要做用的对象，比如<code>auto f1=bind(&amp;MyPair::multiply,_1);f1(ten_two);</code></li></ol><p>![image-20221014155526664](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014155526664.png)</p><p><strong>std::bind可以绑定</strong>：</p><ol><li>functions;</li><li>function objects;&#x2F;&#x2F;这种是注释讲了，也就是把方程改为仿函数</li><li>member functions,_1必须是个object地址;&#x2F;&#x2F;比如说<code>auto f1 = bind(&amp;MyPair::multiply,ten_two);</code></li><li>date member，_1必须是某个object地址；&#x2F;&#x2F;比如说<code>auto f1 = bind(&amp;MyPair::b,_1);</code>,调用<code>f1(ten_two)</code>只会输出成员b的数，这个很特别</li></ol><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><h4 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h4><p>![image-20221014162046483](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014162046483.png)</p><h4 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h4><p>不同于赋值assign，重载操作符，使得&#x3D;变为insert操作</p><p>![image-20221014163840295](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014163840295.png)</p><h3 id="X适配器"><a href="#X适配器" class="headerlink" title="X适配器"></a>X适配器</h3><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p>输出迭代器的适配器，直接用于输出;</p><p>实现方式也是用重载算法的操作符operator&#x3D;为&lt;&lt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(std::cout,<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>(),out_it);</span><br></pre></td></tr></table></figure><p>![image-20221015113148564](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015113148564.png)</p><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>输出迭代器的适配器</p><p>实现是重载算法的operator&#x3D;为&gt;&gt;</p><p>没有参数的作为标兵，有参数的绑定输如cin，读当前it指向的值，++往下读；</p><p>![image-20221015114603355](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015114603355.png)</p><p>下面这个连算法的first和last迭代器都改为了iit和eos，但是算法流程框架没变，第三个参数insert(c,c.begin())重载了&#x3D;为insert操作；</p><ul><li>当创建了istream_iterator后，这个类自动实现++也就是立刻read，往下进行。</li></ul><p>![image-20221015114949021](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015114949021.png)</p><h1 id="第四讲-STL其余体系结构"><a href="#第四讲-STL其余体系结构" class="headerlink" title="第四讲 STL其余体系结构"></a>第四讲 STL其余体系结构</h1><h3 id="一个万用的hash-fuction"><a href="#一个万用的hash-fuction" class="headerlink" title="一个万用的hash fuction"></a>一个万用的hash fuction</h3><ol><li>其中…是省略一些参数的写法, <strong>variadic templates</strong>可变化的模板，可以放任意的参数</li><li>每一个分出来seed，计算出，最后当做hashcode，一直到全部拆解完成加上hashcode</li><li>hash_combine()中seed的计算用的是黄金分割</li></ol><p>![image-20221015150133530](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150133530.png)</p><p>用例尝试，作为unordered_set的hashfunction(第二参数)</p><p>![image-20221015150909323](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150909323.png)</p><p>![image-20221015150932418](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150932418.png)</p><h3 id="tuple，用例"><a href="#tuple，用例" class="headerlink" title="tuple，用例"></a>tuple，用例</h3><p>一些数据的组合，相对于pair</p><p>![image-20221015153445595](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015153445595.png)</p><ol><li>创建用括号初始化，也可以用make_tuple创建</li><li>取出成员用get&lt;1&gt;(t1)</li><li>整个tuple可以用于比较，相同成分的tuple比较，不同成分tuple的比较</li><li>整个tuple可以互相赋值，整个tuple可以cout</li><li>可以初始刷为具体的值，然后用tie绑定变量到值</li><li>tuple_size<t1>::value可以得到tuple的成员数；tuple_element&lt;1,t1&gt;::type f1&#x3D;10可以获得指定元素的类型；</li></ol><h4 id="tuple实现"><a href="#tuple实现" class="headerlink" title="tuple实现"></a>tuple实现</h4><p>还是用到<strong>variadic templates</strong>；tuple类继承他自己，递归继承他的尾部，头部作为成员数据，用于声明变量；当为空就结束</p><p>![image-20221015155218423](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015155218423.png)</p><h3 id="type-traits原编程"><a href="#type-traits原编程" class="headerlink" title="type traits原编程"></a>type traits原编程</h3><p>C++ 提供元编程设施，诸如类型特性、编译时有理数算术，以及编译时整数序列。</p><p>利用特化偏特化，判断构造函数、拷贝构造、析构函数等重不重要</p><p>![image-20221015161257834](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161257834.png)</p><p>C++11中定义了很多的元编程，用于各种类型的查询</p><p>![image-20221015161808849](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161808849.png)</p><p>![image-20221015161851035](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161851035.png)</p><h4 id="用traits分析string"><a href="#用traits分析string" class="headerlink" title="用traits分析string"></a>用traits分析string</h4><p>实际上使用string，是调用<code>basic_string&lt;char&gt;</code></p><p>![image-20221015162105748](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015162105748.png)</p><h4 id="traits实现"><a href="#traits实现" class="headerlink" title="traits实现"></a>traits实现</h4><p>基本都是泛化和偏特化实现的</p><p>remove_const和remove_volatile，用特化来拿掉</p><p>_is_void用特化返回void类型，实现</p><p>![image-20221015165340384](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165340384.png)</p><p>is_integral</p><p>![image-20221015165633636](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165633636.png)</p><p>调用编译过程的接口，找不到源代码，grep的工具可以查看</p><p>![image-20221015165652628](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165652628.png)</p><p>![image-20221015170030086](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170030086.png)</p><h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout的类型为_IO_ostream_withassign，继承自ostream，其中重载了和对不同入参的&lt;&lt;操作、</p><p>![image-20221015170847219](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170847219.png)</p><p>![image-20221015170907392](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170907392.png)</p><h3 id="moveable元素（移动构造）"><a href="#moveable元素（移动构造）" class="headerlink" title="moveable元素（移动构造）"></a>moveable元素（移动构造）</h3><h4 id="对于vector速度效能的影响"><a href="#对于vector速度效能的影响" class="headerlink" title="对于vector速度效能的影响"></a>对于vector速度效能的影响</h4><p>加入move功能的容器，速度上效率会高</p><p>其中MCtor是有move功能的构造函数。CCtor是没有move功能的构造函数。</p><p>其中std::move()是有move的拷贝构造。</p><h4 id="对list的影响"><a href="#对list的影响" class="headerlink" title="对list的影响"></a>对list的影响</h4><p>list是逐个创建，时间效率差距不大；deque其实也影响不大；</p><p>但是除了创建，其他操作可能也有影响</p><h4 id="一个moveable类"><a href="#一个moveable类" class="headerlink" title="一个moveable类"></a>一个moveable类</h4><p>是一种浅拷贝，并且在析构中判断是否要delete指针</p><p>![image-20221015172804821](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015172804821.png)</p><p>![image-20221015172812092](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015172812092.png)</p>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Modelica - Modelica语言学习</title>
      <link href="/2023/11/06/modelica%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/06/modelica%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h2><p>1.新建package-》新建modelica类</p><p>2.找组件modelica–&gt;mechanics–&gt;translational–&gt;components等；找信号源blocks–&gt;sources等</p><p>3.模件进行连接</p><p>4.元件设置参数</p><p>5.仿真-仿真设置</p><h2 id="二、模型类化"><a href="#二、模型类化" class="headerlink" title="二、模型类化"></a>二、模型类化</h2><p>打开类看单个构件的建模语言</p><p>新建类–&gt;扩展 （选库中类的)–&gt;在扩展类中写方程–&gt;调用到modelica类中使用</p><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote><p><strong>变量声明：</strong></p><ol><li>类型：Real，Integer, Boolean,String,enumeration</li><li>前缀：input, output, parameter;</li><li>可见性：public， protected;</li></ol><p><strong>注释：</strong><br> 1.单行；多行；<br> 2.引号注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real foo &quot; A special comment&quot;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real x[3,3]=&#123;1,2,3;4,5,6;4,5,6&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>标注：</strong>annotation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equation</span><br><span class="line">der(x) = 1-x ”Drives value of x toward 1.0”;</span><br><span class="line">annotation(experiment(StartTime=0,StopTime=8));//定义模型仿真开始和结束的时间</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>标注中包含的信息与模型的属性没有直接联系，只是提供进行模拟仿真的条件</p><ol><li><p>对变量、语句（方程）、继承：紧跟在一个声明的后面，并且在标示符 ; 的前面 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real length ”Rod length” annotation(...);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li><li><p>模型标注数据直接在模型自身定义的时候声明</p></li></ol><ul><li><p>标注中即可以包含对变量的赋值，也可以包含对一些内部变量的修改</p></li><li><p>标注就是为了方便模型开发者将任意数据添加到模型中而设计的，</p></li><li><p>可以同时多个标注，</p></li><li><p>只要标注的名称不同，我们就可以一次加入多个。</p><p>​：在加入零件号时，最好要将其放一个特别 的变量内。这个变量最好应该和你的公司或者应用情况相关，而且足够特别 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotation(XogenyIndustries(PartNumber=”FF78-E4B879”),</span><br><span class="line">experiment(StartTime=0,StopTime=8));</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>变量 XogenyIndustries 可以为某个特定组织或目的创建出一个“命名空间”</p></li><li><p>几种标准标注：Documentation；experiment；Evaluate；HideResult（P37）</p></li></ul><p><strong>逻辑运算符：</strong><br> and , or, not,&lt;,&gt;,&lt;&gt;,&lt;&#x3D;, &gt;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if &lt;condition&gt; then</span><br><span class="line">...</span><br><span class="line">elseif &lt;condition&gt; then</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>循环：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in1:10 loop</span><br><span class="line">  ...</span><br><span class="line">end for;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h2 id="四、函数语法"><a href="#四、函数语法" class="headerlink" title="四、函数语法"></a><strong>四、函数语法</strong></h2><blockquote><p><strong>分区标志符</strong></p><p>​    函数内容：alogrithm<br>​     局部变量：protected</p><p><strong>参数默认值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input Real tol=le-5 &quot;Input with default value&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>多个输出变量:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line">  function demo_fuction</span><br><span class="line">    input Real in1&quot;The first input demo function&quot;;</span><br><span class="line">    input Real in2&quot;The second argument&quot;;</span><br><span class="line">    output Real out1&quot;The first output for demo&quot;;</span><br><span class="line">    output Real out2&quot;The second output for demo&quot;;</span><br><span class="line">    </span><br><span class="line">    /*(out1,out2)=demo(in1,in2)*/</span><br><span class="line">  protected//局部变量</span><br><span class="line">    Real p1;</span><br><span class="line">  algorithm</span><br><span class="line">       p1:=in1-in2;</span><br><span class="line">     out1:=in1+in2;</span><br><span class="line">     </span><br><span class="line">     out2:=in1*in2;</span><br><span class="line">     </span><br><span class="line">     p1:=in1-in2;</span><br><span class="line">     </span><br><span class="line">  end demo_fuction;</span><br><span class="line">end demo;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>调用:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(out1,out2)=Fuctions.demo_fuction(in1=10,in2=20);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><p>函数测试：右键调用inputs，结果检验；</p><blockquote><p>例题：将致密矩阵M转化为存储格式的稀疏矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function  coo</span><br><span class="line">  input Real M[:,:] &quot;Input dense matrix&quot;;</span><br><span class="line">  input Real tol = le-5 &quot;M[i,j]&lt;tol is considered empty. Tolerance value&quot;;</span><br><span class="line">  </span><br><span class="line">  output Integer rows[:] &quot;Row indices&quot;;</span><br><span class="line">  output Integer cols[:] &quot;Colum indices&quot;;</span><br><span class="line">  output Real data[:] &quot;values&quot;;</span><br><span class="line">protected</span><br><span class="line">  Integer r_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Integer c_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Real d_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Integer counter;</span><br><span class="line">algorithm</span><br><span class="line">  counter := 0;</span><br><span class="line">  for i in 1:size(M, 1) loop</span><br><span class="line">    for j in 1:size(M, 2) loop</span><br><span class="line">      if abs(M[i, j]) &gt; tol then</span><br><span class="line">        counter := counter + 1;</span><br><span class="line">        r_temp[counter] := i;</span><br><span class="line">        c_temp[counter] := j;</span><br><span class="line">        d_temp[counter] := M[i, j];</span><br><span class="line">      end if;</span><br><span class="line">    end for;</span><br><span class="line">  end for;</span><br><span class="line">  rows := r_temp[1:counter];</span><br><span class="line">  cols := c_temp[1:counter];</span><br><span class="line">  date := d_temp[1:counter];</span><br><span class="line">end coo;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h2 id="五、等式语法"><a href="#五、等式语法" class="headerlink" title="五、等式语法"></a>五、等式语法</h2><p>modelica各元素的组合关系</p><p>变量-表达式-等式组件-系统</p><blockquote><p>语法不同于其他语言，掌握核心</p><p>核心：通过<strong>等式</strong>建立起变量之间的关系，并使<strong>未知变量数量与等式变量一致</strong></p></blockquote><h3 id="model-x2F-block结构"><a href="#model-x2F-block结构" class="headerlink" title="model&#x2F;block结构"></a><strong>model&#x2F;block结构</strong></h3><blockquote><p>model ModeName”模型描述（非必要）”<br>  &#x2F;&#x2F;声明状态变量，参数，输入&#x2F;输出变量等<br> initial equation<br>     &#x2F;&#x2F;初始化等式<br> equation<br>     &#x2F;<em>构建已知未知量之间的关系的等式</em>&#x2F;<br> end ModeName;</p></blockquote><h3 id="等式语法-基本等式"><a href="#等式语法-基本等式" class="headerlink" title="等式语法-基本等式"></a>等式语法-基本等式</h3><p>构建已知与未知或未知与未知量之间的关系</p><blockquote><p>格式： &lt;表达式1&gt;&#x3D;&lt;表达式2&gt;</p></blockquote><p>&#x3D;不表示赋值，无因果关系</p><h3 id="条件等式"><a href="#条件等式" class="headerlink" title="条件等式"></a>条件等式</h3><p>表达形式1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x= if a&gt;b then sin(time) else cos(time);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>表达形式2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if a&gt;b then</span><br><span class="line">        x=sin(time);</span><br><span class="line">else</span><br><span class="line">        x=cos(time);</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1.方程的平衡形式：<br> 核心是要保持等式数量不变，等式有if一定有else；<br> 变量的数量必须等于方程的数量，而且，在模拟的过程中方程的数量必须是固定的</p><p> 2.不平衡形式：<br> ​​​​​​​if 和 else 两侧的方程数量是不同的<br> 仅当 ：模拟过程中条件表达式的值不能改变 ；方程的数量在模拟过程中不能改变；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">parameter Boolean steady_state;</span><br><span class="line">initial equation</span><br><span class="line">if steady_state then</span><br><span class="line">der(x) = 0;</span><br><span class="line">der(y) = 0;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果布尔参数 steady_state（稳定状态）为真，那么初始方程是有效的。但是如果参数为假， 它们就无效。这里的条件表达式具有参数级别的可变性是因为，表达式仅仅包含一个变量，而这个变量 是个参数。</p></blockquote><h3 id="初始值等式"><a href="#初始值等式" class="headerlink" title="初始值等式"></a><strong>初始值等式</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initial equation </span><br><span class="line">        x=3;</span><br><span class="line">        der(y)=0;</span><br><span class="line">        z=p0;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="注意：变量定义域；检验等式平衡性"><a href="#注意：变量定义域；检验等式平衡性" class="headerlink" title="注意：变量定义域；检验等式平衡性"></a>注意：变量定义域；检验等式平衡性</h3><h1 id="五、MSL"><a href="#五、MSL" class="headerlink" title="五、MSL"></a>五、MSL</h1><blockquote><p>Modelica.Blocks</p><ul><li>包含强因果关系的模型</li><li>一般包含一个或多个input和output连接器</li><li>一般用于信号生成及信号处理<br> 多用于辅助物理模型，而不是建构</li></ul><p>Modelica.Blocks.Sources<br> 信号源输出</p></blockquote><blockquote><p>差值模块<br> Modelica.Blocks.Tables.CombiTable1Ds一维单变量差值</p><ul><li>用作信号源</li><li>数据模型</li></ul></blockquote><hr><h1 id="一、基本方程"><a href="#一、基本方程" class="headerlink" title="一、基本方程"></a>一、基本方程</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real T_inf(unit=”K”)=298.15 ”Ambient temperature”;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 1.关键字parameter 表明变量的 值是先验已知的（即仿真开始之前）<br> 2.每个变量的声明部分都包含与变量相关联的物理单元文本 (unit&#x3D;”…”): ”1” 代表值没有物理 单位,。另一方面””（默认没有给定值）表明物理单位不确定。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">model NewtonCoolingWithTypes ”Cooling example with physical types”</span><br><span class="line">// Types</span><br><span class="line">type Temperature=Real(unit=”K”, min=0);</span><br><span class="line">type ConvectionCoefficient=Real(unit=”W/(m2.K)”, min=0);</span><br><span class="line">type Area=Real(unit=”m2”, min=0);</span><br><span class="line">type Mass=Real(unit=”kg”, min=0);</span><br><span class="line">type SpecificHeat=Real(unit=”J/(K.kg)”, min=0);</span><br><span class="line">// Parameters</span><br><span class="line">parameter Temperature T_inf=298.15 ”Ambient temperature”;</span><br><span class="line">parameter Temperature T0=363.15 ”Initial temperature”;</span><br><span class="line">parameter ConvectionCoefficient h=0.7 ”Convective cooling coefficient”;</span><br><span class="line">parameter Area A=1.0 ”Surface area”;</span><br><span class="line">parameter Mass m=0.1 ”Mass of thermal capacitance”;</span><br><span class="line">parameter SpecificHeat c_p=1.2 ”Specific heat”;</span><br><span class="line">// Variables</span><br><span class="line">Temperature T ”Temperature”;</span><br><span class="line">initial equation</span><br><span class="line">T = T0 ”Specify initial value for T”;</span><br><span class="line">equation</span><br><span class="line">m*c_p*der(T) = h*A*(T_inf-T) ”Newton’s law of cooling”;</span><br><span class="line">end NewtonCoolingWithTypes;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>一旦定义了一个物理类型比如 Temperature，我们可以使用它为多 个变量（例如 T、T_inf 和 T0）进行声明</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real x(start=5, fixed=true);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li>start 属性的主要目的是（正如在初始化 ( 31) 那节里广泛讨 论过的）为状态变量提供“备用”的初始状态。</li><li>start 属性的也可以用于变量，是迭代变量时的初始假想值。</li><li>最后，如果一个 parameter 没有明确指定的值，那么 start 属性的值可以作为 parameter 的默认值。</li></ol><p>在声明变量的 start 属性时直接指 定其初始条件；变量的 fixed 属性被 用来通知编译器 start 属性必须作为初始条件来使用</p><p>start 属性的其中一个作用是提供初始化猜想值：因为该变量必须通过系统的非线性方程组来 求解。这也就意味着，我们要对变量 x 和 y 的 start 属性值进行指定，以尽量“避开”系统的零解（或 者说至少接近我们期望的非零解）</p></blockquote><blockquote><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model QuiescentModelWithInheritance ”Steady state model with inheritance”</span><br><span class="line">extends ClassicModel;</span><br><span class="line">initial equation</span><br><span class="line">der(x) = 0;</span><br><span class="line">der(y) = 0;</span><br><span class="line">end QuiescentModelWithInheritance;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>从 ClassicModel 模型中复制（或“继承”） 其包含的所有内容，而无需重复定义。因此，除了新加入的初始化方程外，QuiescentModelWithInheritance 模型和 ClassicModel 模型其他部分完全一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model QuiescentModelWithModifications ”Steady state model with modifications”</span><br><span class="line">extends QuiescentModelWithInheritance(gamma=0.3, delta=0.01);</span><br><span class="line">end QuiescentModelWithModifications;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>允许对模型加入相应的“修改语句”</p><ul><li>按照惯例，extends 子句通常列在模型定义最上方，在任何变量之前</li></ul></blockquote><blockquote><h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><p>type NewTypeName &#x3D; BaseTypeName(&#x2F;* attributes to be modified *&#x2F;);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Temperature = Real(unit=”K”); // Could be a temperature difference</span><br><span class="line">type AbsoluteTemperature = Temperature(min=0); // Must be positive</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>BaseTypeName（基本类型名称）一般为内置类型（比如 Real（实数））。但是它也可以是另外一种派生 类型。这意味着多层次的限定也是支持的。</p></blockquote><blockquote><h2 id="Record-类型"><a href="#Record-类型" class="headerlink" title="Record 类型"></a>Record 类型</h2><p>record 类型可以有自己的变量，但是不允许包含方程。record 类型主要用于数据的分组</p><p>定义record；创建record：记录构造函数输入record类型内部定义匹配的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">record Vector ”A vector in 3D space”</span><br><span class="line">Real x;</span><br><span class="line">Real y;</span><br><span class="line">Real z;</span><br><span class="line">end Vector;</span><br><span class="line"></span><br><span class="line">parameter Vector v = Vector(x=1.0, y=2.0, z=0.0);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h1 id="二、离散行为"><a href="#二、离散行为" class="headerlink" title="二、离散行为"></a>二、离散行为</h1><p>事件是任何在系统内触发了某种不连续性的东西：<br> “时间事件”：发生在某个特定时间的事件是最简单的一类事件；<br> “状态事件”：等到某信号越过特定阈值</p><p>time 是一个内置在所有 Modelica 模型内的变量</p><blockquote><p> T_inf &#x3D; 298.15 - (if time&lt;0.5 then 0 else 20*(time-0.5));<br> T_inf &#x3D; 298.15 - max(0, 20*(time-0.5));&#x2F;&#x2F;用max表示环境温度的变化</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">model NewtonCooling</span><br><span class="line">//Types</span><br><span class="line">type Temperature=Real(unit=&quot;K&quot;,min=0);</span><br><span class="line">type ConvectionCoefficient=Real(unit=&quot;W/(m2.k)&quot;,min=0);</span><br><span class="line">type Area=Real(unit=&quot;m2&quot;,min=0);</span><br><span class="line">type Mass=Real(unit=&quot;kg&quot;,min=0);</span><br><span class="line">type SpecificHeat=Real(unit=&quot;J/(K.kg)&quot;,min=0);</span><br><span class="line"></span><br><span class="line">//Parameters</span><br><span class="line">parameter Temperature T0=363.15&quot;Initial temperature&quot;;</span><br><span class="line">parameter ConvectionCoefficient h=0.7&quot;Convective cooling coefficient&quot;;</span><br><span class="line">parameter Area A=1.0&quot;Surface area&quot;;</span><br><span class="line">parameter Mass m=0.1&quot;Mass of thermal capacitance&quot;;</span><br><span class="line">parameter SpecificHeat c_p=1.2&quot;Specific heat&quot;;</span><br><span class="line"></span><br><span class="line">//Variables</span><br><span class="line">Temperature T_inf&quot;Ambient temperature&quot;;</span><br><span class="line">Temperature T &quot;Temperature&quot;;</span><br><span class="line"></span><br><span class="line">initial equation</span><br><span class="line">  T=T0&quot;Specify initial value for T&quot;;</span><br><span class="line">equation</span><br><span class="line">  if time&lt;=0.5 then</span><br><span class="line">    T_inf=298.15&quot;Constant temperature when time &lt;=0.5&quot;;</span><br><span class="line">  else</span><br><span class="line">    T_inf=298.15-20*(time-0.5)&quot;Otherwise,increasing&quot;;</span><br><span class="line">  end if;</span><br><span class="line">  m*c_p*der(T)=h*A*(T_inf-T)&quot;Newton&#x27;s law of cooling&quot;;  </span><br><span class="line"></span><br><span class="line">end NewtonCooling;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>问题：0x000002错误</p><p>另：可以用初始方程，方程从平衡态开始</p><blockquote><p>if表达式代替if语句</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/06/hello-world/"/>
      <url>/2023/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS - 计算机操作系统复习思维导图</title>
      <link href="/2023/11/06/ComputerSysMind/"/>
      <url>/2023/11/06/ComputerSysMind/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统-基础-思维导图"><a href="#操作系统-基础-思维导图" class="headerlink" title="操作系统-基础-思维导图"></a>操作系统-基础-思维导图</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys1.png"></p><h2 id="计组复习"><a href="#计组复习" class="headerlink" title="计组复习"></a>计组复习</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys2.png"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys3.png"></p><h2 id="进程线程管理"><a href="#进程线程管理" class="headerlink" title="进程线程管理"></a>进程线程管理</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys4.png"></p><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys5.png"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys6.png"></p><h2 id="文件管理-Linux"><a href="#文件管理-Linux" class="headerlink" title="文件管理-Linux"></a>文件管理-Linux</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys7.png"></p><h2 id="IO设备管理"><a href="#IO设备管理" class="headerlink" title="IO设备管理"></a>IO设备管理</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys8.png"></p><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网 - 计算机网络复习思维导图</title>
      <link href="/2023/11/06/ComputerNetMind/"/>
      <url>/2023/11/06/ComputerNetMind/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="计算机网络-中间三层协议-思维导图"><a href="#计算机网络-中间三层协议-思维导图" class="headerlink" title="计算机网络-中间三层协议-思维导图"></a>计算机网络-中间三层协议-思维导图</h1><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_0.png"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_1.png"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_2.png"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_3.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_4.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>计算机网络第七版- 谢希仁</li><li><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&vd_source=e249eb5e70a068ab71d1537db21d292b">https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e249eb5e70a068ab71d1537db21d292b</a></li><li><a href="https://xiaolincoding.com/network/5_learn/learn_network.html">https://xiaolincoding.com/network/5_learn/learn_network.html</a></li><li>网络是怎样连接的 - 户根勤</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
