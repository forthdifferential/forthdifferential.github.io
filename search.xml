<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式 - GFS论文阅读</title>
      <link href="/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2023/11/21/GFS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>①<strong>Consistency 一致性：</strong>所以节点访问同一份最新的数据副本。</p><p>②<strong>Availability 可用性：</strong>所有读写请求在一定时间内得到<strong>非错</strong>响应，不会一直等待（但不能保证数据是最新的数据）。</p><p>③<strong>Partition tolerance 分区容忍性：</strong>在网络分区的情况下，被分隔的节点仍然能够正常对外服务</p><p>对于一个分布式系统来说，三者只能取其二。</p><p>考虑对于分布式环境，P一定是存在的，没有网络分区和网络波动情况下，正常CAP，当出现网络分区的时候，那么一致性和可用性就要抛弃一个。</p><p>PA：存在网络分区，那么网络中的节点之间就有可能数据不一致；比如往节点A中写入数据，B节点由于网络原因没有同步数据过去，如果此时往B节点读取数据是不能读到数据的，所以在存在网络分区的情况下，这个时候如果系统可用，那么数据是不可能保持一致的。</p><p>PC：两个节点网络隔离了，想要保证数据一致性只能等待网络恢复，将数据同步，才能读取到数据；也就是说如果想要保证数据强一致性，那么在等待网络恢复的过程中，是不能对外提供服务的，这个时候系统就不可用。</p><h4 id="高容错的实现难点："><a href="#高容错的实现难点：" class="headerlink" title="高容错的实现难点："></a>高容错的实现难点：</h4><ol><li>高性能的要求 导致需要 <strong>跨机器对数据分片</strong></li><li>大量计算机  导致必然 <strong>会有很多崩溃</strong></li><li>容错解决奔溃情况 采用的机制是 <strong>副本</strong>；副本需要实施更新，保持副本一致；一致性高 必然导致 <strong>性能开销</strong>。</li></ol><h4 id="一致性实现的难点-："><a href="#一致性实现的难点-：" class="headerlink" title="一致性实现的难点 ："></a>一致性实现的难点 ：</h4><ol><li>并发性，保证线程安全，可以通过之后的分布式锁等机制解决</li><li>故障和失败案例 ：为了容错会用复制，但是不成熟的复制会导致读者在不做修改的情况下读到两次不同数据。</li></ol><h3 id="GFS简介"><a href="#GFS简介" class="headerlink" title="GFS简介"></a>GFS简介</h3><p> GFS旨在保持高性能，且有复制、容错机制，但很难保持一致性，现在谷歌已经不用了； 在论文中可以看到mapper从GFS系统(上千个磁盘)能够以超过10000MB&#x2F;s的速度读取数据。论文发表时，当时单个磁盘的读取速度大概是30MB&#x2F;s，一般在几十MB&#x2F;s左右。</p><p>GFS的几个主要特征：</p><ul><li>Big：large data set，巨大的数据集</li><li>Fast：automatic sharding，自动分片到多个磁盘</li><li>Gloal：all apps see same files，所有应用程序从GFS读取数据时看到相同的文件（一致性）</li><li>Fault tolerance：automic，尽可能自动地采取一些容错恢复操作</li></ul><p>GFS主要包含三种节点:</p><p>• GFS client：维持专用接口，与应用交互。<br>• GFS master：维持元数据，统一管理chunk位置与租约。<br>• GFS chunkserver：存储数据</p><p><img src="/imgs/$%7Bfiilename%7D/GFS/image-20230411161308484.png" alt="image-20230411161308484"></p><h3 id="GFS存储设计"><a href="#GFS存储设计" class="headerlink" title="GFS存储设计"></a>GFS存储设计</h3><p>考虑到文件可能非常大，并且大小不均。GFS没有选择直接以文件为单位进行存储，而是把文件分为一个个chunk来存储。GFS把每个<strong>chunk</strong>设为64MB, 这个单位是比较大的</p><p>chunk在chunkserver中的分布:</p><img src="/imgs/$%7Bfiilename%7D/GFS/image-20231121185821822.png" alt="image-20231121185821822" style="zoom:80%;" /><h3 id="GFS的Master的工作"><a href="#GFS的Master的工作" class="headerlink" title="GFS的Master的工作"></a>GFS的Master的工作</h3><ul><li><p>维护文件名到块句柄数组的映射(file name &#x3D;&gt; chunk handles)  <strong>filename -&gt; chunk handles -&gt; chunk server \  version</strong></p><p>这些信息大多数存放在内存中，所以Master可以快速响应客户端Client</p></li><li><p>维护每个块句柄(chunk handle)的版本(version)</p></li><li><p>维护块存储服务器列表(list of chunk servers)</p><ul><li>主服务器(primary)<ul><li>Master还需维护每一个主服务器(primary)的<strong>租赁时间(lease time)</strong></li></ul></li><li>次要服务器(secondaries)<ul><li>典型配置，即将chunk存储到3台服务器上</li></ul></li></ul></li><li><p>log+check point：通过日志和检查点机制维护文件系统。所有变更操作会先在log中记录，后续才响应Client。这样即使Master崩溃&#x2F;故障，重启时也能通过log恢复状态。master会定期创建自己状态的检查点，落到持久性存储上，重启&#x2F;恢复状态时只需重放log中最后一个check point检查点之后的所有操作，所以恢复也很快。</p></li></ul><p> 这里需要思考的是，哪些数据需要放到稳定的存储中(比如磁盘)？</p><ul><li><p>比如file name &#x3D;&gt; chunk hanles的映射，平时已经在内存中存储了，还有必要存在稳定的存储中吗？</p><p>需要，否则崩溃后恢复时，内存数据丢失，master无法索引某个具体的文件，相当于丢失了文件。</p></li><li><p>chunk handle 到 存放chunk的服务器列表，这一层映射关系，master需要稳定存储吗？</p><p>不需要，master重启时会要求其他存储chunk数据的服务器说明自己维护的chunk handles数据。这里master只需要内存中维护即可。同样的，主服务器(primary)、次要服务器(secondaries)、主服务器(primary)的租赁时间(lease time)也都只需要在内存中即可。</p></li><li><p>chunk handle的version版本号信息呢，master需要稳定存储吗？</p><p>需要。否则master崩溃重启时，master无法区分哪些chunk server存储的chunk最新的。比如可能有服务器存储的chunk version是14，由于网络问题，该服务器还没有拿到最新version 15的数据，master必须能够区分哪些server有最新version的chunk。</p></li></ul><h3 id="GFS数据读取流程"><a href="#GFS数据读取流程" class="headerlink" title="GFS数据读取流程"></a>GFS数据读取流程</h3><p>GFS通过Master管理文件系统的元数据等信息，其他Client只能往GFS写入或读取数据。</p><p>应用并发的通过GFS Client读取数据时，单个读取的大致流程如下：</p><ol><li>Client向Master发起读数据请求</li><li>Master查询需要读取的数据对应的目录等信息，汇总文件块访问句柄、这些文件块所在的服务器节点信息给Client（大文件通常被拆分成多个块Chunk存放到不同服务器上，单个Chunk很大， 这里是64MB）</li><li>Client得知需要读取的Chunk的信息后，直接和拥有这些Chunk的服务器网络通信传输Chunks</li></ol><h3 id="GFS文件读取"><a href="#GFS文件读取" class="headerlink" title="GFS文件读取"></a>GFS文件读取</h3><ol><li>Client向Master发请求，要求读取X文件的Y偏移量的数据</li><li>Master回复Client，X文件Y偏移量相关的块句柄、块服务器列表、版本号(chunk handle, list of chunk servers, version)</li><li>Client 缓存cache块服务器列表(list of chunk servers)<br>理解： 只有一个Master，所以需要尽量减少Client和Server之间的通信次数，缓冲减少交互</li><li>Client从最近的服务器请求chunk数据(reads from closest servers)<br>理解： 因为这样在宛如拓扑结构的网络中可以最大限度地减少网络流量(mininize network traffic)，提高整体系统的吞吐量</li><li>被Client访问的chunk server检查version，version正确则返回数据<br>理解： 为了尽量避免客户端读到过时数据的情况。</li></ol><h3 id="GFS文件写入"><a href="#GFS文件写入" class="headerlink" title="GFS文件写入"></a>GFS文件写入</h3><p> 主要是关注文件写入的append操作，在mapreduce 中，reduce处理后计算结果需要append到file中</p><img src="/imgs/$%7Bfiilename%7D/GFS/image-20230411165609018.png" alt="image-20230411165609018" style="zoom: 50%;" /><ol><li><p>Client向Master发出请求，查询应该往哪里写入filename对应的文件。</p></li><li><p>Master查询filename到chunk handle映射关系的表，找到需要修改的chunk handle后，再查询chunk handle到<strong>chunk server数组映射关系的表</strong>，以list of chunk servers(主副本primary、secondaries、version信息)<strong>也就是得到所有该文件的chunkserver并且附加上版本号</strong>作为Client请求的响应结果</p><p>接下去有两种情况，已有primary和没有primary(假设这是系统刚启动后不久，还没有primary)</p><ul><li><p>有primary，（<strong>primary：主文件副本，也就是正常情况下对外读写的文件；secondaries： 其他副本</strong>）</p><p>继续后续流程</p></li><li><p>无primary</p><ul><li><p>master在chunk servers中选出一个作为primary，其余的chunk server作为secondaries</p><p>(暂时不考虑选出的细节和步骤)</p><ul><li>master会增加version（每次有<strong>新的primary</strong>时，都需要考虑时进入了一个new epoch，所以需要<strong>维护新的version</strong>），然后向primary和secondaries发送新的version，并且会发给primary有效期限的租约lease。这里primary和secondaries需要将version存储到磁盘，否则重启后内存数据丢失，无法让master信服自己拥有最新version的数据(同理Master也是将version存储在磁盘中)。</li></ul></li></ul></li></ul></li><li><p>Client发送数据到想写入的chunk servers(primary和secondaries)，有趣的是，<strong>这里Client只需访问最近的secondary，而这个被访问的secondary会将数据也转发到列表中的下一个chunk server</strong>，<strong>此时数据还不会真正被chunk severs存储</strong>。（即上图中间黑色粗箭头，secondary收到数据后，马上将数据推送到其他本次需要写的chunk server）<br>理解： 这么做提高了Client的吞吐量，避免Client本身需要消耗大量网络接口资源往primary和多个secondaries都发送数据。</p></li><li><p>数据传递完毕后，Client向primary发送一个message，表明本次为append操作。</p><p>primary此时需要做几件事：</p><ol><li>primary此时会检查version，如果version不匹配，那么Client的操作会被拒绝</li><li>primary检查<strong>lease是否还有效</strong>，如果自己的lease无效了，则不再接受任何mutation operations（因为租约无效时，外部可能已经存在一个新的primary了）</li><li>如果version、lease都有效，那么primary会选择一个offset用于写入</li><li>primary将前面接收到的数据写入稳定存储中</li></ol></li><li><p>primary发送消息到secondaries，表示需要将之前接收的数据写入指定的offset（更新其他副本）</p></li><li><p>secondaries写入数据到primary指定的offset中，并回应primary已完成数据写入</p></li><li><p>primary回应Client，你想append追加的数据已完成写入</p></li></ol><h3 id="GFS一致性"><a href="#GFS一致性" class="headerlink" title="GFS一致性"></a>GFS一致性</h3><ol><li><p>appen一次之后，read返回什么结果</p><p>例如： M（maseter），P（primary），S（Secondary）</p><p>某时刻Mping不到P了，那咋办？ </p><p>假设选出新P，那可能旧P还在和CLient交互，两个P同时存在叫做脑裂，会出现严重问题，比如数据写入顺序混乱等问题，严重的脑裂问题可能会导致系统最后出现两个Master。</p><p>所以依照M知道的旧P的lease，在旧Please期限结束之前，不会选出新P，也就是M和P无法通信，但是P还可能和其他Client通信</p></li><li><p>强一致性的保证<br>保证 所有S都成功写入或者都不写入</p></li></ol><p>GFS是为了运行mapreduce而设计的</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式 - MapReduce论文阅读</title>
      <link href="/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2023/11/21/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="问题理解："><a href="#问题理解：" class="headerlink" title="问题理解："></a>问题理解：</h3><p>过去，处理大量数据的计算时，通常依赖于<strong>一台</strong>“<strong>超级电脑</strong>”，但机器计算能力仍然是有限的，这种方式无法解决无限大规模的数据。</p><p>MapReduce作为一种分布式并行计算的框架，它主要从<strong>分治的角度出发</strong>，能够高容错地组织<strong>许多一般性能的机器</strong>，将大规模问题进行拆解，在并行计算后再做整合，解决了大规模运算的问题。</p><p>现实生活中通常应用于一些分治问题：</p><ul><li>词频统计</li><li>网页抓取</li><li>日志处理</li><li>查询请求汇总</li></ul><blockquote><p> Hadoop架构中，包含三大组件:分布式文件系统HDFS, 分布式计算组件MapReduce， 资源调度管理系统YARN</p></blockquote><h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><p>输入一组kv，生成一组kv。</p><p>MAP函数获取一个输入，并且生成一组中间的KV，</p><p>MapReduce库把与同一中间键i相关联的所有中间值组合在一起，通过迭代器传递给Reduce函数。</p><p>Reduce函数接受中间键i和键对应的一组值，把值合在一起，形成一个key更小的值集。一般每次只生成0或1个输出值。</p><img src="/imgs/$%7Bfiilename%7D/MapReduce/image-20230329113648794.png" alt="image-20230329113648794" style="zoom:80%;" /><h3 id="M-R工作基本步骤："><a href="#M-R工作基本步骤：" class="headerlink" title="M-R工作基本步骤："></a>M-R工作基本步骤：</h3><ol><li>输入文件，MapReduce库分割成M个片段，每个片段16-64MB，然后在一群机器上启动程序的副本</li><li>其中一个副本是Master，其余是workers，总共有M个map任务和R个reduce任务需要分配。由主进程挑选空闲的workers分配一项任务。</li><li>分配到map任务的worker读取内容（被拆分好的一部分），从输出数据中解析出KV，传递给Map函数，然后把生成的中间KV存在内存</li><li>定期写入本地磁盘，并分区R个区，然后传地址给master。</li><li>master通知reduce任务的workers这些位置，然后用RPC读取map的workers这些数据（直接从map workers传到reduce workers）。当reduceWorker读完所有中间数据后，按照键排序，以便将所有相同键的项组合。（排序是必须的，如果中间数据量大到内存不够了，用外部排序）</li><li>reduceWorker遍历已排序的中间数据，按照键值和对应的一组中间值传递给Reduce函数。reduce函数的结果加到此分区的输出文件中</li><li>所有map和reduce任务完成后，master唤醒user程序。这时user程序中的MapReduce来return结果，一般所有分区输出文件同时输出传递给另一个MapReduce函数，不需要合并为一个文件。</li></ol><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>每个map和reduce任务，保留存储状态（空闲，进行，完成）和工作计算机的标识（非空闲）</p><p>master是map任务中间文件位置的接受管道，master存储R个中间文件的位置和大小，map任务完成后，master接受信息更新，并且递增地传给正在进行的reduceWorkers</p><h3 id="容错设计："><a href="#容错设计：" class="headerlink" title="容错设计："></a>容错设计：</h3><h4 id="workers-failure"><a href="#workers-failure" class="headerlink" title="workers failure"></a>workers failure</h4><p>master定期ping（心跳机制）每个worker如果有worker没有响应 或者 工作线程故障 ，就标记为失败，其上的任务重置为初始空闲状态，可以放在其他works上调度。</p><ol><li><p>对于map任务故障，直接全部重新执行，因为输出存储在故障计算机上，无法访问。</p></li><li><p>对于reduce任务，只要接下来换机器执行，因为输出存储在全局文件系统中。</p></li></ol><p>A执行map任务的时候坏了转给了B，那么对应执行reduce的workers需要重新执行，从B读取数据</p><h4 id="master-failure"><a href="#master-failure" class="headerlink" title="master failure"></a>master failure</h4><ol><li><p>写入master数据结构的检查点，master终止之后，可以从上一个检查点状态重新启动新的副本。</p></li><li><p>维护一个检查点，当宕机后从检查点恢复</p></li></ol><h4 id="避免语义冲突"><a href="#避免语义冲突" class="headerlink" title="避免语义冲突"></a>避免语义冲突</h4><p>无论是Map还是Reduce，worker输出都会先将结果暂时写在一个私有的临时文件中，等到任务完成后，再重命名该临时文件。目的是防止多个任务写在同一个文件中，导致内容语义冲突。依靠 <strong>文件系统提供的原子重命名操作</strong> 来确保最终文件的系统状态仅包含执行一次任务所产生的数据。（这一点6.824Lab并未体现，论文里有说明）</p><p>举例子：M的一次输出可能被R1读取并正在执行，M的另一次输出可能被R2读取了</p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>如果任务失败，将在输入数据的副本附近调度map任务，大多数是本地读取的，不会消耗带宽。</p><h4 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h4><p>任务数量M和R远大于计算机数量（当然有个上限），调整动态负载平衡。 R受到用户限制，一般是机器数量的小倍数</p><h4 id="任务备份"><a href="#任务备份" class="headerlink" title="任务备份"></a>任务备份</h4><p>问题：有些worker机器运行落后，最后几个任务要一直等着。</p><p>解决方案： 当一个MapReduce系统快完成的时候，主线程调度正在进行的任务进行备份执行(其余空闲的worker进行重复任务），只要主执行或者备份执行有完成的，那这个任务就被标记完成。这样加了少量计算负担，能提升时间较多</p><h3 id="优化拓展"><a href="#优化拓展" class="headerlink" title="优化拓展"></a>优化拓展</h3><h4 id="分区函数"><a href="#分区函数" class="headerlink" title="分区函数"></a>分区函数</h4><p>用户指定M和R，使用分区函数对数据进行分区。要求平衡的分区，有时候希望相同的输出文件结束。。。</p><h4 id="中间结果序列化"><a href="#中间结果序列化" class="headerlink" title="中间结果序列化"></a>中间结果序列化</h4><p>保证给定分区中，中间KV按照K升序处理，方便输出文件被查找，以减轻Reduce任务负担。</p><h4 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h4><p>中间键有时候有大量重复计算，原本都需要单独发给reduce任务计算，然后合并。</p><p>现在可以在map任务的计算器上指定一个合并函数，执行合并后写入一个中间文件，发给reduce任务。这样可以提高操作速度。</p><p>这种部分合并的combiner函数和reduce函数代码一致（除了输出的位置）。</p><h4 id="输入输出类型"><a href="#输入输出类型" class="headerlink" title="输入输出类型"></a>输入输出类型</h4><p>支持不同格式读取输入数据，读取器不一定需要提供从文件读取的数据</p><h4 id="跳过坏记录"><a href="#跳过坏记录" class="headerlink" title="跳过坏记录"></a>跳过坏记录</h4><p>数据集并不能保证完全是正确的，如果有一行记录是错误的导致map任务崩溃，不断的重试最终使得整个程序不能结束。因此必然需要跳过这一段错误的记录，如何跳过呢？每个map任务要捕获异常，通过安装信号的方式，在程序退出之前执行安装的信号函数把执行到的文件的行号offset等信息发送给主节点。 主节点在下次调度的时候 将这些offset处的记录作为黑名单列表传递给新的map任务，执行时会对此处的记录跳过执行。</p><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>状态页面可以查看所有任务的进度，心跳跳中附加状态信息，方便用户查看做任务的执行进度</p><p>计数器工具：对各种事件记录，在任务函数中调用incre，定期传给master以更新</p><h3 id="lab1设计"><a href="#lab1设计" class="headerlink" title="lab1设计"></a>lab1设计</h3><h4 id="主要思路："><a href="#主要思路：" class="headerlink" title="主要思路："></a>主要思路：</h4><ol><li><p>map 处理，用ihash处理下key分成Nreduce份用json编码后写出到”mr-x-y”文件。</p><blockquote><p>看MapReduce原文论文这步是有排序的，因为真正生产活动数据量是非常巨大的，map端提前排序好后，reduce的排序压力会减小很多，lab1这里数据量小，排不排序无所谓。</p></blockquote></li><li><p>map 处理结果 返回kv，存储在中间文件中，中间文件命名 mr-X-Y X是map任务号，y是reduce任务号；</p><blockquote><p>map阶段应该将中间键划分为<strong>nReduce</strong>的存储桶，这里只用了一倍reduce数量也就是**%NumReduce**；每个映射器都应创建NumReduce个中间文件，存在main目录下以供Reduce任务使用</p></blockquote></li><li><p>reduce再都读取中间文件；Worker实现将第X个Reduce任务的输出放入文件MR-OUT-X中。Done()方法中，在MapReduceJob完全完成时返回TRUE；此时，mrcoherator.go将退出。当作业完全完成时，工作进程应该退出。</p><blockquote><p>因为真正分布式worker都不在一个机器上，涉及<strong>网络传输</strong>，所以用lab1采用的是<strong>json编码解码走个过场</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql - MySql必知必会记录</title>
      <link href="/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/11/14/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>MySQL必知必会</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  概述</h2><p>数据库：保存有组织的数据的容器</p><ol><li>DBMS：数据库管理系统</li><li>表：某种特定类型数据的结构化清单</li><li>表名：唯一性，</li><li>模式：关于数据库和表的布局及特性的信息；</li><li>列：表的一个字段；</li><li>数据类型：每个表列都有相应的数据类型；</li><li>行：表中的一个记录；</li><li>主键：一列，其值能区别表的每个行；一个总是定义主键；唯一性；非空；不更新，不重用，常量</li><li>SQL(Structured Query Language)：机构化查询语言，专门用来与数据库通信的语言；</li></ol><h2 id="15-联结"><a href="#15-联结" class="headerlink" title="15.联结"></a>15.联结</h2><ol><li><p>外键：表的一列，包含另一个表的逐渐值，定义了两个表之间的关系</p></li><li><p>关系数据库的可伸缩性好：能适应不断增加的工作量而不失败</p></li><li><p>联结：机制，用来在一条select语句中关联表，存在在查询的执行中</p></li><li><p>笛卡尔积 没有联结条件的表关系返回结果为笛卡尔积，没有where限定联结关系</p></li><li><p><strong>内部联结</strong>(等值联结)<br>SELECT vend_name,prod_name,prod_price<br>FROM vendors,products<br>WHERE vendors.vend_id &#x3D; products.vend_id<br>ORDER BY vend_name,prod_name;</p><p>FROM vendors INNER JOIN products<br>ON vendors.vend_id &#x3D; products.vend_id;</p></li><li><p>联结代替子查询</p><p>SELECT cust_name,cust_contact<br>FROM customers<br>WHERE cust_id IN(SELECT cust_id<br>                            FROM orders<br>                            WHERE order_num IN (SELECT order_num<br>​FROM oderitems<br>​WHERE prod_id &#x3D;’TNT2’));</p><p>SELECT cust_name,cust_contact<br>FROM customers ,orders,oderitems<br>WHERE oderitems.prod_id&#x3D;’TNT2’<br>AND oderitems.order_num &#x3D;orders.order_num<br>AND order.cuts_id &#x3D; customers.cust_id;</p></li></ol><h2 id="16-创建高级联结"><a href="#16-创建高级联结" class="headerlink" title="16.创建高级联结"></a>16.创建高级联结</h2><ol><li>别名用在表上：缩短sql语句，单条SELECT语句中不 止一次引用相同的表</li><li><strong>自联结</strong> ：不然要用子查询了<br>SELECT p1.prod_id ,p1.prod_name<br>FROM products As p1,products As p2<br>WHERE p1.vend_id &#x3D; p2.vend_id<br>AND p2.prod_id &#x3D; ‘DTNTR’;</li><li><strong>自然联结</strong>：需要联结则至少有一列出现在不止一个表中，自然连接防止相同列的多次出现：具体是让一个表通配，其他表罗列，自己控制；<br>目前基本都是自然联结</li><li><strong>外部联结</strong>：不仅是两个表中关联的行，还要列出包含没有关联行的哪些行：<br>对课话下了多少订单进行计数，包括那些从没下过订单的客户<br>SELECT custmers.cust_id,orders.order_num<br>FROM customers LEFT OUTER JION orders<br>ON customers.cust_id&#x3D;orders.cust_id;<br>其中LEFT 表示指定左边表的所有行</li><li>带有聚集函数的链接：<br>这里复习一下聚集函数count（sum、avg等）和group by联合使用来返回group by后面条件列的值的条数（合、均值）；<br>这里就是多了个INNER JOIN</li></ol><h2 id="17-组合查询"><a href="#17-组合查询" class="headerlink" title="17.组合查询"></a>17.组合查询</h2><ol><li>单个查询中从不同的表返回类似结构的数据；单个表执行多个查询，按照按个查询返回数据</li><li>用UNION连接两个SELECT语句，可多个组合</li><li>UNION和where一样，自动去处重复的行，也就是当做一次查询返回了；也可以用UNION ALL保留重复</li><li>UNION的一堆只能定义一次ORDER BY</li></ol><h2 id="18-全文本搜索"><a href="#18-全文本搜索" class="headerlink" title="18. 全文本搜索"></a>18. 全文本搜索</h2><ol><li>在创建时启动FULLTEXT(note_text)；定义之后，MySQL自动维护缩影，增加、更新、删除行随时更新；</li><li>索引时执行全文搜索WHERE Match(note_text) Against(‘rabbit’)<br>也可以用link实现 WHERE note_text LINCK ‘%rabbit%’;</li><li>全文搜索的返回顺序,按照被搜索词出现的前后顺序</li><li>也可以在select时候按照搜索值进行返回，其中rank是一个等级值，文本中词靠前的行的等级值比词靠后的 行的等级值高。SELECT note_text,Match(note_text) Against(‘rabbit’) As rank</li><li>查询扩展 WITH QUERY EXPANSION</li><li>布尔文本搜索：没有FULLTEXT索引也可以使用 IN BOOLEAN MODE</li></ol><h2 id="19-数据插入"><a href="#19-数据插入" class="headerlink" title="19.数据插入"></a>19.数据插入</h2><ol><li>insert 插入完整的行，在表名括号给出列明，VALUES括号给出所有的值；</li><li>可以省略列，该列为NULL或定义时给出默认值</li><li>INSERT IN单条insert语句多组值，每组用圆括号，逗号分割</li><li>INSERT SELECT语句，插入检索出来的数据；不管名字，按照列插入，这对不同的表之间的互换有好处</li></ol><h2 id="20-更新和删除数据"><a href="#20-更新和删除数据" class="headerlink" title="20.更新和删除数据"></a>20.更新和删除数据</h2><ol><li><p>UPTATE语句,别忘了WHERE限制<br>UUPTATE customers<br>SET cust_email &#x3D; ‘<a href="mailto:&#101;&#108;&#64;&#x66;&#117;&#x64;&#x64;&#46;&#99;&#111;&#109;">&#101;&#108;&#64;&#x66;&#117;&#x64;&#x64;&#46;&#99;&#111;&#109;</a>‘</p><p>SET cust_name &#x3D; ‘fudd’<br>WHERE cust_id &#x3D; 1005;</p></li><li><p>可以把值设置为NULL以删除某个列的值</p></li><li><p>DELETE FROM删除整行</p></li><li><p>删除所有行 TRUNCATE TABLE</p></li></ol><h2 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21.创建和操纵表"></a>21.创建和操纵表</h2><ol><li>CREATE TABLE创建，用PRIMARY KEY()指定主键列；可以指定多个主键</li><li>可以使用 IF NOT EXISTS</li><li>每个列的数据类型，NOT NULL情况</li><li>AUTO_INCREMENT，自动对该列增量；每个表只允许一个AUTO_INCREMENT列，而且他必须被缩影；</li><li>last_insert_id()函数获得最后一个自增的值；</li><li>DEFAULT 1给出该行的默认值是1；注意该值必须是常量；</li><li>MySQL支撑多种引擎，具有不同特性和功能，一般使用默认（很可能是MyISAM）;用ENGINE &#x3D; 语句显示指出使用哪种引擎；<br>InnoDB是事务处理引擎，不支持全文搜索<br>MEMORY功能差不多，但是数据存储在内存中，速度快<br>MyISAM是性能极高的引擎，支持全文内搜索，但不支持事务处理</li><li>更改表的结构 ALTER TABLE，增加和删除列 ADD和DROP</li><li>删除DROP DABLE customer</li><li>重命名表 RENAME TABLE    TO</li></ol><h2 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22. 使用视图"></a>22. 使用视图</h2><ol><li>虚拟的表，不包含数据，只包含使用时动态检索数据的查询；</li><li>操作视图 CREATE VIEW;SHOW CREATE VIEW;DROP VIEW;CREATE OR REPLACE VIEW</li><li>利用视图简化复杂的联结，创建课重用的视图</li><li>用视图重新格式化检索出的数据Concat()之后转化为VIEW</li><li>用视图过滤不想要的数据</li><li>使用视图与计算字段</li><li>视图的更新，实际上是更新基表的数据吗，有限制的使用</li></ol><h2 id="23-存储过程"><a href="#23-存储过程" class="headerlink" title="23.存储过程"></a>23.存储过程</h2><ol><li><p>通过吧处理封装在容易使用的单元中，简单安全高性能</p></li><li><p>没有创建存储过程的安全访问权限，就不能创建，</p></li><li><p>调用存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,@pricehigh,@priceaverage);</span><br><span class="line">然后调用返回显示</span><br><span class="line">SELECT @pricelow,@pricehigh,@priceaverage;</span><br></pre></td></tr></table></figure></li><li><p>创建存储过程 参数前缀IN OUT INOUT</p></li><li><p>无参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER//</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Avg(prod_price) AS </span><br><span class="line">FROM products;</span><br><span class="line">END;</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>有参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER//</span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">OUT p1 DECIMAL(8,2)</span><br><span class="line">OUT ph DECIMAL(8,2)</span><br><span class="line">OUT pa DECIMAL(8,2))</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Min(prod_price)</span><br><span class="line">INTO p1</span><br><span class="line">FROM products;</span><br><span class="line">SELECT Max(prod_price)</span><br><span class="line">INTO ph</span><br><span class="line">FROM products;</span><br><span class="line">SELECT Avg(prod_price)</span><br><span class="line">INTO pa</span><br><span class="line">FROM products;</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure></li><li><p>删除存储过程<br>DROP PROCEDURE  IF EXISTS priveaverage;</p></li><li><p>高级的存储过程，相对于封装函数啊</p></li><li><p>检查存储过程</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br><span class="line">SHOW PROCEDURE SRARUS LIKE &#x27;ordertotal&#x27;;</span><br></pre></td></tr></table></figure><h2 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24.使用游标"></a>24.使用游标</h2><ol><li>游标用于交互式应用，滚动数据，对数据进行浏览或做出更改；</li><li>MySQL游标只能用于存储过程和和函数</li><li>创建游标</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">DECLARE ordernumbers CURSOR</span><br><span class="line">For </span><br><span class="line">SELECT order_num FROM orders;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><ol start="4"><li>打开和关闭游标 OPEN 和 CLOSE</li><li>使用游标 FETCH ordernumbers INTO o;</li></ol><h2 id="25-触发器"><a href="#25-触发器" class="headerlink" title="25. 触发器"></a>25. 触发器</h2><ol><li><p>响应DELETE、INSERT、UPDATE任一语句而自动执行的MySQL语句</p></li><li><p>创建触发器 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;</span><br></pre></td></tr></table></figure><p>每个表最多6个触发器，每个触发器和单个事件相关联</p></li><li><p>删除触发器 <code>DROP TRIGGER newproduct;</code></p></li><li><p>使用触发器</p></li><li><p>INSERT触发器</p><p>BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）</p><p>可以引用一个名为<strong>NEW的虚拟表</strong>——看起来想是新建new一个不过是按照AUTO_INCREASE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure></li><li><p>DELETE触发器<br>可以引用一个名为<strong>OLD的虚拟表</strong>——本条本删掉的行的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">存档的使用</span><br><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO archive_orders(order_num,order_date,cust_id)</span><br><span class="line">VALUES(OLD.order_num,OLD.order_date,OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></li><li><p>UPDATE触发器<br>可以引用OLD虚拟表访问你以前的值，OLD都是只读不能更新<br>BEFORE UPDATE触发器中，NEW的值可能被更新</p></li><li><p>MySQL的触发器比较初级，创建需要特殊的安全访问权限；但是执行是自动的；触发器来保证数据的一致性；创建审计跟踪很容器；MySQL触发器不支持CALL，不能调用存储过程</p></li></ol><h2 id="26-管理事务处理"><a href="#26-管理事务处理" class="headerlink" title="26. 管理事务处理"></a>26. 管理事务处理</h2><ol><li>事务处理，维护数据库的完整性，保证操作的原子性</li><li>唯物、回退、提交、保留点</li><li>事务开始START TRANSACTION</li><li>回退只能在事务处理中使用 ROLLBACK，只能对INSERT, UPDATE, DELETE语句，不能回退SELECT， CREATE, DROP语句</li><li>事务处理快中，需要显示提交COMMIT</li><li>回退到占位符，保留点SAVEPOINT delete1;保留点越多越好</li><li>回退和提交处理后，事务自动关闭，保留点自动释放</li><li>一般是在自动提交，可以设置autocommit&#x3D;0</li></ol><h2 id="27-全球化和本地化"><a href="#27-全球化和本地化" class="headerlink" title="27.全球化和本地化"></a>27.全球化和本地化</h2><ol><li>字符集、编码、校对collate</li><li>校对顺序在order by子句中很重要，也可以自己select时自己指定校对顺序</li><li>Cast()和Convert()函数转换串的字符集</li></ol><h2 id="28-安全管理"><a href="#28-安全管理" class="headerlink" title="28. 安全管理"></a>28. 安全管理</h2><ol><li><p>访问控制：用户访问权的设置；</p></li><li><p>管理用户：除了root账号，需要创建一系列账号，设置权限；有一个user表包含所有用户账号</p></li><li><p>创建用户账号 CREATE USER ben IDENTIFIED BY ‘p@$$w0rd’;为了作为散列值指定口 令，使用IDENTIFIED BY PASSWORD</p></li><li><p>重命名 RENAME USER ben To bforta;</p></li><li><p>删除 DROP USER ben;</p></li><li><p>设置访问权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显示权限 SHOW GRANTS FOR；</span><br><span class="line">设置权限、被授予的数据库或表、用户名</span><br><span class="line">只读GRANT SELECT,INSERT ON crashcourse.* TP ben;</span><br><span class="line">撤销权限</span><br><span class="line">REVOKE SELECT ON crashcourse.* TP ben;</span><br></pre></td></tr></table></figure></li><li><p>更改用户口令SET PASSWORD &#x3D;Password(‘are you  ok’)</p></li></ol><h2 id="29-数据库维护"><a href="#29-数据库维护" class="headerlink" title="29.数据库维护"></a>29.数据库维护</h2><ol><li>MySQL数据是基于硬盘的文件，备份的方式: 提前FLUSH TABELS</li><li>数据库维护ANALYZE TABLE，用来检查表键是否正确；CHECK TABLE用来针对许多问题对表进行检查；REPAIR TABLE来修复相应的表；如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能</li><li>诊断启动问题</li><li>查看日志文件 错误、查询、二进制、缓慢查询；FLUSH LOGS语句来刷新和重新开始所有日志文 件</li></ol><h2 id="30-改善性能"><a href="#30-改善性能" class="headerlink" title="30. 改善性能"></a>30. 改善性能</h2><ol><li>在导入数据时，应该关闭自动提交</li><li>为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;</li><li>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）</li><li>一般来说，最好是使用FULLTEXT而不是LIKE。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql - MySql数据库运行原理</title>
      <link href="/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>/2023/11/14/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>MySQl是怎么运行的</p><h2 id="1-初始部分"><a href="#1-初始部分" class="headerlink" title="1.初始部分"></a>1.初始部分</h2><p>mysqld 可执行文件 服务器程序<br>服务器相关的mysqld mysqld_safe客户端相关mysql mysqladmin</p><p>默认InnoDB  外键支持的功能的事务存储引擎</p><p>MyISAM      主要的非事务处理存储引擎</p><p>Memory      至于内存的表</p><h3 id="CS进程间通信方式"><a href="#CS进程间通信方式" class="headerlink" title="CS进程间通信方式"></a>CS进程间通信方式</h3><ul><li>TCP&#x2F;IP方式： mysql -h127.0.0.1 -uroot -P3306 -p</li><li>windowOS 的一台主机：命名管道和共享内存</li><li>类Unix的一台主机：套接字</li></ul><h3 id="服务器处理客户端的查询请求流程"><a href="#服务器处理客户端的查询请求流程" class="headerlink" title="服务器处理客户端的查询请求流程"></a>服务器处理客户端的查询请求流程</h3><h4 id="连接管理："><a href="#连接管理：" class="headerlink" title="连接管理："></a>连接管理：</h4><p>S端创建线程处理交互； </p><ul><li>1.限制连接C端数量；2.断开后线程不销毁，另一个C端连接时分配；3，携带主机各类信息发起连接 ，用SSL通信保证数据传输安全性</li></ul><h4 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h4><ol><li>查询缓存：MySQL8.0删除，因为维护缓存开销</li><li>语法解析：编译过程：词法解析 语法解析 语义分析（编译原理）</li><li>查询优化：优化语句，提高效率（类似以扁平化）</li></ol><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>功能：物理上如何存储、读取、写入、表示记录；</p><p>向上提供存储引擎API</p><ul><li>默认的存储引擎InnoDB，主要还有MyISAM、Memory</li></ul><h2 id="2-启动选项和系统变量"><a href="#2-启动选项和系统变量" class="headerlink" title="2. 启动选项和系统变量"></a>2. 启动选项和系统变量</h2><h3 id="命令行上使用选项（当次启动生效）"><a href="#命令行上使用选项（当次启动生效）" class="headerlink" title="命令行上使用选项（当次启动生效）"></a>命令行上使用选项（当次启动生效）</h3><ul><li><p>在选项名前加上 –前缀</p></li><li><p>短形式简化启动选项，短选项名与值之间可以没有间隙</p></li></ul><h3 id="配置文件中使用选项（本机修改）"><a href="#配置文件中使用选项（本机修改）" class="headerlink" title="配置文件中使用选项（本机修改）"></a>配置文件中使用选项（本机修改）</h3><h3 id="系统变量-VARIABLES"><a href="#系统变量-VARIABLES" class="headerlink" title="系统变量 VARIABLES"></a>系统变量 VARIABLES</h3><p>作用范围：全局GLOBAL启动选项、会话SESSION;</p><p>SET GLOBAL default_storage_engine &#x3D; MyISAM;</p><p>SET SESSION default_storage_engine &#x3D; MyISAM;</p><ul><li>默认的作用范围是SESSION</li></ul><h3 id="状态变量-STATUS"><a href="#状态变量-STATUS" class="headerlink" title="状态变量 STATUS"></a>状态变量 STATUS</h3><p>SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</p><h2 id="3-字符集和比较规则"><a href="#3-字符集和比较规则" class="headerlink" title="3.字符集和比较规则"></a>3.字符集和比较规则</h2><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><ul><li><p>ASCII字符集128 1字节；</p></li><li><p>GB2312&#x2F;GBK字符集 对ASCII字符集采用1字节，否则2字节</p></li><li><p>Unicode也是一种字符编码方法，容纳全世界所有语言文字的编码方,UCS只是规定如何编码，并没有规定如何传输、保存这个编码。而我们熟悉的<strong>UTF-8 UTF-16 UTF-32是Unicode的具体实现</strong>(怎么存储在计算机)</p><p>UTF8变长编码方式，1-4字节，MySQL中utf8为1-3，utf8mb4为1-4字节；</p><p><strong>用途</strong>：</p><ol><li><p>可以用来确定数据的存储空间</p></li><li><p>编码和解码方式不一致导致乱码；常见的有UTF-8书写的用GBK解码，导致中文乱码</p></li><li><p>解码后，可以字符集转换；</p><ul><li>类 Unix系统使用的是 utf8</li><li>Windows使用的是 gbk</li><li>CS通信采用的系统变量规定</li></ul><p>character_set_clientS收到后解码方式；<br>character_set_connectionS转换类型；<br> character_set_resultsS返回数据编码方式</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230212171538207.png" alt="image-20230212171538207"></p></li></ol></li></ul><h4 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h4><p>SHOW COLLATION [LIKE 匹配的模式]</p><ul><li>服务器级别 数据库基本 表级别 列级别</li><li>排序时比较 SELECT * FROM t ORDER BY s;</li></ul><h2 id="4-InnoDB记录结构"><a href="#4-InnoDB记录结构" class="headerlink" title="4.InnoDB记录结构"></a>4.InnoDB记录结构</h2><p>将数据划分若干页，页作为磁盘和内存交换的基本单位，InnoDB页的大小一般为16KB</p><h3 id="四种行格式ROW-FORMAT-："><a href="#四种行格式ROW-FORMAT-：" class="headerlink" title="四种行格式ROW_FORMAT ："></a>四种行格式ROW_FORMAT ：</h3><p>Compact、Redundant、Dynamic、Compressed，之后可能还会再加其他的但是原理相同；</p><h3 id="Compact示例"><a href="#Compact示例" class="headerlink" title="Compact示例"></a>Compact示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE record_format_demo (</span><br><span class="line"> -&gt; c1 VARCHAR(10),</span><br><span class="line"> -&gt; c2 VARCHAR(10) NOT NULL,</span><br><span class="line"> -&gt; c3 CHAR(10),</span><br><span class="line"> -&gt; c4 VARCHAR(10)</span><br><span class="line"> -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230212210043291.png" alt="image-20230212210043291"></p><h4 id="1-变长字段部分"><a href="#1-变长字段部分" class="headerlink" title="1. 变长字段部分"></a>1. 变长字段部分</h4><p>VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类型等存储字节数据不固定，称为<strong>变长字段</strong>；</p><p>变长字段占用包括（真正数据内容+占用字节数），这个占用的字节数就放在这部分中。</p><ul><li>逆序存放</li><li>只存非NULL</li><li>按照W*M和L比较，选择1或2字节</li><li>高位补0</li></ul><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816114943613.png" alt="image-20230816114943613"></p><h4 id="2-NULL值列表"><a href="#2-NULL值列表" class="headerlink" title="2. NULL值列表"></a>2. NULL值列表</h4><p>（去掉强制非NULL）二进制位逆序排列，高位补0</p><h4 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h4><ul><li><p>5固定是5字节，40个二进制位表示</p></li><li><p>不同的位表示不同的意思（当前记录的位置信息、是否被使用、删除等）</p></li><li><p>类似表头信息</p></li></ul><h4 id="4-还有一些隐藏列"><a href="#4-还有一些隐藏列" class="headerlink" title="4. 还有一些隐藏列"></a>4. 还有一些隐藏列</h4><ol><li><p>InnoDB自动添加transaction_id事务ID、roll_pointer回滚指针</p></li><li><p>InnoDB默认添加row_id作为主键，但是用户自定义了就不添加</p></li></ol><h4 id="5-真实数据"><a href="#5-真实数据" class="headerlink" title="5. 真实数据"></a>5. 真实数据</h4><p>按照列号顺序存入，字符集相关</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816145752286.png" alt="image-20230816145752286"></p><h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816145852582.png" alt="image-20230816145852582"></p><ul><li><p>把记录中所有列的长度信息都按照逆序存储，按照偏移存储</p></li><li><p>一种比较简单粗暴的格式，所以现在不常用</p></li></ul><h3 id="行溢出：一条记录占用的最大存储空间超出"><a href="#行溢出：一条记录占用的最大存储空间超出" class="headerlink" title="行溢出：一条记录占用的最大存储空间超出"></a>行溢出：一条记录占用的最大存储空间超出</h3><ul><li>溢出页+指针</li><li>一个页一般是<strong>16KB</strong> 记录太多或者记录太大， 当前页存不下，多于数据存储到其他页，叫行溢出</li><li>要记住一行中国所有列占用的字节长度记起来不超过65535字节</li><li>对于占用存储空间非常大的列，在记录真是数据处只会存储该列的一部分数据，把剩余的数据分散存储在其他几个页中，然后记录的真是数据处用20个字节存储指向这些页的地址</li><li>MySQL规定一个页中至少存放两行数据</li></ul><h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>和Compact像，但是处理行溢出的时候，把所有的数据都放在溢出页</p><h2 id="5-InnoDB数据页结构"><a href="#5-InnoDB数据页结构" class="headerlink" title="5.InnoDB数据页结构"></a>5.InnoDB数据页结构</h2><p>索引页（数据页）：存放表中记录的那种类型的页</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230816152404384.png" alt="image-20230816152404384"></p><ul><li>数据插入过程就是从Free Space划分空间，写入记录，放到User Records的部分。</li><li>当Free Space用完了，就是本页使用完了</li></ul><h4 id="记录的位置"><a href="#记录的位置" class="headerlink" title="记录的位置"></a>记录的位置</h4><ul><li>heap_no表示记录在本页中的位置，但是0 Infimum和 1 Supermum是伪记录，由页给出</li><li>用next_record指向下一条记录。所以一个页中的记录用单链表表示连接起来</li></ul><p>如何查找一个记录：</p><ol><li>将页中记录分为几个组，<strong>每组的最后一条记录地址偏移量存在Page Directory页目录</strong>（槽）</li><li>n_owned表示以此结尾的组的记录数。InnoDB规定最小记录结尾分组只有1条，最大记录结尾分组有1-8条，剩下分组时4-8条之间。</li></ol><h5 id="添加记录条的过程："><a href="#添加记录条的过程：" class="headerlink" title="添加记录条的过程："></a>添加记录条的过程：</h5><p>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。<br>之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。<br>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在 页目录 中<strong>新增一个 槽</strong> 来记录这个新增分组中最大的那条记录的偏移量。</p><h5 id="一个数据页中查找指定主键值的记录过程："><a href="#一个数据页中查找指定主键值的记录过程：" class="headerlink" title="一个数据页中查找指定主键值的记录过程："></a>一个数据页中查找指定主键值的记录过程：</h5><ol><li>二分查找所在的槽，找到槽中最小记录</li><li>next_record属性遍历槽所在的组中的各个记录</li></ol><h2 id="6-B-数索引"><a href="#6-B-数索引" class="headerlink" title="6. B+数索引"></a>6. B+数索引</h2><p>前提保证：下一个数据页中记录的主键值必须大于上一个页中用户记录的主键值（页分裂）。</p><p>把每个页的最小主键值和页号合在一起，列一个目录，成为索引。这样的页是<strong>索引页</strong>，其中记录是索引record_type &#x3D; 1。索引页信息提取后放大更高级的目录项，依次层级递推，就是一个B+树。一般不超过4层</p><h4 id="聚簇索引："><a href="#聚簇索引：" class="headerlink" title="聚簇索引："></a>聚簇索引：</h4><ol><li>使用记录的主键值的大小进行记录和页的排序：页内记录组成单向链表；存放用户记录的页也组成双向链表；存放目录项记录的页分为不同层次，在同一层次中的页根据页中目录项记录的主键大小排序组成双向链表。</li><li>B+树叶子结点是完整的用户记录</li></ol><p>InnoDB自动创建的结构，索引即数据</p><h4 id="二级索引："><a href="#二级索引：" class="headerlink" title="二级索引："></a>二级索引：</h4><p>根据非主键查找，就需要建立另一棵树，键是查找列，值是主键。</p><ol><li>同样的方法查找叶子结点的记录，找到主键值</li><li>按照主键再索引一遍，找到完整记录（回表）</li></ol><p>回表是为了减少建第二颗树存完整数据的所占的空间。</p><h4 id="联合索引："><a href="#联合索引：" class="headerlink" title="联合索引："></a>联合索引：</h4><p>先把各个记录和页按照 c2 列进行排序；<br>在记录的 c2 列相同的情况下，采用 c3 列进行排序</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li>根页面一直不动，先创建B+树缩影，然后添加记录、多了分页作为索引页，但是根节点不会移动</li><li>页节点中记录项记录的唯一性，在目录项记录的内容是主键+索引列+页号，来保证唯一性</li><li>一个页面至少存两条记录</li></ol><h3 id="MyISAM中索引方案"><a href="#MyISAM中索引方案" class="headerlink" title="MyISAM中索引方案"></a>MyISAM中索引方案</h3><ul><li>记住MySIAM和InnoDB区别是他把索引和数据分开存储</li></ul><ol><li>数据文件：按照插入的顺序把记录单独存储在一个文件。</li><li>B+树，根节点是行号而非完整数据。</li></ol><ul><li>建立的索引，相当于全是二级索引，因为要回表找完整的数据</li></ul><h3 id="创建和删除索引"><a href="#创建和删除索引" class="headerlink" title="创建和删除索引"></a>创建和删除索引</h3><p>InnoDB和MyISAM会<code>自动</code>为<strong>主键或UNIQUE列</strong>生成B+树索引。</p><p>其他需求，声明建立B+树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TALBE 表名 (</span><br><span class="line"> 各种列的信息 ··· , </span><br><span class="line"> [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX idx_c2_c3 (c2, c3)                    //创建联合声明</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE index_demo DROP INDEX idx_c2_c3       //删除索引</span><br></pre></td></tr></table></figure><h2 id="7-B-树索引的使用"><a href="#7-B-树索引的使用" class="headerlink" title="7. B+树索引的使用"></a>7. B+树索引的使用</h2><h3 id="索引代价"><a href="#索引代价" class="headerlink" title="索引代价"></a>索引代价</h3><ol><li>空间上建树，数据页代价</li><li>时间上CRUD需要修改索引，为了维护排序需要移位操作</li></ol><h3 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h3><p>建立了联合索引后，可以适用以下情况：</p><ol><li><p>全值匹配</p></li><li><p>匹配左边的列</p></li><li><p>列前缀 （英文前缀n个字符</p></li><li><p>匹配范围值</p></li><li><p>精确匹配某一列，范围匹配另一列</p></li><li><p>用于排序，用联合索引必须<strong>按照几个列的顺序</strong>，因为有比较的优先级；但是几个变量选择ASC、DESC混用的情况不能，也就是联合索引的各个排序列的<strong>排序顺序必须一致</strong>；不能用修饰过的表达式（无法比较）</p></li><li><p>用于分组，要求和排序差不多</p></li></ol><h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>联合索引中，二级索引查找读取主键，因为是顺序IO快，但是按主键聚簇索引是随机IO慢。</p><p>如果需要回表的记录数很多，倾向于全表扫描：</p><ol><li>一般加LIMIT多少就倾向于二级索引+回表</li><li>有排序需求也是满足这类讨论</li></ol><ul><li>为了去掉回表的性能损耗，建议<strong>只查索引列</strong>，这样告别了回表，称为<code>覆盖索引</code></li></ul><h3 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h3><h4 id="1-只为搜索、排序、分组的列创建"><a href="#1-只为搜索、排序、分组的列创建" class="headerlink" title="1. 只为搜索、排序、分组的列创建"></a>1. 只为搜索、排序、分组的列创建</h4><p>只是查询就没必要，只需要为出现在WHERE句子中的列、连接子句中的连接列，或者ORDER BY、GROUP BY子句中列创建索引。</p><h4 id="2-列的基数越大于好"><a href="#2-列的基数越大于好" class="headerlink" title="2. 列的基数越大于好"></a>2. 列的基数越大于好</h4><p>基数就是去掉重复数，重复太多不好排序</p><h4 id="3-索引列的类型尽量小"><a href="#3-索引列的类型尽量小" class="headerlink" title="3. 索引列的类型尽量小"></a>3. 索引列的类型尽量小</h4><p>类型表示的数据范围小，CPU查询快，存储空间小，页可以放更多的记录</p><h4 id="4-索引字符串值的前缀"><a href="#4-索引字符串值的前缀" class="headerlink" title="4.索引字符串值的前缀"></a>4.索引字符串值的前缀</h4><p>只对字符串的前几个字符进行索引，这样节约空间、比较时间、解决排序问题</p><h4 id="5-索引列在比较表达式单独出现"><a href="#5-索引列在比较表达式单独出现" class="headerlink" title="5.索引列在比较表达式单独出现"></a>5.索引列在比较表达式单独出现</h4><p>如果是表达式的形式，而不是单独列出现，不能用到索引（引擎没有前处理优化）</p><h4 id="6-主键插入顺序"><a href="#6-主键插入顺序" class="headerlink" title="6.主键插入顺序"></a>6.主键插入顺序</h4><p>最好是从小到大插入，如果是随机等，插入过程需要性能损耗</p><h4 id="7-不要冗余或者重复索引"><a href="#7-不要冗余或者重复索引" class="headerlink" title="7.不要冗余或者重复索引"></a>7.不要冗余或者重复索引</h4><h4 id="8-尽量使用覆盖索引避免回表"><a href="#8-尽量使用覆盖索引避免回表" class="headerlink" title="8.尽量使用覆盖索引避免回表"></a>8.尽量使用覆盖索引避免回表</h4><h2 id="8-MySQL的数据目录"><a href="#8-MySQL的数据目录" class="headerlink" title="8.MySQL的数据目录"></a>8.MySQL的数据目录</h2><p>InnoDB和MyISAM是把表存在文件系统上的，然后读写页</p><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><p>数据库程序启动的时候在目录下加载文件，在运行时产生的数据存储到目录的文件中。区别于安装目录</p><h4 id="数据库在文件中的表示"><a href="#数据库在文件中的表示" class="headerlink" title="数据库在文件中的表示"></a>数据库在文件中的表示</h4><ul><li>每个数据库对应数据目录下一个子目录，或者说文件夹，其下还有db.opt文件，包含数据库的各种数学，比如字符集和比较规则</li></ul><p>InnoDB的索引即数据：其包含的表空间：系统表空间、独立表空间、其他类型的</p><blockquote><p>对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为 表名.ibd 的实际文件。</p></blockquote><p>MyISAM分开存储：.MYD是数据 .MYI是索引文件</p><h4 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h4><p><strong>视图</strong>是虚拟的表，在其数据库下，也需要存储起来，视图名.frm</p><p>数据库进程文件</p><p>数据库日志文件：查询日志、错误日志、二进制日志、redo日志</p><p>默认&#x2F;自动生成的SSL和RSA证书和秘钥文件</p><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><strong>mysql</strong><br>核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过<br>程中产生的日志信息，一些帮助信息以及时区信息等</p><p><strong>information_schema</strong><br>MySQL服务器维护的<strong>所有其他数据库的信息</strong>，比如有哪些表、哪些视图、哪些触发器、哪些列。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。</p><p><strong>performance_schema</strong><br>存MySQL服务器<strong>运行过程中的一些状态信息</strong>，算是对MySQL服务器的一个性能监控。<br>包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p><p><strong>sys</strong><br>这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</p><h2 id="9-InnoDB的表空间-不太熟再看看"><a href="#9-InnoDB的表空间-不太熟再看看" class="headerlink" title="9.InnoDB的表空间 不太熟再看看"></a>9.InnoDB的表空间 不太熟再看看</h2><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><p>ALLOCATED 分配还未使用</p><p>INDEX 索引页，数据页</p><h3 id="页面通用部分"><a href="#页面通用部分" class="headerlink" title="页面通用部分"></a>页面通用部分</h3><p>FileHeader 包含页号、检验和、类型、next、prev</p><p>主体</p><p>FileTrailer 校验页面是否完整，保证内存到磁盘刷新时内容一致性</p><h3 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h3><p>独立表空间和系统表空间中，64页是一个区，256区是一个组；</p><p>每个组的最开始几个页面类型固定，表示一些属性信息；</p><h4 id="区、段的概念："><a href="#区、段的概念：" class="headerlink" title="区、段的概念："></a>区、段的概念：</h4><p>因为随机访问内存损耗，且磁盘读取很慢，所以数据量大的时候可以用<strong>区</strong>为分配单位。</p><p>叶子结点有独有的区，区的集合称为<strong>段</strong>，非叶子节点也有段。</p><p>但是数据量小的表用整个区浪费存储空间，会设置<strong>碎片区</strong>，碎片区直属于表空间</p><ul><li>首先插入数据，段式从碎片区以页面为单位分配存储空间</li><li>段已经占了32个碎片区页面后，单独以完整的为范围分配存储空间</li></ul><p><strong>目的：提高表插入数据的效率，又不至于数据量少的表浪费空间</strong></p><h4 id="区的分类："><a href="#区的分类：" class="headerlink" title="区的分类："></a>区的分类：</h4><p>FREE、 FREE_FRAG、 FULL_FRAG、FSEC（附属于某个段了）：前三个直属于表空间</p><ol><li><p>表空间由若干区组成，每个区有一个XDES Entry结构，直属于表空间的区对应XDES Entry结构分为FREE、 FREE_FRAG、 FULL_FRAG三个链表；</p></li><li><p>每个段附属于若干区，每个段中的区对应的XDES Entry结构分为FREE、NOT_FULL、FULL 3个链表。每个链表对应一个List Base Node的结构，和这个机构记录俩表的头、尾节点，以及节点数。来管理这些区。</p></li></ol><p>举例：一个表有两个索引，聚簇和二级索引，那就有4个段，12个上述段相关区的链表，加上3个直属于表空间的三个链表，共15个链表。</p><h4 id="段的分类："><a href="#段的分类：" class="headerlink" title="段的分类："></a>段的分类：</h4><p>段是一个逻辑上的概念，由若干零散的页面和一些完整的区组成。</p><p>也有一个INODE Entry结构记录段中的属性</p><p>也有List Base Node记录三个链表的信息</p><h4 id="各类页面的详细情况"><a href="#各类页面的详细情况" class="headerlink" title="各类页面的详细情况"></a>各类页面的详细情况</h4><p>表空间的第一个组的第一个页面FSP_HDR描述了区的信息，也就是包含很多XDES Entry</p><p>第二个页面是IBUF_BITMAP信息，记录关于Change Buffer东西</p><p>第三个页面是INODE，为了存储 INODE Entry 结构而存在的</p><h4 id="Segment-Header"><a href="#Segment-Header" class="headerlink" title="Segment Header"></a>Segment Header</h4><p>把段和INDOE Entry对应起来的方法：在<strong>数据页</strong>的PageHeader中有两个Segment Header结构，记录着叶子结点和非叶子结点的头部信息（两个段），去定位INODE Entry：哪个表空间的哪个页面的哪个偏移量</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230826154746003.png" alt="image-20230826154746003" style="zoom:50%;" /><h3 id="系统表空间结构"><a href="#系统表空间结构" class="headerlink" title="系统表空间结构"></a>系统表空间结构</h3><p>表空间ID是0，开头有许多记录整个系统属性的页面。</p><p>每次向表插入记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。</p><p>所以需要些额外的信息，叫做<strong>元数据</strong>，InnoDB定义了一些列的<strong>内部系统表</strong>（数据字典）记录。</p><p><strong>基本系统表：</strong></p><p>SYS_TABLES 整个InnoDB存储引擎中所有的表的信息<br>SYS_COLUMNS 整个InnoDB存储引擎中所有的列的信息<br>SYS_INDEXES 整个InnoDB存储引擎中所有的索引的信息<br>SYS_FIELDS 整个InnoDB存储引擎中所有的索引对应的列的信息</p><ul><li><p>有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。</p></li><li><p>Data Dictionary Header页面是页号为7的SYS类型页面，记录了这4个表的5个索引的根页面信息和一些全局信息</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>区、段、记录区entry的表、记录段entry的表，段到分配区的链表，把数据页和段联系起来的segment header；</p><p>记录系统的表，表的索引页Data dictionary header；</p><h2 id="10-单表查询的方法"><a href="#10-单表查询的方法" class="headerlink" title="10. 单表查询的方法"></a>10. 单表查询的方法</h2><p>数据库的<strong>查询优化器</strong>的自动查询方式：全表扫描、索引查询。具体类型分为以下</p><blockquote><p>注：UNIQUE唯一索引可以用于确保表中某一列或列组的数值唯一性约束，以便在查询和筛选数据时提高性能和准确性。当你尝试在已存在的唯一索引中插入重复值时，数据库会返回错误。</p></blockquote><h3 id="const常数级别"><a href="#const常数级别" class="headerlink" title="const常数级别"></a>const常数级别</h3><p>通过主键或者唯一二级索引列（多列的话，每一列都要与常数等值比较）定位一条记录的方法。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>普通的二级索引列与常数<code>等值</code>比较。</p><p>因为可能找到多条对应记录，如果记录少选择索引，而不是全表扫描时</p><ul><li>NULL值二级索引，NULL可能有多个所以是ref</li></ul><h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出<br>来</p><p>使用二级索引而不是全表扫描的方式执行该查询时，称为ref_or_null</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>索引列需要匹配某个或某些范围的值，利用<strong>索引</strong>进行<strong>范围匹配</strong></p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 &#x3D; ‘abc’;</p><p>key_part1, key_part2, key_part3都是联合索引的索引，列但是key_part2不是联合索引中最左索引列</p><p>直接<strong>遍历二级索引记录</strong></p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>全表扫描</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>重温 二级索引+回表：<br><code>一般情况</code>下只能用<strong>单个二级索引执行查询</strong>，茶轩优化器识别多个搜索条件，先判断哪个条件用二级索引行数更少，就用二级索引+回表，再筛选处理其他的条件。</p></li><li><p>明确range访问方法使用的范围区间<br>有的搜索条件无法使用索引的情况</p></li><li><p>索引合并</p><p>特殊情况可能在一个查询中使用多个二级索引，index merge算法：</p><p>1） Intersection交集：多次二级索引，求出的主键求交集，再回表聚簇索引（因为二级索引是顺序搜索，回表是随机搜索开销大）</p><p>2）Union并集，适用于OR连接，必须保证二级索引列等值匹配，或者主键范围匹配</p><p>3）Sort-Union合并，多次二级索引，然后按主键分别排序，然后合并</p></li><li><p>注意用联合索引代替Intersection合并比较快</p></li></ol><p><code>剩余的访问方式：</code> 15节补</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory</p><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>连接查询时，被驱动表是通过主键或唯一二级索引等值匹配进行访问</p><h3 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h3><p>全文索引</p><h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h3><p>在某些场景下可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询</p><h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery</p><h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p>访问子查询中的表时使用的是普通的索引</p><h2 id="11-连接（联结）的原理"><a href="#11-连接（联结）的原理" class="headerlink" title="11.连接（联结）的原理"></a>11.连接（联结）的原理</h2><p>单纯连接，连接查询的结果表包含两个表（可以多个表）的记录的笛卡尔积</p><h4 id="连接过程："><a href="#连接过程：" class="headerlink" title="连接过程："></a>连接过程：</h4><ol><li>涉及单表的条件；常规</li><li>涉及两表查询的条件；<ul><li>第一个表是驱动表，首先选取与驱动表相关的过滤条件，对驱动表单表查询，只查询一次；</li><li>然后第二个表是被驱动表，按照赵上步的结果，对每条记录都在被驱动表查询并筛选匹配的结果，访问多次；</li><li>有其他表连接，那么结果集就是新的驱动表，第三个表就成了被驱动表重复上述过程</li></ul></li></ol><h4 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h4><ol><li>INNER JOIN或WHERE语句，对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接 。</li><li>（LEFT 或 RIGHT）OUTER JOIN 对于 外连接 的两个表，<strong>驱动表中的记录</strong>即使在<strong>被驱动表中没有匹配的记录，也仍然需要加入到结果集</strong>， 对于的被驱动表的各字段用NULL表示</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><ul><li>推荐内连接用INNER JOIN，外连接用LEFT&#x2F;RIGHT JOIN</li><li>内连接的驱动表和被驱动表可以换，外连接不行。</li></ul><h4 id="嵌套循环连接"><a href="#嵌套循环连接" class="headerlink" title="嵌套循环连接"></a>嵌套循环连接</h4><p>就是上述双表查询的过程</p><h4 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h4><p>在连接查询中对被驱动表使用<strong>主键值或者唯一二级索引列的值</strong>进行<strong>等值查找</strong>的查询执行方式称之为： eq_ref 。</p><ul><li>当然建立索引不一定用，只有二级索引+回表的代价比all代价低才会用</li><li>还有不要用select * 这样方式，最好是需要什么列列出来，这样可以用index方式</li></ul><h4 id="基于块的嵌套循环连接"><a href="#基于块的嵌套循环连接" class="headerlink" title="基于块的嵌套循环连接"></a>基于块的嵌套循环连接</h4><p>申请一块内存，把若干驱动表结果集中记录到join buffer中，被驱动表的记录一次性和其中多条驱动表记录做匹配</p><h2 id="12-MySQL基于成本的优化"><a href="#12-MySQL基于成本的优化" class="headerlink" title="12.MySQL基于成本的优化"></a>12.MySQL基于成本的优化</h2><p>MySQL执行查找的成本：</p><p>​1.0的I&#x2F;O成本（读取一个页面），0.2的CPU成本（检测一个记录是否符合搜索条件）</p><h3 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h3><h4 id="基于成本计算的优化"><a href="#基于成本计算的优化" class="headerlink" title="基于成本计算的优化"></a>基于成本计算的优化</h4><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><h4 id="计算all的成本"><a href="#计算all的成本" class="headerlink" title="计算all的成本"></a>计算all的成本</h4><p>Rows 表中的记录条数</p><p>Data_length 表占用的存储空间字节数 &#x2F;16&#x2F;1024就是页面数量被（16K一个页面）</p><p>1.0的I&#x2F;O成本，0.2的CPU成本&#x3D;1.0 *页面数 + 0.2*记录数</p><h4 id="计算索引的成本"><a href="#计算索引的成本" class="headerlink" title="计算索引的成本"></a>计算索引的成本</h4><ol><li>二级索引：</li></ol><p>范围区间数量：顺序IO基本就是1；</p><p>得到需要回表的记录数，范围搜索（不是UNIQUE），得到最左页面和最右页面，读取；</p><p>所在页面*1.0 + 搜的记录*0.2</p><ol start="2"><li>回表</li></ol><p>回表后得到完整用户记录：需要完整记录的IO + 读取二级索引记录CPU + 回表聚簇索引CPU</p><h3 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h3><p>驱动表查询得到的结果条数：扇出值</p><p>condition filtering计算扇出值需要查询优化去猜,实际用了启发式规则：</p><ol><li>全表扫描的单表查询，猜搜索条件的记录有多少条</li><li>索引执行单表扫描，才满足除使用到对应索引的搜索条件外的搜索条件的记录有多少</li></ol><h4 id="两表连接的成本"><a href="#两表连接的成本" class="headerlink" title="两表连接的成本"></a>两表连接的成本</h4><p>连接查询总成本 &#x3D; 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</p><ul><li>内连接要考虑哪个作为驱动表，能用到索引 或者 减少驱动表的扇出</li></ul><h4 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h4><p>减少一些连接方法的考虑</p><h2 id="13-InnoDB统计数据如何收集"><a href="#13-InnoDB统计数据如何收集" class="headerlink" title="13. InnoDB统计数据如何收集"></a>13. InnoDB统计数据如何收集</h2><p>之前成本估计的一些统计信息如何收集</p><p>永久性的统计数据，非永久性的统计数据（用的少），STATS_PERSISTENT &#x3D; 0|1</p><ul><li>InnoDB 默认是以<strong>表</strong>为单位来收集和存储统计数据的</li></ul><h3 id="永久性数据"><a href="#永久性数据" class="headerlink" title="永久性数据"></a>永久性数据</h3><h4 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h4><p>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</p><p>|database_name |数据库名|<br>|table_name| 表名|<br>|last_update| 本条记录最后更新时间|<br>|n_rows |表中记录的条数|  <code>页面采样法统计的</code><br>|clustered_index_size |表的聚簇索引占用的页面数量|<br>|sum_of_other_index_sizes |表的其他索引占用的页面数量|</p><h4 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h4><p> 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</p><p>database_name 数据库名<br>table_name 表名<br>index_name 索引名<br>last_update 本条记录最后更新时间<br>stat_name 统计项的名称<br>stat_value 对应的统计项的值<br>sample_size 为生成统计数据而采样的页面数量<br>stat_description 对应的统计项的描述</p><h4 id="自动更新和手动更新表"><a href="#自动更新和手动更新表" class="headerlink" title="自动更新和手动更新表"></a>自动更新和手动更新表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE innodb_table_stats </span><br><span class="line">SET n_rows = 1</span><br><span class="line">WHERE table_name = &#x27;single_table&#x27;;</span><br><span class="line"></span><br><span class="line">FLUSH TABLE single_table;</span><br></pre></td></tr></table></figure><h3 id="innodb-stats-method"><a href="#innodb-stats-method" class="headerlink" title="innodb_stats_method"></a>innodb_stats_method</h3><p>nulls_equal ：认为所有 NULL 值都是相等的。这个值也是 innodb_stats_method 的默认值。<br>nulls_unequal ：认为所有 NULL 值都是不相等的。<br>nulls_ignored ：直接把 NULL 值忽略掉。</p><h2 id="14-MySQL基于规则的优化"><a href="#14-MySQL基于规则的优化" class="headerlink" title="14. MySQL基于规则的优化"></a>14. MySQL基于规则的优化</h2><p>MySQL自动的语句优化，重写规则相关</p><h3 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h3><ol><li><p>移除不必要的括号</p></li><li><p>常量传递</p></li><li><p>等值传递</p></li><li><p>移除没用的条件</p></li><li><p>表达式计算：</p><blockquote><p>如果某个列不是单独的形式作为表达式的操作数，比如出现在函数等不会化简;</p><p>就像之前说的如果不是单独的形式，不能用于索引</p></blockquote></li><li><p>HAVING子句和WHERE子句的合并</p><blockquote><p>WHERE在数据分组前进行过滤，HAVING在<strong>数据分组后</strong>进行过滤。</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230819155644556.png" alt="image-20230819155644556"></p><p>所以当没有SUM、MAX、GROUP BY子句就可以把HAVING和WHERE子句合并</p></blockquote></li><li><p>常量表检测</p></li></ol><h3 id="外连接消除"><a href="#外连接消除" class="headerlink" title="外连接消除"></a>外连接消除</h3><p>指定（或者隐含）被驱动表中的列不为NULl，这种条件称为 <strong>空值拒绝</strong></p><p>空值拒绝后内外连接互相转换，查询优化器就可以转换驱动表来优化成本了</p><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询-外层查询</p><p>包括：SELCET子句中 、FROM子句中、WHERE ON子句中、 ORDER BY 子句中、GROUP BY 子句中</p><ol><li>必须小括号</li><li>select对于的标量子查询</li><li>（NOT） IN ANY SOME ALL查询来说不允许LIMIT语句</li><li>去掉一些冗余的表达</li></ol><h4 id="子查询执行"><a href="#子查询执行" class="headerlink" title="子查询执行"></a>子查询执行</h4><ol><li>对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了</li></ol><p>物化表，作为临时表去重、哈希；转连接</p><ul><li>半连接 （英文名： semi-join ）。将 s1 表和 s2 表进行半连接的意思就是：对于 s1 表的某条记录来说，我们只关心在 s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留 s1 表的记录</li></ul><p>如果 IN 子查询符合转换为 semi-join 的条件，查询优化器会优先把该子查询为 semi-join ，然后再考虑下<br>边5种执行半连接的策略中哪个成本最低：<br>Table pullout<br>DuplicateWeedout<br>LooseScan<br>Materialization<br>FirstMatch<br>选择成本最低的那种执行策略来执行子查询。<br>如果 IN 子查询不符合转换为 semi-join 的条件，那么查询优化器会从下边两种策略中找出一种成本更低的<br>方式执行子查询：<br>先将子查询物化之后再执行查询<br>执行 IN to EXISTS 转换。</p><h2 id="15-Explain详解"><a href="#15-Explain详解" class="headerlink" title="15.Explain详解"></a>15.Explain详解</h2><p>在具体的查询语句前边加一个 EXPLAIN ：帮助我们查看某个查询语句的具体执行计划，</p><p>列名 描述<br>id 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id<br>select_type SELECT 关键字对应的那个查询的类型<br>table 表名<br>partitions 匹配的分区信息<br>type 针对单表的访问方法<br>possible_keys 可能用到的索引<br>key 实际上使用的索引<br>key_len 实际使用到的索引长度<br>ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息<br>rows 预估的需要读取的记录条数<br>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比<br>Extra 一些额外的信息</p><h2 id="16-15-Explain详解-下"><a href="#16-15-Explain详解-下" class="headerlink" title="16. 15.Explain详解 下"></a>16. 15.Explain详解 下</h2><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Using index</p><p>Using index condition</p><p>等。。。用到在看吧</p><h3 id="Json格式的执行计划"><a href="#Json格式的执行计划" class="headerlink" title="Json格式的执行计划"></a>Json格式的执行计划</h3><p>在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT&#x3D;JSON</p><p> json 格式的执行计划，里边儿包含该计划花费的成本</p><h3 id="Extented-EXPLAIN"><a href="#Extented-EXPLAIN" class="headerlink" title="Extented EXPLAIN"></a>Extented EXPLAIN</h3><p>使用 EXPLAIN 语句查看了某个查询的执行计划后，紧接着还可以使用 <strong>SHOW WARNINGS</strong> 语句查看与这个查询的执行计划有关的一些扩展信息</p><ul><li>Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句</li></ul><h2 id="17-optimizer-trace表"><a href="#17-optimizer-trace表" class="headerlink" title="17. optimizer trace表"></a>17. optimizer trace表</h2><p>方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量optimizer_trace 决定，默认是关闭的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br></pre></td></tr></table></figure><p>然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到</p><p><strong>information_schema</strong> 数据库下的 <strong>OPTIMIZER_TRACE</strong> 表中查看完整的优化过程。这个OPTIMIZER_TRACE 表有4个列，分别是：</p><ol><li>QUERY ：表示我们的查询语句。</li><li>TRACE ：表示优化过程的JSON格式文本。</li><li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE ：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li>INSUFFICIENT_PRIVILEGES ：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是1 ，我们暂时不关心这个字段的值。</li></ol><ul><li>演示了调用 optimizer trace表的方式</li></ul><h2 id="18-调节磁盘和CUP的矛盾-InnoDB的BufferPool"><a href="#18-调节磁盘和CUP的矛盾-InnoDB的BufferPool" class="headerlink" title="18. 调节磁盘和CUP的矛盾-InnoDB的BufferPool"></a>18. 调节磁盘和CUP的矛盾-InnoDB的BufferPool</h2><h3 id="InnoDB的Buffer-Pool"><a href="#InnoDB的Buffer-Pool" class="headerlink" title="InnoDB的Buffer Pool"></a>InnoDB的Buffer Pool</h3><p>Mysql服务器启动时，申请的连续内存。默认128MB</p><h3 id="内部组成："><a href="#内部组成：" class="headerlink" title="内部组成："></a>内部组成：</h3><p>控制块 碎片 缓存也</p><h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>空闲的缓存块对应的控制块作为节点放到链表中，free链表以供取用</p><h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>表空间号+页号是key，查找缓存页，是否存在Buffer Pool中</p><h3 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h3><p>修改了一个缓存页的数据，就是<code>脏页</code>，需要等待同步到磁盘上</p><p>flush链是存储脏页的，</p><h3 id="LRU链表管理"><a href="#LRU链表管理" class="headerlink" title="LRU链表管理"></a>LRU链表管理</h3><p>缓存页需要移除，留下频繁使用的</p><p>LRU（Least Recently Pool) 按照最近最少使用的原则淘汰缓存页。访问页的时候，把页放到Buffer Pool的LRU链的头部</p><h4 id="1）划分区域的LRU链表"><a href="#1）划分区域的LRU链表" class="headerlink" title="1）划分区域的LRU链表"></a>1）划分区域的LRU链表</h4><p>问题： 1. 预读导致不一定用到 2. 全表扫描读入频率偏低的页</p><p>做法： LRU链表分区：热数据young区域，冷数据old区域</p><p>当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部。</p><h4 id="2）进一步优化"><a href="#2）进一步优化" class="headerlink" title="2）进一步优化"></a>2）进一步优化</h4><p>只有被访问的缓存页位于 young 区域的 1&#x2F;4 的后边，才会被移动到 LRU链表头部等</p><h3 id="刷新脏页到磁盘"><a href="#刷新脏页到磁盘" class="headerlink" title="刷新脏页到磁盘"></a>刷新脏页到磁盘</h3><p>专门的线程负责</p><ol><li>LRU链表冷数据刷新部分页面到磁盘</li><li>flash链表刷新部分页面到磁盘</li></ol><h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h3><p>拆分若干个小的Buffer Pool，多线程并发访问</p><h3 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h3><p>chunk为单位想操作系统申请空间。</p><p>在运行期间以chunk为单位增加或删除内存空间</p><p>innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的</p><h3 id="查看Buffer-Pool的状态信息"><a href="#查看Buffer-Pool的状态信息" class="headerlink" title="查看Buffer Pool的状态信息"></a>查看Buffer Pool的状态信息</h3><p>SHOW ENGINE INNODB STATUS</p><h2 id="19-事务简介transaction"><a href="#19-事务简介transaction" class="headerlink" title="19. 事务简介transaction"></a>19. 事务简介transaction</h2><p>ACID 原子性 一致性 隔离性Isolation 持久性Durability</p><p>需要保证ACID的一个或多个数据库操作称为一个事务</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230824193205375.png" alt="image-20230824193205375" style="zoom:50%;" /><h3 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h3><ol><li>开启用 BEGIN [WORK] 或者 START TRANSACTION + 修饰符（READ ONLY、 READ WRITE、 WITH CONSISTENT SANPSHOT</li><li>提交用 COMMIT [WORK]</li><li>中止并回归 ROLLBACK[WORK]</li></ol><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>只有InnoDB和NDB存储引擎支持事务，ROLLBACK必须支持事务才能用</p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>autocommit 为 ON</p><p>每条语句都算是一个独立的事务，叫做自动提交</p><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>关闭自动提交后，会导致事务隐式提交的语句包括：</p><ol><li><p>定义或修改数据库对象的数据定义语言DDL，比如说CREAT、ALERT、DROP</p></li><li><p>隐式使用或修改<strong>mysql数据库</strong>中的表</p></li><li><p>事务控制或关于锁定的句子： START TRANSACTION、 LOCK TABLES</p></li><li><p>加载数据的语句： LOAD DATA</p></li><li><p>关于Mysql复制的一些语句： START SLAVE 、 STOP SLAVE 、 RESET SLAVE 、 CHANGE MASTER TO</p></li><li><p>其他一些系统语句： </p><p>使用 ANALYZE TABLE 、 CACHE INDEX 、 CHECK TABLE 、 FLUSH 、 LOAD INDEX INTO CACHE 、 OPTIMIZE TABLE 、 REPAIR TABLE 、 RESET 等语句也会隐式的提交前边语句所属的事务。</p></li></ol><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>SAVEPOINT 保存点名称;</p><p>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</p><p>RELEASE SAVEPOINT 保存点名称;</p><h2 id="21-redo-log（上）"><a href="#21-redo-log（上）" class="headerlink" title="21. redo log（上）"></a>21. redo log（上）</h2><p>问题： 事务提交了，数据修改了只存在Buffer Pool中，flush链等待写入磁盘，就不能保证持久化。</p><p>方法： 在事务提交完成之前把该事务修改的所有页面都刷新到磁盘</p><p>问题： 1. 刷新整个数据页太浪费了，2. 随机IO刷新起来比较慢</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>把事务修改数据库的内容记录，系统重启的时候只需要redo log就行</p><p><strong>好处：</strong> 1. redo log 占用的空间小 2. redo log 是顺序写入磁盘的（按顺序写入log）</p><h3 id="redo-log-格式"><a href="#redo-log-格式" class="headerlink" title="redo log 格式"></a>redo log 格式</h3><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230824202827065.png" alt="image-20230824202827065"></p><p>spaceID 是 表空间ID</p><h4 id="简单的日志类型"><a href="#简单的日志类型" class="headerlink" title="简单的日志类型"></a>简单的日志类型</h4><p>物理日志：记录在某一个页的某个偏移量修改了几个字节的值和具体内容：MLOG_8BYTE</p><h4 id="复杂的日志类型"><a href="#复杂的日志类型" class="headerlink" title="复杂的日志类型"></a>复杂的日志类型</h4><p>一条INSERT语句，要向B+树插入数据，也要更新系统数据（比如系统表空间中页号为7的页面的Max Row ID属性），每处修改都记录一个log很浪费，完整记录全部修改内存为一条log很浪费，所以需要设置插入行格式的redo日志类型。</p><p>MLOG_COMP_REC_INSERT   MLOG_COMP_PAGE_CREATE等</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825100714639.png" alt="image-20230825100714639" style="zoom: 80%;" /><p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来</p><h3 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h3><h4 id="以组的形式插入redo-log"><a href="#以组的形式插入redo-log" class="headerlink" title="以组的形式插入redo log"></a>以组的形式插入redo log</h4><p>执行语句产的redo log需要分成若干个不可分割的组： 因为一些redo日志需要保证原子性，比如向聚簇索引插入一条记录产生的redo log是不可分割的。</p><ul><li><p>乐观插入：数据页剩余空间足够</p></li><li><p>悲观插入：数据页剩余空间不够，需要页分裂，甚至内节点也不够，非叶子节点也需要页分裂。这整个过程需要<strong>以组的形式记录log来保证原子性</strong></p></li></ul><p>标志：以MLOG_MULTI_REC_END结尾。</p><p>恢复：解析到标志，才是一组完整的redo日志，进行恢复</p><p>其他一条原子性的保证： type字段的第一个位是1</p><h4 id="对底层页面一次原子访问是Mini-Transaction-（mtr"><a href="#对底层页面一次原子访问是Mini-Transaction-（mtr" class="headerlink" title="对底层页面一次原子访问是Mini-Transaction （mtr"></a>对底层页面一次原子访问是Mini-Transaction （mtr</h4><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825103038372.png" alt="image-20230825103038372" style="zoom: 50%;" /><h3 id="redo-log写入过程"><a href="#redo-log写入过程" class="headerlink" title="redo log写入过程"></a>redo log写入过程</h3><p>redo log block ：mtr生成的redo日志存在512字节的页中，称为block</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230825103501535.png" alt="image-20230825103501535"></p><p><strong>redo log buffer</strong>的连续内存空间，划分为若干连续的redo log block：</p><ul><li>每个 mtr 运行过程中产生的日志先暂时存到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志再全部复制到 log buffer 中。</li></ul><h2 id="22-redo-log-（下）"><a href="#22-redo-log-（下）" class="headerlink" title="22. redo log （下）"></a>22. redo log （下）</h2><h3 id="redo-log-文件"><a href="#redo-log-文件" class="headerlink" title="redo log 文件"></a>redo log 文件</h3><p>log buffer需要持久化，</p><h4 id="日志刷盘时机："><a href="#日志刷盘时机：" class="headerlink" title="日志刷盘时机："></a>日志刷盘时机：</h4><ol><li>log buffer空间不足 </li><li>事务提交： 可以不提交buffer pooll页面，但是为了持久性不许要提交redo log</li><li>后台线程每秒都刷</li><li>开关服务器 6.checkpoint</li></ol><h4 id="具体文件组"><a href="#具体文件组" class="headerlink" title="具体文件组"></a>具体文件组</h4><p>SHOW VARIABLES LIKE ‘datadir’ 查看mysql的数据目录</p><p>ib_logfile0 和 ib_logfile1 的文件记录刷新的log</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230825105401574.png" alt="image-20230825105401574"></p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825110426049.png" alt="image-20230825110426049" style="zoom:50%;" /><h3 id="Log-Sequeue-Number-（lsn"><a href="#Log-Sequeue-Number-（lsn" class="headerlink" title="Log Sequeue Number （lsn"></a>Log Sequeue Number （lsn</h3><p>日志序列号lsn，InnoDB的初始lsn是8704</p><p>要存log的话，回想一下：log是以mtr方式存入的，单位是512B的log Block，其中Block有header和trailer</p><h4 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h4><p>刷新到磁盘中的redo log的全局变量</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825112606149.png" alt="image-20230825112606149" style="zoom:50%;" /><p>lsn的值在读入log buffer的时候增长，flushed_to_disk_lsn的值在刷新到磁盘时往后增长，两值相同说明log buffer中的redo log都刷新到磁盘中了</p><h4 id="flush链中的lsn"><a href="#flush链中的lsn" class="headerlink" title="flush链中的lsn"></a>flush链中的lsn</h4><p>回想之前mtr执行后，redo log写入log buffer，还有修改的页面加入到Buffer Pool中的flush链表中；</p><p>flush链中页面的更新： 首次加入写一个lsn， 每次修改页面会更新lsn为新的</p><p>顺序是<strong>按照初始的lsn（oldest_modification）排序</strong>，更新的页面会更新newest_modification, 但不用更新链表的顺序</p><h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><p>redo log可覆盖操作： 当对应的脏页已经刷新到磁盘中</p><p>checkpoint_lsn: 系统中可以被覆盖的redo log总量是多少，初始是8704</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230825115710329.png" alt="image-20230825115710329"></p><p><strong>批量刷脏页</strong>： lsn增长过快，需要线程同步从flush 链表中把最早修改的脏页刷新到磁盘，然后去做checkpoint</p><p>SHOW ENGINE INNODB STATUS 命令查看当前 InnoDB 存储引擎中的<strong>各种 LSN 值的情况</strong></p><h3 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h3><p>可以设置： </p><p>1 事务提交时立即磁盘同步redo log </p><p>0 不交，等待后台线程做</p><p>2 写到<strong>操作系统的缓冲区</strong>，专业操作系统没挂就能保证事务的持久性</p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><strong>起点</strong> ： 从checkpoint_lsn开始读取redo log （最近的checkpoint）</p><p><strong>终点</strong> ： 最后一条log，也就是按顺序下去block不为512的那个最后block为止</p><p><strong>恢复</strong> ： 按照SpaceID和page number哈希表放在一起加速读取，避免一些随机IO</p><ul><li>每个页面的File Header部分都有一个FIL_PAGE_LSN记录最近一次修改页面的lsn</li></ul><h2 id="undo-log-（上"><a href="#undo-log-（上" class="headerlink" title="undo log （上"></a>undo log （上</h2><p>保证原子性，需要把旧数据记录下来，以用于事务的回滚</p><h3 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h3><p>只读事务：只有在第一次对用户创建的临时表进行CUD时，才会分配一个事务id</p><p>读写事务： 只有在第一次对某个表（包括用户创建的临时表）进行CUD时，才会分配事务id</p><p><strong>事务id递增</strong>： 页号为5的页面一个Max Trx ID 的属性处，每次分配自增1</p><ul><li>聚簇索引的记录会保存用户数据外，还有自动添加的trx_id代表改动语句所在的事务id</li></ul><h3 id="undo-log的格式"><a href="#undo-log的格式" class="headerlink" title="undo log的格式"></a>undo log的格式</h3><p>每条记录一次改动，就对应一个undo日志，编号undo no</p><p>undo日志记录在类型为FIL_PAGE_UNDO_LOG页中</p><h4 id="INSERT操作"><a href="#INSERT操作" class="headerlink" title="INSERT操作"></a>INSERT操作</h4><p>TRX_UNDO_INSERT_REC类型</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825160853833.png" alt="image-20230825160853833" style="zoom:80%;" /><ul><li>需要把主键包含的所有列的长度和真实值记录下来；</li><li>只需要考虑向聚簇索引插入记录时的情况记录就好了，因为回滚的时候只要知道记录的主键信息，然后回滚聚簇索引的时候顺带着把二级索引记录也回滚了</li></ul><p>例子：INSERT INTO undo_demo(id, key1, col)<br> VALUES (1, ‘AWM’, ‘狙击枪’), (2, ‘M416’, ‘步枪’);</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825161636437.png" alt="image-20230825161636437" style="zoom:50%;" /> <img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825161645429.png" alt="image-20230825161645429" style="zoom:50%;" /></p><ul><li>数据页每条记录中的roll_pointer,就是指向记录对应的undo日志的一个指针</li></ul><h4 id="DELETE操作"><a href="#DELETE操作" class="headerlink" title="DELETE操作"></a>DELETE操作</h4><p>删除的过程： </p><ol><li><p>deletd mark阶段： 记录的delete_mask标识位设置为1，</p></li><li><p>purge阶段：  <code>删除的事务提交后</code>，专门的线程来把记录从 正常记录链表 中移除，加入到 垃圾链表 中</p></li></ol><p>所以要处理回滚，只需要考虑第一个阶段</p><p>TRX_UNDO_DEL_MARK_REC</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230825163029255.png" alt="image-20230825163029255" style="zoom:80%;" /><ul><li>old trx_id和old roll_pointer属性，可以帮助找到记录修改前一条的undo日志<br>利用这些 可以组成<strong>记录的一个版本链</strong></li><li>索引列各列信息&lt;pos, len, value&gt; ，在事务提交后真正删除阶段用</li></ul><h4 id="UPDATE操作"><a href="#UPDATE操作" class="headerlink" title="UPDATE操作"></a>UPDATE操作</h4><h5 id="不更新主键"><a href="#不更新主键" class="headerlink" title="不更新主键"></a>不更新主键</h5><p>如果更新的<strong>每个列</strong>前后存储空间一样大，可以就地更新</p><p><strong>任何列</strong>更新前后存储空间大小不一致，需要记录删掉后（真删除，不是delete mark）新记录插入页面中； 新添加的空间可以重用垃圾链表空间，或者页分裂</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826150530261.png" alt="image-20230826150530261"></p><ul><li>n_updated 表示将有几个列被更新，后边跟着的 &lt;pos, old_len, old_value&gt;<br>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</li></ul><h5 id="更新主键"><a href="#更新主键" class="headerlink" title="更新主键"></a>更新主键</h5><p>意味着记录在聚簇索引的位置会发送改变</p><ol><li>旧记录进行delete mark操作</li><li>更新后列的值创建一条新纪录，并插入聚簇索引中</li></ol><p>所以会记录额外的TRX_UNDO_DEL_MARK_REC 和 TRX_UNDO_INSERT_REC 两条redo log</p><h2 id="23-undo-log-（下）"><a href="#23-undo-log-（下）" class="headerlink" title="23. undo log （下）"></a>23. undo log （下）</h2><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p>List Node结构：表空间中通过一个页的页号和在页内的偏移量唯一定位一个节点的位置</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826152109320.png" alt="image-20230826152109320"> </p><p>基结点管理List Node： </p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826152129088.png" alt="image-20230826152129088"></p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826152135283.png" alt="image-20230826152135283"></p><h3 id="undo-log页面类型"><a href="#undo-log页面类型" class="headerlink" title="undo log页面类型"></a>undo log页面类型</h3><p>表空间中的FIL_PAGE_UNDO_LOG类型页面存储redo log</p><p>这类页有有特有的Undo Page Header</p><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230826152534627.png" alt="image-20230826152534627" style="zoom:50%;" /><p><strong>TRX_UNDO_PAGE_TYPE</strong> ：本页面准备存储什么种类的 undo日志</p><ol><li>TRX_UNDO_INSERT类型， 2. TRX_UNDO_UPDATE 类型</li></ol><ul><li>前者只存Insert，后者存其他，因为后者需要提供MVCC服务不能直接删除</li></ul><p><strong>TRX_UNDO_PAGE_NODE</strong> ：代表一个 List Node 结构</p><h3 id="undo-log页面链表"><a href="#undo-log页面链表" class="headerlink" title="undo log页面链表"></a>undo log页面链表</h3><h4 id="单个事务："><a href="#单个事务：" class="headerlink" title="单个事务："></a>单个事务：</h4><p>一个事务多个undo log，可能放在多个页中，需要用<strong>TRX_UNDO_PAGE_NODE属性连成一个链表</strong>，其中第一个undo页面叫first undo page，除了记录 undo page header以外，要记录一些管理信息，也就是<code>undo log segment header</code></p><p>最多四个链表，按需分配：简单表和临时表的分别两个insert undo链表，upadate undo链表，</p><h4 id="多事务："><a href="#多事务：" class="headerlink" title="多事务："></a>多事务：</h4><p>不同事务产生的undo log写入不同的undo页面链表</p><h3 id="undo-log-写入具体过程"><a href="#undo-log-写入具体过程" class="headerlink" title="undo log 写入具体过程"></a>undo log 写入具体过程</h3><blockquote><p>Undo Log Segment</p></blockquote><p>每个<strong>undo页面链表</strong>都有一个<strong>对应的段</strong> <code>Undo Log Segment</code>，****，也就是说链表的页面都是从这个段中申请的。</p><p>所以在first undo page有关于这个段的信息，Undo Log segment Header部分</p><p>没有被重用的 Undo页面 链表来说，链表的第一个页面，也就是 first undo page 在真正写入 undo日志前，会填充 Undo Page Header 、 Undo Log Segment Header 、Undo Log Header 这3个部分，之后才开始正式写入 undo日志 。</p><h3 id="重用-undo页面"><a href="#重用-undo页面" class="headerlink" title="重用 undo页面"></a>重用 undo页面</h3><p>一般一个页面链表只存一个事务产生的一组undo日志</p><p>每次开启事务都创建新的undo页面链表存undo log是一种浪费，事务提交后可以重用undo页面链表。</p><p><strong>重用条件</strong>：</p><ol><li>该链表只包含<code>一个undo页面</code>， 2. 该undo页面已经使用的空间小于整页面空间的3&#x2F;4</li></ol><p><strong>重用分类</strong>：</p><p>insert undo链表 ，事务提交后重用可以覆盖undo log</p><p>update undo链表， 事务提交后不能删除，往后写undo log。 </p><h3 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h3><p>一个事务最多可以分配4个undo 页面链表，不同事务不同。</p><p>设置了一种统一放<strong>Rollback Segment Header页面</strong>， 存放每个undo页面链表的first undo page 页号<strong>（undo slot）</strong></p><p><strong>回滚段</strong>Rollback Segment ：每个Rollback Segment Header页面对应一个段，</p><blockquote><p>好像分配页面必须要有对应的段??? 也就是物理存址需要有逻辑上对应的操作</p><p>这里的回滚段就是对应了 <strong>记录了所有回滚链的第一个页的页号</strong> 的页</p><p>前面的undo log segment 就是对应了 undo log 页面的链表</p></blockquote><p>从回滚段中省去undo页面链表： 分配FIL_NULL状态的undo slot。</p><p>一个Rollback Segment Header页面对应<strong>1024个undo slot</strong></p><h5 id="回滚段的数量和分类"><a href="#回滚段的数量和分类" class="headerlink" title="回滚段的数量和分类"></a>回滚段的数量和分类</h5><p>系统一共有<strong>128 个回滚段</strong>，在系统表空间的第 5 号页面中存储了128个 Rollback Segment Header<br>页面地址，</p><p>这些回滚段分类： 0号是系统表空间中的，1-32是在临时表空间的，33-127号是既可以在系统表空间中，也可以在自己配置的undo表空间中</p><p><strong>分类的原因：</strong>在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志</p><h3 id="为事务分配undo页面链表的过程"><a href="#为事务分配undo页面链表的过程" class="headerlink" title="为事务分配undo页面链表的过程"></a>为事务分配undo页面链表的过程</h3><p>系统5号页面分配回滚段，查看回滚段的两个cached链表（insert 和 update）有没有缓存的undo slot，没有就在Rollback Segment Header页面找一个可用的undo slot分配给该事务，分配一个undo log segment，从中申请一个页面作为undo 页面的first undo page。然后事务就把undo log 写到这个页面链表了</p><p>如果也有临时表的改动，那也要相同的分配临时表的回滚段</p><h2 id="24-事务的隔离级别与MVCC"><a href="#24-事务的隔离级别与MVCC" class="headerlink" title="24. 事务的隔离级别与MVCC"></a>24. 事务的隔离级别与MVCC</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>隔离性： 在某个事务对某个数据进行访问时，其他事务应该排队。</p><p>性能： CS架构需要同时处理多个会话</p><h4 id="事务并发的问题："><a href="#事务并发的问题：" class="headerlink" title="事务并发的问题："></a>事务并发的问题：</h4><p><strong>脏写</strong>：一个事务修改了另一个未提交事务修改过的数据 </p><p><strong>脏读</strong>: 一个事务读到了<strong>另一个未提交事务</strong>修改过的数据</p><p><strong>不可重复读 ：</strong> 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</p><p><strong>幻读:</strong> 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。</p><ul><li>从下往上依次严重</li></ul><blockquote><p>不可重复读：重点是修改，同一事务，两次读取到的数据不一样。<br>幻读：重点在于新增或者删除，同样的条件 , 第 1 次和第 2 次读出来的记录数不一样。<br>脏读：强调的是第二个事务读到的不够新。</p></blockquote><h4 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h4><p>READ UNCOMMITTED ：未提交读。<br>READ COMMITTED ：已提交读。<br>REPEATABLE READ ：可重复读。<br>SERIALIZABLE ：可串行化。</p><p><img src="/imgs/$%7Bfiilename%7D/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/image-20230826190649111.png" alt="image-20230826190649111"></p><h4 id="MySQL中支持的4中隔离级别"><a href="#MySQL中支持的4中隔离级别" class="headerlink" title="MySQL中支持的4中隔离级别"></a>MySQL中支持的4中隔离级别</h4><p>MySQL默认支持<strong>REPEATABLE READ</strong> ,并且是可以禁止幻读问题的发生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="版本链："><a href="#版本链：" class="headerlink" title="版本链："></a><strong>版本链</strong>：</h4><p>InnoDB每条记录的必要两个隐藏列 trx_id、 roll_pointer</p><p>其中roll_pointer之前一个操作undo log，如果前一个是insert undo，并且事务提交了，他的undo log segment被系统回收了，就会指向空的。其中第一个字节标识类型，1代表inset undo，看到就可以不用管了</p><p>随着更新次数增加，<strong>所有版本的roll_pointer属性连成一个链表，叫做版本连</strong>，头结点是当前记录的值</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的<strong>最新</strong>版本就好了；</p><p>对于使用 SERIALIZABLE 隔离级别的事务来说， InnoDB 规定使用<strong>加锁</strong>的方式来访问记录；</p><p>READ COMMITTED 和 REPEATABLE READ 隔离级别不一定能读取最新版本的记录。（加入另一个事务已经修改记录但是尚未提交，不能读取最新版本的记录）</p><ul><li>需要判断一下版本链中的哪个版本是当前事务可见的，设计了版本的ReadView：</li></ul><ol><li>m_ids:在生成 ReadView 时当前系统中活跃的读写事务的事务id列表</li><li>min_trx_id</li><li>max_trx_id</li><li>creator_trx_id : 生成这个ReadView的事务id</li></ol><ul><li>通过当前版本的ReadView，判断判断trx_id可见性：</li></ul><ol><li><p>trx_id&#x3D; creator_trx_id 自己访问，可以</p></li><li><p>&lt; min_trx_id trx_id 比当前最小的还小，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，可以 </p></li><li><p>&gt; max_trx_id  比当前的最大的还新，不行</p></li><li><p>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，<strong>如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问</strong>；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</p></li></ol><p>READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们<strong>生成ReadView的</strong><br><strong>时机不同</strong></p><p>READ COMMITTED —— 每次读取数据前都生成一个ReadView</p><p>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</p><h4 id="MVCC小结"><a href="#MVCC小结" class="headerlink" title="MVCC小结"></a>MVCC小结</h4><p>MVCC （Multi-Version Concurrency Control ，多版本并发控制）：使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p><p>READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同：</p><p>生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p><h3 id="purge前后"><a href="#purge前后" class="headerlink" title="purge前后"></a>purge前后</h3><p> update undo 由于还需要支持 MVCC ，不能立即删除掉，只是delete mark；</p><p>在确定系统中包含<strong>最早产生的那个 ReadView 的事务不会再访问某些 update undo日志</strong> 以及被打了删除标记的记录后，有一个后台运行的 purge线程 会把它们真正的删除掉。</p><h2 id="25-锁"><a href="#25-锁" class="headerlink" title="25. 锁"></a>25. 锁</h2><p>事务并发在读情况下不会对记录产生影响，但是脏写的问题是每个隔离级别都不允许的；</p><p>一般用锁实现事务执行同步</p><p>每条记录在事务修改时都要检查有没有锁结构，锁结构：trx信息、 is_waiting标志</p><blockquote><p>这里锁结构是对应记录和事务的，如果前一个事务锁着，另一个事务要拿到这条记录要生成了一个 锁结构 与这条记录关联，不过 锁结构 的is_waiting 属性值为 true ，表示当前事务需要等待</p></blockquote><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230828102250590.png" alt="image-20230828102250590" style="zoom:67%;" /><h3 id="解决并发事务问题的两种方式"><a href="#解决并发事务问题的两种方式" class="headerlink" title="解决并发事务问题的两种方式"></a>解决并发事务问题的两种方式</h3><ol><li>读操作利用MVCC控制，写操作加锁： 效率高</li><li>读 写操作都加锁：但是幻读的幻影记录在读之前不存在，不知道给谁加锁</li></ol><h4 id="一致性无锁读："><a href="#一致性无锁读：" class="headerlink" title="一致性无锁读："></a><strong>一致性无锁读</strong>：</h4><p>一般的SELECT语句在在 READ COMMITTED 、 REPEATABLE READ 隔离级别下都算是 一致性读</p><h4 id="锁定读："><a href="#锁定读：" class="headerlink" title="锁定读："></a><strong>锁定读</strong>：</h4><p>既要允许读 读不受影响，又要使得写 写， 读 写， 写 读 互相阻塞，需要设计锁</p><p>用锁来解决 脏读、不可重复读、幻读 问题</p><p><code>共享锁S</code>：<strong>读取记录</strong>需要获得锁； <code>独占锁X</code>： <strong>改动记录</strong>需要获得锁</p><blockquote><p>S锁是兼容的，X和S是不兼容，X和X是不兼容的：</p><p>假如事务 T1 首先获取了一条记录的 S锁 之后，事务 T2 接着也要访问这条记录：<br>如果事务 T2 想要再获取一个记录的 S锁 ，那么事务 T2 也会获得该锁，也就意味着事务 T1 和 T2 在该记录上同时持有 S锁 。<br>如果事务 T2 想要再获取一个记录的 X锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S锁 释放掉。<br>如果事务 T1 首先获取了一条记录的 X锁 之后，那么不管事务 T2 接着想获取该记录的 S锁 还是 X锁 都会被阻塞，直到事务 T1 提交。</p></blockquote><p>可以锁定读语句： </p><ol><li><p>对读取的记录加 S锁 ：不允许写<br>SELECT … LOCK IN SHARE MODE;</p></li><li><p>对读取的记录加 X锁 ：不允许读 写<br>SELECT … FOR UPDATE;</p></li></ol><h4 id="读操作："><a href="#读操作：" class="headerlink" title="读操作："></a>读操作：</h4><ol><li>DELETE: <strong>X锁读</strong> 取记录在B+树的位置，<strong>X锁写</strong> delete mark</li><li>UPDATE: <ol><li>不修改主键 不修改存储空间：<strong>X锁读</strong> B+树定位，<strong>X锁写</strong> 修改原纪录</li><li>不修改主键 至少有列占用存储空间修改前后变化： <strong>X锁读</strong> B+树定位， <strong>X锁写</strong> 彻底删除记录，<strong>INSERT 隐形锁</strong> 新插入记录</li><li>修改主键 相当于 DELETE后INSERT操作</li></ol></li><li>INSERT： 一般不加锁，用<strong>隐式锁</strong>保护</li></ol><h3 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h3><p>锁的粒度 包括 行锁 表锁</p><h4 id="意向锁："><a href="#意向锁：" class="headerlink" title="意向锁："></a>意向锁：</h4><p>意向共享锁：IS 事务给记录上S锁，需要在表加SI锁</p><p>意向独占锁：IX 事务给记录上X锁，需要在表加XI锁</p><p>IS、IX锁是表级锁，它们的提出仅仅<strong>为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否</strong><br><strong>被上锁</strong>，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</p><h3 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h3><h4 id="其他引擎的锁"><a href="#其他引擎的锁" class="headerlink" title="其他引擎的锁"></a>其他引擎的锁</h4><p>对于 MyISAM 、 MEMORY 、 MERGE 这些存储引擎来说，它们<strong>只支持表级锁，而且这些引擎并不支持事务</strong>，所以使用这些存储引擎的锁一般都是<strong>针对当前会话来</strong>说的。比方说在 Session 1 中对一个表执行 SELECT 操作，就相当于为这个表加了一个表级别的 S锁 ，如果在 SELECT 操作未完成时， Session 2 中对这个表执行 UPDATE 操作，相当于要获取表的 X锁 ，此操作会被阻塞，直到 Session 1 中的 SELECT 操作完成，释放掉表级别的 S锁 后，Session 2 中对这个表执行 UPDATE 操作才能继续获取 X锁 ，然后执行具体的更新语句。</p><ul><li>这些引擎的表在同时只允许一个会话对表写操作，一般用在大<strong>部分只读、或者单用户</strong>的场景</li></ul><h4 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h4><h5 id="表锁："><a href="#表锁：" class="headerlink" title="表锁："></a>表锁：</h5><ol><li>表级别的 S锁 、 X锁：<br>在对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时， InnoDB 存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。</li></ol><p>ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如 SELECT 、 INSERT 、 DELETE 、 UPDATE 的语句会发生阻塞。 </p><p>不过请尽量避免在使用 InnoDB 存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。 InnoDB 的厉害之处还是实现了更细粒度的行锁</p><ol start="2"><li><p>表级别的 IS锁 、 IX锁</p></li><li><p>表级别的 AUTO-INC锁： 实现AUTO_INCREMENT修饰的列递增赋值：</p><p>一种方式：在执行插入语句时，表级别加AUTO_INC锁，自增列分配递增值，然后释放AUTO_INC锁</p><p>另一种： 采用轻量级的锁，原理差不多，但是可以避免锁定表，提升插入性能</p></li></ol><h5 id="行锁："><a href="#行锁：" class="headerlink" title="行锁："></a>行锁：</h5><ol><li><p><strong>Record Locks</strong> ，单条记录锁，类型名LOCK_REC_NOT_GAP</p></li><li><p><strong>Gap Locks</strong>， 防止幻影记录提出来的，锁住主键的一个间隙，防止插入新纪录，类型名为LOCK_GAP<br>比如对Supremum记录插入gap锁，就可以防止（最后一个记录主键，+无穷）范围插入记录</p></li><li><p><strong>Next-Key Locks</strong>, next-key锁 的本质就是一个 正经记录锁 和一个 gap锁 的合体，它既能保护该条记录，又能阻止别的事务<br>将新记录插入被保护记录前边的 间隙 。</p></li><li><p><strong>LOCK_INSERT_INTENTION</strong> ， 插入意向锁 , 插入位置被gap锁锁住， 需要等待。</p><p>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。 就是记录一下</p></li><li><p><strong>隐式锁</strong>：INSERT操作不会自己加锁，而是依靠<strong>trx_id</strong>，别的事务对这条记录加S锁或X锁时，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构进入等待</p></li></ol><h4 id="InnoDB的锁结构"><a href="#InnoDB的锁结构" class="headerlink" title="InnoDB的锁结构"></a>InnoDB的锁结构</h4><p>以下情况，可以放到一个锁结构中： </p><ol><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ol><img src="/imgs/$%7Bfiilename%7D/Mysql数据库原理/image-20230828143936242.png" alt="image-20230828143936242" style="zoom:67%;" /><p>表锁／行锁信息 ：</p><p>表锁：<br>记载着这是对哪个表加的锁，还有其他的一些信息。</p><p>行锁：<br>记载了三个重要的信息：<br>Space ID ：记录所在表空间。<br>Page Number ：记录所在页号。<br>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比<br>特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 n_bits 属<br>性代表使用了多少比特位。</p><p>type_mode ：<br>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux - Linux网络编程</title>
      <link href="/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/11/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Linux服务器 网络编程</p><h2 id="1-Linux系统编程入门"><a href="#1-Linux系统编程入门" class="headerlink" title="1. Linux系统编程入门"></a>1. Linux系统编程入门</h2><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>gcc和g++都是GCC组织的编译器 ，套件和库；一般用gcc和g++两个编译器</p><ul><li><p>gcc不能自动和cpp程序库链接，一般编译和链接都用g++，因为g++会调用gcc</p></li><li><p>gcc编译c文件 gcc test.c -o app 然后.&#x2F;app<br>其中-o 指明输出文件名</p></li><li><p>预处理 编译 汇编 链接 </p></li><li><p>-c 只是汇编不链接,生成目标文件“.o”  test.o</p><p>-S 只是编译不汇编,生成汇编代码  test.s</p><p>-E 只进行预编译,不做其他处理    test.i</p><p><strong>后置</strong> ：</p></li><li><p>-D 指定宏 配合#ifdef DEBUG #endif<br>g++ test.cpp -o test -DDEBUG <em>指定宏DEGUB</em></p></li><li><p>-I 指定include包含文件搜索目录</p></li><li><p>-L 指定编译时 库 的路径</p></li><li><p>-l 指定编译时 使用的 库</p></li></ul><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul><li><p>代码仓库，保存一些变量、函数、类等；编写差不多，但不能单独运行；</p></li><li><p>静态库在程序的链接阶段被复制到程序中；动态库在程序运行时，加载到内存中供程序调用</p></li><li><p>好处：1. 代码保密（cpp反汇编还原度低）；2. 方便部署和分发</p></li><li><p><strong>工作原理</strong>：静态库GCC链接时，把静态库代码打包到可执行程序中；<br>动态度GCC链接时，动态库代码<strong>不会</strong>被打包到可执行程序中，运行时加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系；系统加载可执行代码时，需要知道库的名字和绝对路径，一般用<strong>动态载入器获取绝对路径，然后找到库文件载入内存中</strong><br><strong>优缺点比较</strong>：</p><ul><li>静态库被打包到应用程序 ；加载速度快；<br>但消耗资源，浪费内存； 更新速度慢；</li><li>动态库 可以进程资源共享（共享库）；更新部署简单；控制加载时间；<br>但加载速度慢；发布程序需要提供依赖的动态库；</li><li>库比较小用静态 大用动态</li></ul></li></ul><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><ul><li><p>命名规则 Linux:    libxxx.a<br>Win :     libxxx.lib</p></li><li><p>制作静态库</p><ol><li><p>gcc获得.o文件 - c</p></li><li><p>将 .o文件打包，使用ar工具 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a  xxx.o xxx.o</span><br></pre></td></tr></table></figure><p>静态库移动到lib目录下</p></li><li><p>编译main程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -I ./include/ -L ./lib/ -l xxx</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><ul><li><p>命名规则 Linux:   libxxx.so 在Linux下是一个可执行文件<br>Win :    libxxx.dll</p></li><li><p>制作动态库</p><ol><li><p>gcc得到.o文件，得到与位置无关的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC a.c b.c</span><br></pre></td></tr></table></figure><p>-fpic 用于编译阶段，产生的代码没有绝对地址，全部用相对地址，这正好满足了共享库的要求，共享库被加载时地址不是固定的。如果不加-fpic ，那么生成的代码就会与位置有关，当进程使用该.so文件时都需要重定位，且会产生成该文件的副本，每个副本都不同，不同点取决于该文件代码段与数据段所映射内存的位置</p></li><li><p>gcc得到动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure></li><li><p>编译mian程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app2 -I ./include/ -L ./lib/ -l calc</span><br></pre></td></tr></table></figure><p>运行时加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系；系统加载可执行代码时，需要知道库的名字和绝对路径，一般用<strong>动态载入器获取绝对路径，然后找到库文件载入内存中</strong></p><ol><li><p>窗口级别 直接export配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klchen@vmware:~/WinToUbuntu/lession06/library$ export LD_LIBRARY_PATH=$LD_LIBRAY_PATH:/home/klchen/WinToUbuntu/lession06/library/lib</span><br></pre></td></tr></table></figure></li><li><p>用户级别 在用户中配置.bashrc环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRAY_PATH:/home/klchen/WinToUbuntu/lession06/library/lib</span><br><span class="line"></span><br><span class="line">. .bashrc或者source .bashrc</span><br></pre></td></tr></table></figure></li><li><p>系统级别 在etc&#x2F;profile中export</p></li></ol><ul><li>还有&#x2F;etc&#x2F;ld.so.cache文件列表添加的方式</li></ul></li></ol></li></ul><h3 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。</p><p>◼Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><ul><li>make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，VisualC++的nmake，Linux下GNU的make。</li></ul><h4 id="makefile文件书写规则"><a href="#makefile文件书写规则" class="headerlink" title="makefile文件书写规则"></a>makefile文件书写规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span> </span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> <span class="comment">#clean操作在make不会被执行，需要手动make clean</span></span><br><span class="line"> <span class="comment">#表示clean是一个为目标，不会生成文件</span></span><br><span class="line"> .PHONY:clean</span><br><span class="line"> clean:</span><br><span class="line"> rm <span class="variable">$(objs)</span> -f</span><br></pre></td></tr></table></figure><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>​调试工具，是许多类Unix系统中的标准开发环境</p><ul><li><p>主要功能：断点调试，监控，改BUG</p></li><li><p>准备工作 在生成可执行文件时添加</p><ol><li>-O关掉优化选项</li><li>-g打开调试选项：可执行文件中加入源代码信息，第几条机器指令对应源代码几行</li><li>-Wall打开所有warning</li></ol></li><li><p>gdb基本操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应该要保证可执行文件和源文件都在</span></span><br><span class="line">gdb 目标程序</span><br></pre></td></tr></table></figure></li><li><p>断点操作</p><p><strong>退出gdb后断点全部失效</strong></p></li><li><p>调试命令 </p><p>bt打印堆栈</p></li></ul><h3 id="Linux系统的IO函数"><a href="#Linux系统的IO函数" class="headerlink" title="Linux系统的IO函数"></a>Linux系统的IO函数</h3><p> 标准C库IO函数带有缓冲区，有FILE*fp文件指针，减少写磁盘次数；但是Linux系统自带的IO没有缓冲区</p><ul><li><p>在网络通信时候用linux系统自带的IO；</p></li><li><p>在磁盘读写用标准C库IO；</p></li><li><p>FILE类型 文件描述符</p></li><li><p>库函数说明查找</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Linux库函数</span></span><br><span class="line">man 2 xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标准C库</span></span><br><span class="line">man 3 xxx</span><br></pre></td></tr></table></figure></li></ul><h5 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h5><ul><li><p>用man操作打开函数的说明文档，可以查找头文件，看IO</p><p>man 1是普通的shell命令比如ls，<br> man 2是系统调用比如open，write说明，<br>    man 3是函数说明，一些库函数</p></li></ul><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>​       int open(const char *pathname, int flags);的说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">打开文件操作</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 打开一个已经存在的文件</span><br><span class="line">   <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line">       参数：</span><br><span class="line"></span><br><span class="line">      - pathname：要打开的文件路径</span><br><span class="line">        - flags：对文件的操作权限设置还有其他的设置</span><br><span class="line">              - flO_RDONLY,  O_WRONLY,  O_RDWR  这三个设置是互斥的</span><br><span class="line">      - 返回值：返回一个新的文件描述符，如果调用失败，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;作用：打印errno对应的错误描述</span><br><span class="line">       s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span><br><span class="line">       创建一个新的文件</span><br><span class="line">   <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="comment">/*man 1是普通的shell命令比如ls，</span></span><br><span class="line"><span class="comment">    man 2是系统调用比如open，write说明，</span></span><br><span class="line"><span class="comment">    man 3是函数说明，一些库函数。        </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;的说明参数：</span><br><span class="line">    - pathname：要创建的文件的路径</span><br><span class="line">    - flags：对文件的操作权限和其他的设置</span><br><span class="line">        - 必选项：O_RDONLY,  O_WRONLY, O_RDWR  这三个之间是互斥的，就是权限的设置只读、只写、读写</span><br><span class="line">        - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">    - mode：八进制的数，表示创建出的新的文件的操作权限，比如：<span class="number">0775</span></span><br><span class="line">    最终的权限是：mode &amp; ~umask</span><br><span class="line">    <span class="number">0777</span>   -&gt;   <span class="number">111111111</span></span><br><span class="line">&amp;   <span class="number">0775</span>   -&gt;   <span class="number">111111101</span></span><br><span class="line">----------------------------</span><br><span class="line">                <span class="number">111111101</span></span><br><span class="line">按位与：<span class="number">0</span>和任何数都为<span class="number">0</span></span><br><span class="line">umask的作用就是抹去某些权限，也可以自己</span><br><span class="line"></span><br><span class="line">flags参数是一个<span class="type">int</span>类型的数据，占<span class="number">4</span>个字节，<span class="number">32</span>位。</span><br><span class="line">flags <span class="number">32</span>个位，每一位就是一个标志位。</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>,O_RDONLY|O_CREAT,<span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="line">        - buf：需要读取数据存放的地方，数组的地址（传出参数）</span><br><span class="line">        - count：指定的数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：</span><br><span class="line">            &gt;<span class="number">0</span>: 返回实际的读取到的字节数</span><br><span class="line">            =<span class="number">0</span>：文件已经读取完了</span><br><span class="line">        - 失败：<span class="number">-1</span> ，并且设置errno</span><br></pre></td></tr></table></figure><h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="line">        - buf：要往磁盘写入的数据，数据</span><br><span class="line">        - count：要写的数据的实际的大小</span><br><span class="line">          write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    返回值：</span><br><span class="line">        成功：实际写入的字节数</span><br><span class="line">        失败：返回<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure><p>例子：读写复制文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//open打开资源文件</span></span><br><span class="line">    <span class="type">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建拷贝文件</span></span><br><span class="line">    <span class="type">int</span> destfd = open(<span class="string">&quot;copy.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(destfd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//频繁的读写操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        write(destfd,buf,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(srcfd);</span><br><span class="line">    close(destfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lseek移动文件指针偏移"><a href="#lseek移动文件指针偏移" class="headerlink" title="lseek移动文件指针偏移"></a>lseek移动文件指针偏移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    标准C库的函数</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    Linux系统函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span><br><span class="line">        - offset：偏移量</span><br><span class="line">        - whence:</span><br><span class="line">            SEEK_SET</span><br><span class="line">                设置文件指针的偏移量</span><br><span class="line">            SEEK_CUR</span><br><span class="line">                设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line">            SEEK_END</span><br><span class="line">                设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">    返回值：返回文件指针的位置</span><br><span class="line">    作用：</span><br><span class="line">    <span class="number">1.</span>移动文件指针到文件头</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>获取当前文件指针的位置</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span>获取文件长度</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span>拓展文件的长度，当前文件<span class="number">10b</span>, <span class="number">110b</span>, 增加了<span class="number">100</span>个字节</span><br><span class="line">    lseek(fd, <span class="number">100</span>, SEEK_END)</span><br><span class="line">    注意：需要写一次数据</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><ul><li>终端操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat xxx</span><br></pre></td></tr></table></figure><h5 id="stat函数-lstat函数获取文件信息"><a href="#stat函数-lstat函数获取文件信息" class="headerlink" title="stat函数 lstat函数获取文件信息"></a>stat函数 lstat函数获取文件信息</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：操作的文件的路径</span><br><span class="line">        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;获取软链接的文件信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：操作的文件的路径</span><br><span class="line">        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure><p>例子：用stat实现ls -l</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟ls-l指令</span></span><br><span class="line"><span class="comment">//-rw-rw-r-- 1 klchen klchen 0 2月  18 14:01 a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过stat函数获取用户传入文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret=stat(argv[<span class="number">1</span>],&amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件类型和文件权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (st.st_mode &amp; __S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> __S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> __S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> __S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断文件访问权限</span></span><br><span class="line">    perms[<span class="number">1</span>]= st.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>]= st.st_mode &amp; S_IWUSR ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>]= st.st_mode &amp; S_IXUSR ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    perms[<span class="number">4</span>]= st.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>]= st.st_mode &amp; S_IWGRP ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>]= st.st_mode &amp; S_IXGRP ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    perms[<span class="number">7</span>]= st.st_mode &amp; S_IROTH ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>]= st.st_mode &amp; S_IWOTH ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>]= st.st_mode &amp; S_IXOTH ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬链接数</span></span><br><span class="line">    <span class="type">int</span> linkNum =st.st_nlink;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所有者</span></span><br><span class="line">    <span class="type">char</span> *fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所在组</span></span><br><span class="line">    <span class="type">char</span> *fileGrp=getgrgid(st.st_uid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> fileSize =st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取修改时间</span></span><br><span class="line">    <span class="type">char</span> *time = ctime(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime,time,<span class="built_in">strlen</span>(time) <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>,perms,linkNum,fileUser,fileGrp,fileSize,mtime,argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h4><h5 id="access判断文件权限或文件是否存在"><a href="#access判断文件权限或文件是否存在" class="headerlink" title="access判断文件权限或文件是否存在"></a>access判断文件权限或文件是否存在</h5><pre><code>#include &lt;unistd.h&gt;int access(const char *pathname, int mode);    作用：判断某个文件是否有某个权限，或者判断文件是否存在    参数：        - pathname: 判断的文件路径        - mode:            R_OK: 判断是否有读权限            W_OK: 判断是否有写权限            X_OK: 判断是否有执行权限            F_OK: 判断文件是否存在    返回值：成功返回0， 失败返回-1</code></pre><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在！！!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="chmod函数修改文件权限"><a href="#chmod函数修改文件权限" class="headerlink" title="chmod函数修改文件权限"></a>chmod函数修改文件权限</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="truncate修改文件尺寸"><a href="#truncate修改文件尺寸" class="headerlink" title="truncate修改文件尺寸"></a>truncate修改文件尺寸</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h4><h5 id="mkdir函数创建目录"><a href="#mkdir函数创建目录" class="headerlink" title="mkdir函数创建目录"></a>mkdir函数创建目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="chdir修改进程工作目录"><a href="#chdir修改进程工作目录" class="headerlink" title="chdir修改进程工作目录"></a>chdir修改进程工作目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br></pre></td></tr></table></figure><h5 id="getcwd获取当前目录"><a href="#getcwd获取当前目录" class="headerlink" title="getcwd获取当前目录"></a>getcwd获取当前目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h4><h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h5 id="readdir"><a href="#readdir" class="headerlink" title="readdir()"></a>readdir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class">//返回值 <span class="title">dirent</span>结构体的具体 元素 如图</span></span><br></pre></td></tr></table></figure><h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir()"></a>closedir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;<span class="comment">//此处 参数 关闭的是文件描述符</span></span><br></pre></td></tr></table></figure><h6 id="应用-统计某个目录下文件数量"><a href="#应用-统计某个目录下文件数量" class="headerlink" title="应用-统计某个目录下文件数量"></a>应用-统计某个目录下文件数量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFilenum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取某目录下所有文件个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否输入了文件名</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=getFilenum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平台文件的个数是 %d\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFilenum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>&#123;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    DIR *dir=opendir(path);</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="comment">//记录普通文件数</span></span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((ptr=readdir(dir))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略掉. 和..</span></span><br><span class="line">        <span class="type">char</span>* dname=ptr-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dname,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是目录递归</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            <span class="comment">//目录，需要继续读取目录</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="comment">//生成地址名称，字符串合并函数</span></span><br><span class="line">            <span class="built_in">sprintf</span>(newpath,<span class="string">&quot;%s/%s&quot;</span>,path,dname);</span><br><span class="line">            total+=getFilenum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">            <span class="comment">//普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件描述符操作函数"><a href="#文件描述符操作函数" class="headerlink" title="文件描述符操作函数"></a>文件描述符操作函数</h4><p>一个进程中有一个文件描述符表</p><h5 id="dup-文件描述符-复制-浅拷贝"><a href="#dup-文件描述符-复制-浅拷贝" class="headerlink" title="dup()文件描述符 复制 - 浅拷贝"></a>dup()文件描述符 复制 - 浅拷贝</h5><pre><code>#include &lt;unistd.h&gt;int dup(int oldfd);    作用：复制一个新的文件描述符    fd=3, int fd1 = dup(fd),    fd指向的是a.txt, fd1也是指向a.txt    从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</code></pre><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dup2-文件描述符-重定向"><a href="#dup2-文件描述符-重定向" class="headerlink" title="dup2()文件描述符 重定向"></a>dup2()文件描述符 重定向</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">    作用：重定向文件描述符,让newfd也来指向oldfd</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fcntl-函数-控制文件描述符"><a href="#fcntl-函数-控制文件描述符" class="headerlink" title="fcntl()函数 控制文件描述符"></a>fcntl()函数 控制文件描述符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。<span class="comment">//这个flag都可以|上O_NONBLOCK</span></span><br><span class="line">            <span class="comment">//设置fd非阻塞的方法，一般是fcntl+F_GETFL得到flag，|上O_NONBLOCK，然后fcntl+F_SETFL设置falg</span></span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改！！！！！</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            NONBLOK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。 导致当前进程线程被挂起-阻塞</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="comment">// 首先要获取文件描述符状态flag</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改完flag后替换进去</span></span><br><span class="line">    flag |= O_APPEND;   <span class="comment">// flag = flag | O_APPEND 此处用按位或来追加flag状态</span></span><br><span class="line">    <span class="type">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Linux多进程编程"><a href="#2-Linux多进程编程" class="headerlink" title="2. Linux多进程编程"></a>2. Linux多进程编程</h2><h3 id="2-1进程状态转换-终端指令"><a href="#2-1进程状态转换-终端指令" class="headerlink" title="2.1进程状态转换  -终端指令"></a>2.1进程状态转换  -终端指令</h3><ul><li><p>Linux中PBC的结构体task_struct</p></li><li><p>进程参数查看 ulimit -a </p></li><li><p>查看进程<br>ps aux &#x2F; ajx<br>a：显示终端上的所有进程，包括其他用户的进程<br>u：显示进程的详细信息<br>x：显示没有控制终端的进程<br>j：列出与作业控制相关的信息</p></li><li><p>STAT参数意义：<br>D 不可中断 Uninterruptible（usually IO）<br>R 正在运行，或在队列中的进程<br>S(大写) 处于休眠状态<br>T 停止或被追踪<br>Z 僵尸进程<br>W 进入内存交换（从内核2.6开始无效）<br>X 死掉的进程<br>&lt; 高优先级<br>N 低优先级<br>s 包含子进程</p><p>+ 位于前台的进程组</p></li><li><p>然后，实时显示进程动态<br>top<br>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令<br>执行后，可以按以下按键对显示的结果进行排序：<br>⚫ M 根据内存使用量排序<br>⚫ P 根据 CPU 占有率排序<br>⚫ T 根据进程运行时间长短排序<br>⚫ U 根据用户名来筛选进程<br>⚫ K 输入指定的 PID 杀死进程</p></li><li><p>杀死进程<br>kill [-signal] pid<br>kill –l 列出所有信号<br>kill –SIGKILL 进程ID<br>kill -9 进程ID<br>killall name 根据进程名杀死进程</p></li><li><p>进程号和进程组相关函数：<br>⚫ pid_t getpid(void);<br>⚫ pid_t getppid(void);  &#x2F;&#x2F;父进程的pid<br>⚫ pid_t getpgid(pid_t pid);</p></li></ul><h3 id="2-2进程创建"><a href="#2-2进程创建" class="headerlink" title="2.2进程创建"></a>2.2进程创建</h3><h5 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h5><ul><li><p>创建子进程</p><p>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;unistd.h&gt;</p><p>pid_t fork(void);<br>函数的作用：用于创建子进程。<br>返回值：<br>    fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。<br>    在父进程中返回创建的子进程的ID,<br>    在子进程中返回0<br>    如何区分父进程和子进程：通过fork的返回值。<br>    在父进程中返回-1，表示创建子进程失败，并且设置errno<br><br>父子进程之间的关系：<br>区别：<br>    1.fork()函数的返回值不同<br>        父进程中: &gt;0 返回的子进程的ID<br>        子进程中: &#x3D;0<br>    2.pcb中的一些数据<br>        当前的进程的id pid<br>        当前的进程的父进程的id ppid<br>        信号集<br><br>共同点：<br>    某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作<br>        - 用户区的数据<br>        - 文件描述符表<br><br>父子进程对变量是不是共享的？<br>    - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。<br>    - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。<br> 实际上，更准确来说，Linux 的 fork() 使用是通过<strong>写时拷贝 (copy- on-write)</strong> 实现。<br>写时拷贝是一种可以推迟甚至避免拷贝数据的技术。<br>内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。<br>只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。<br>也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。<br>注意：fork之后父子进程共享文件，<br>fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p></li><li><p>查看例子</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    <span class="comment">//判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">//如果大于0，返回的创建的是子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process,pid:%d,ppid:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num:%d\n&quot;</span>,num);</span><br><span class="line">        num+=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num +=10:%d\n&quot;</span>,num);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process,pid:%d,ppid:%d&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num:%d\n&quot;</span>,num);</span><br><span class="line">        num+=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num +=10:%d\n&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i:%d,pid:%d\n&quot;</span>,i,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父进程和子进程执行的代码块分别是以下图：</li><li><ol><li>子进程只执行以下的自己进程部分</li></ol></li><li><ol start="2"><li>父子进程代码段一样，但是按照pid来运行；</li></ol></li><li><ol start="3"><li>写操作之后，进程资源之间互不影响，共同部分运行的是各自的资源</li></ol></li></ul><h5 id="gdb调试父子进程"><a href="#gdb调试父子进程" class="headerlink" title="gdb调试父子进程"></a>gdb调试父子进程</h5><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p><ul><li>设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child]</li><li>设置调试模式：set detach-on-fork [on | off]<br>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。</li><li>查看调试的进程：info inferiors<br>切换当前调试的进程为id进程：inferior id<br>使进程脱离 GDB 调试：detach inferiors id</li></ul><h5 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h5><p>◼ exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p><p>◼ exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p><p>注意：</p><ol><li><p>内核区的id等不会改变，但是用户取的数据都被替换</p></li><li><p>有p或者v后缀，一般filename直接写文件名，因为p会指定到环境变量查，v指定到数组envp[]中路径依次查找，没找到返回-1</p></li><li><p>一般fork新进程后，替换子进程数据</p></li></ol><ul><li>函数族</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族</span><br><span class="line">◼ int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">◼ int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">◼ int execle(const char *path, const char *arg, .../*, (char *) NULL, char *</span><br><span class="line">const envp[] */);</span><br><span class="line">◼ int execv(const char *path, char *const argv[]);</span><br><span class="line">◼ int execvp(const char *file, char *const argv[]);</span><br><span class="line">◼ int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line">◼ int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">l(list) 参数地址列表，以空指针结尾</span><br><span class="line">v(vector) 存有各参数地址的指针数组的地址</span><br><span class="line">p(path) 按 PATH 环境变量指定的目录搜索可执行文件</span><br><span class="line">e(environment) 存有环境变量字符串地址的指针数组的地址</span><br></pre></td></tr></table></figure><ul><li><p>execl()</p><pre><code>#include &lt;unistd.h&gt;</code></pre><p>   int execl(const char *path, const char *arg, …);<br>   - 参数：<br>       - path:需要指定的执行的文件的路径或者名称<br>           a.out &#x2F;home&#x2F;nowcoder&#x2F;a.out 推荐使用绝对路径<br>           .&#x2F;a.out hello world<br>       - arg:是执行可执行文件所需要的参数列表<br>       第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称<br>       从第二个参数开始往后，就是程序执行所需要的的参数列表。<br>       参数最后需要以NULL结束（哨兵）</p><ul><li>返回值：<br>只有当调用失败，才会有返回值，返回-1，并且设置errno<br>如果调用成功，没有返回值。</li></ul></li><li><p>execlp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... )</span>;</span><br><span class="line">    - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">    - 参数：</span><br><span class="line">        - file:需要执行的可执行文件的文件名</span><br><span class="line">            a.out</span><br><span class="line">            ps</span><br><span class="line">- arg:是执行可执行文件所需要的参数列表</span><br><span class="line">        第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">        从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">        参数最后需要以<span class="literal">NULL</span>结束（哨兵）</span><br><span class="line"></span><br><span class="line">- 返回值：</span><br><span class="line">    只有当调用失败，才会有返回值，返回<span class="number">-1</span>，并且设置errno</span><br><span class="line">    如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure></li><li><p>execv</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line">argv是需要的参数的一个字符串数组</span><br><span class="line"><span class="type">char</span> * argv[] = &#123;<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/ps&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">char</span> * envp[] = &#123;<span class="string">&quot;/home/nowcoder&quot;</span>, <span class="string">&quot;/home/bbb&quot;</span>, <span class="string">&quot;/home/aaa&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-进程退出"><a href="#2-3-进程退出" class="headerlink" title="2.3 进程退出"></a>2.3 进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*标准库</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment">  Linux系统（没有缓冲区，退出过不刷新缓冲区，直接退出，可能导致缓冲区的数据还没有拿出来）</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0);</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>◼ 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。<br>◼ 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init<br>进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束<br>了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。<br>◼ 因此孤儿进程并不会有什么危害</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，<strong>内核区的 PCB</strong> 没有办法自己释放掉，需要<strong>父进程</strong>去释放。<br>◼ 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。<br>◼ 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p><h5 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h5><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。<br>◼ 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><h6 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h6><ul><li><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *wstatus);    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。    参数：int *wstatus        进程退出时的状态信息，传入的是一个int类型的地址，传出参数。        //wstatus指针传入到宏里面可得到 退出的具体信息        //如果不需要查看直接 wait(NULL)    返回值：        - 成功：返回被回收的子进程的id        - 失败：-1 (所有的子进程都结束，调用函数失败)调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">◼ wait() 和 waitpid() 函数的功能一样，区别在于：</span><br><span class="line">**wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。**</span><br><span class="line">◼ 注意：一次wait或waitpid调用**只能清理一个子进程**，清理多个子进程应使用循环：while()</span><br><span class="line"></span><br><span class="line">* 退出信息相关宏函数查询</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  ◼ WIFEXITED(status) 非0，进程正常退出</span><br><span class="line">  ◼ WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</span><br><span class="line">  ◼ WIFSIGNALED(status) 非0，进程异常终止</span><br><span class="line">  ◼ WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</span><br><span class="line">  ◼ WIFSTOPPED(status) 非0，进程处于暂停状态</span><br><span class="line">  ◼ WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</span><br><span class="line">  ◼ WIFCONTINUED(status) 非0，进程暂停后已经继续运行</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">  例子;</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/wait.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">  </span><br><span class="line">      pid_t pid;</span><br><span class="line">      //创建5个子进程 </span><br><span class="line">      for(int i=0;i!=5;++i)&#123;</span><br><span class="line">          pid = fork();</span><br><span class="line">          if(pid == 0)&#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(pid &gt; 0)&#123;</span><br><span class="line">          //父进程</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              printf(&quot;父进程: %d\n&quot;,getpid());</span><br><span class="line">              int st;</span><br><span class="line">              int ret = wait(&amp;st);</span><br><span class="line">              if(ret == -1)&#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              if(WIFEXITED(st))&#123;</span><br><span class="line">                  //是不是正常退出</span><br><span class="line">                  printf(&quot;退出状态码: %d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">              &#125;</span><br><span class="line">              if(WIFSIGNALED(st))&#123;</span><br><span class="line">                  //是不是被异常终止</span><br><span class="line">                  printf(&quot;被哪个信号干掉: %d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">              &#125;</span><br><span class="line">              printf(&quot;child die,pid = %d\n&quot;,WTERMSIG(st));</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid == 0)&#123;</span><br><span class="line">          //子进程</span><br><span class="line">          printf(&quot;子进程: %d\n&quot;,getpid());</span><br><span class="line">          exit(0);</span><br><span class="line">          sleep(1);        </span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">###### waitpid()函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; 0 : 某个子进程的pid</span><br><span class="line">                pid = 0 : 回收当前进程组的所有子进程    </span><br><span class="line">                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - 参数：int *wstatus</span><br><span class="line">                     进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                0 : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line"> //这三个会返回值可以判断当前进程的子进程回收情况，可以以此来设计，很多子进程时，回收处理函数</span><br><span class="line">                &gt; 0 : 返回子进程的id</span><br><span class="line">                = 0 : options=WNOHANG, 表示还有子进程活着 </span><br><span class="line">                = -1 ：错误，或者没有子进程了</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 例子(设置非阻塞)：</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/wait.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">  </span><br><span class="line">      pid_t pid;</span><br><span class="line">      //创建5个子进程</span><br><span class="line">      for(int i=0;i!=5;++i)&#123;</span><br><span class="line">          pid = fork();</span><br><span class="line">          if(pid == 0)&#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(pid &gt; 0)&#123;</span><br><span class="line">          //父进程</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              printf(&quot;父进程: %d\n&quot;,getpid());</span><br><span class="line">              sleep(1);</span><br><span class="line">              </span><br><span class="line">              int st;</span><br><span class="line">              //int ret = waitpid(-1,&amp;st,0);</span><br><span class="line">              int ret = waitpid(-1,&amp;st,WNOHANG);</span><br><span class="line">              </span><br><span class="line">              if(ret == -1)&#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;else if(ret == 0)&#123;</span><br><span class="line">                  //子进程还有在运行的</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;else if(ret &gt; 0)&#123;</span><br><span class="line">                  if(WIFEXITED(st))&#123;</span><br><span class="line">                      printf(&quot;退出的状态码：%d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">                  &#125;</span><br><span class="line">                  if(WIFSIGNALED(st))&#123;</span><br><span class="line">                      printf(&quot;被哪个信号干掉：%d&quot;,WTERMSIG(st));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              printf(&quot;child die,pid = %d\n&quot;,WTERMSIG(st));</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid == 0)&#123;</span><br><span class="line">          //子进程</span><br><span class="line">          while (1)</span><br><span class="line">          &#123;</span><br><span class="line">              printf(&quot;子进程: %d\n&quot;,getpid());</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">          exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">### 2.4进程间通信IPC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管道在使用完毕后应该被关闭，这是为了防止出现资源泄漏的情况。如果没有关闭管道，在程序运行过程中会一直占用系统资源，而且可能导致其他进程无法使用同名管道。同时，如果管道没有被及时关闭，在程序意外退出时也可能导致数据丢失或者磁盘空间占用问题。因此，在使用完毕后，最好及时关闭管道。</span><br><span class="line"></span><br><span class="line">* TCP/IP方式： mysql -h127.0.0.1 -uroot -P3306 -p</span><br><span class="line">* windowOS 的一台主机：命名管道和共享内存</span><br><span class="line">* 类Unix的一台主机：套接字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* （匿名）管道，Unix系统最古老的通信方式，所有Unix系统都支持</span><br><span class="line">* 统计目录中文件数量的命令： ls | wc -l</span><br><span class="line">  实际上就是创建管道 把写入端导出读取端</span><br><span class="line"></span><br><span class="line">##### 管道特点</span><br><span class="line"></span><br><span class="line">1. 管道其实是内核在内存中维护的缓冲区，缓冲能力有限，不同操作系统大小不同；</span><br><span class="line">2. 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但是不存储数据，可以按照操作文件的方式操作管道。</span><br><span class="line">3. 一个管道是一个字节流，使用管道不存在消息和消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块是多少（每次都按照自己能力读取）</span><br><span class="line">4. 通过管道传递是顺序的。</span><br><span class="line">5. 管道中传递数据方向是单向的，一端写入，一端读取，也就是半双工。</span><br><span class="line">6. 从管道中读取数据是一次性操作，数据一旦被读走了，就从管道抛弃了，(队列实现)释放空间以便写入更多的数据，在管道中无法使用lseek()随机访问数据</span><br><span class="line">7. 管道只能在具有公共祖先的进程（父子进程，兄弟进程，具有亲缘关系）之间使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 管道原理：子进程forkc()出来之后，可以共享文件描述符，可以操作建立管道</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 管道数据结构：环形队列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 匿名管道传输pipe()函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int pipe(int pipefd[2]);</span><br><span class="line">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">            pipefd[0] 对应的是管道的读端</span><br><span class="line">            pipefd[1] 对应的是管道的写端</span><br><span class="line">        返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line"></span><br><span class="line">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 例子-父子间管道通信</span><br><span class="line">* 匿名管道一般不会实现双向读写，因为没有了sleep()，本进程会抢读管道，一般就是一个读，一个写，并且关闭另一个操作，俺理解为互斥</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //在fork()之前创建管道</span><br><span class="line">    int pipefd[2];</span><br><span class="line">    int ret=pipe(pipefd);</span><br><span class="line">    if(ret==-1)&#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if(pid&gt;0)&#123;</span><br><span class="line">        //父进程先读取，然后写</span><br><span class="line">        printf(&quot;父进程&quot;);</span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            //先读</span><br><span class="line">            //sizeof给出操作数的存储地址空间</span><br><span class="line">            int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">            printf(&quot;parent recv: %s ,pid : %d\n&quot;,buf,getpid());</span><br><span class="line"></span><br><span class="line">            //向管道写入数据</span><br><span class="line">            char* str=&quot;hello,this is parent process&quot;;</span><br><span class="line">            write(pipefd[1],str,strlen(str));   </span><br><span class="line">            sleep(1);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(pid ==0)&#123;</span><br><span class="line">        //子进程先写，然后读</span><br><span class="line">        //管道默认阻塞，sleep(10); 如果没有数据，读取端就等着</span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        printf(&quot;子进程&quot;);</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            //先写</span><br><span class="line">            char* str=&quot;hello,this is child process&quot;;</span><br><span class="line">            //strlen()函数给出字符串的长度</span><br><span class="line">            write(pipefd[1],str,strlen(str));   </span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">            //读取数据</span><br><span class="line">            int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">            printf(&quot;child recv: %s ,pid : %d\n&quot;,buf,getpid());</span><br><span class="line">            //清除一下</span><br><span class="line">            bzero(buff,1024);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 互斥读写操作的代码如下</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">      //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  #include &lt;string.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">      //在fork()之前创建管道</span><br><span class="line">      int pipefd[2];</span><br><span class="line">      int ret=pipe(pipefd);</span><br><span class="line">      if(ret==-1)&#123;</span><br><span class="line">          perror(&quot;pipe&quot;);</span><br><span class="line">          exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      //创建子进程</span><br><span class="line">      pid_t pid = fork();</span><br><span class="line">      if(pid&gt;0)&#123;</span><br><span class="line">          //父进程读取</span><br><span class="line">          printf(&quot;父进程\n&quot;);</span><br><span class="line">  </span><br><span class="line">          //关闭写端</span><br><span class="line">          close(pipefd[1]);</span><br><span class="line">  </span><br><span class="line">          char buf[1024]=&#123;0&#125;;</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">              printf(&quot;parent recv: %s ,pid : %d\n&quot;,buf,getpid());           </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid ==0)&#123;</span><br><span class="line">          //子进程写端</span><br><span class="line">          printf(&quot;子进程\n&quot;);</span><br><span class="line">  </span><br><span class="line">          //关闭读端</span><br><span class="line">          close(pipefd[0]);</span><br><span class="line">  </span><br><span class="line">          while(1)&#123;</span><br><span class="line">              char* str=&quot;hello,this is child process&quot;;</span><br><span class="line">              //strlen()函数给出字符串的长度</span><br><span class="line">              write(pipefd[1],str,strlen(str));   </span><br><span class="line">              sleep(1);                  </span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">* 获取管道大小</span><br><span class="line"></span><br><span class="line">* // 1. 函数获取管道的大小</span><br><span class="line">  long size = fpathconf(pipefd[0], _PC_PIPE_BUF);</span><br><span class="line">  // 2. 终端获取管道信息</span><br><span class="line">  ulimit -a</span><br><span class="line"></span><br><span class="line">##### ps aux | grep xxx 操作实现 -父子进程通信案例</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //创建管道</span><br><span class="line">    int fd[2];</span><br><span class="line">    int ret=pipe(fd);</span><br><span class="line">    if(ret==-1)&#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;  </span><br><span class="line">    //创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if(pid &gt; 0)&#123;</span><br><span class="line">    //父进程，读取管道信息输出到列表</span><br><span class="line">        close(fd[1]);</span><br><span class="line">        </span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        int len=-1;</span><br><span class="line">        //空间设置 -1 留一个字符串的结束符位置</span><br><span class="line">        while((len=read(fd[0],buf,sizeof(buf)-1))&gt;0)&#123;</span><br><span class="line">            //过滤数据输出</span><br><span class="line">            printf(&quot;%s&quot;,buf);</span><br><span class="line">            //清空buf内容</span><br><span class="line">            memset(buf,0,1024);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(NULL);</span><br><span class="line"></span><br><span class="line">    &#125;else if(pid == 0)&#123;</span><br><span class="line">    //子进程，把输出stdout_fileno的内容写入管道</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        // 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span><br><span class="line">        dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">        //替换到aux的内容</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        //如果没退出，报系统错误</span><br><span class="line">        perror(&quot;execlp&quot;);</span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">##### 管道读写的特点</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端</span><br><span class="line">读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</span><br><span class="line"></span><br><span class="line">2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程</span><br><span class="line">也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line"></span><br><span class="line">3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程</span><br><span class="line">向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line"></span><br><span class="line">4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程</span><br><span class="line">也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">    读管道：</span><br><span class="line">        管道中有数据，read返回实际读到的字节数。</span><br><span class="line">        管道中无数据：</span><br><span class="line">            写端被全部关闭，read返回0（相当于读到文件的末尾）</span><br><span class="line">            写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">    写管道：</span><br><span class="line">        管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">        管道读端没有全部关闭：</span><br><span class="line">            管道已满，write阻塞</span><br><span class="line">            管道没有满，write将数据写入，并返回实际写入的字节数</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 设置非阻塞 - 此时设置为管道读端继续read，由于没有写入，read()返回-1</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">        int flags = fcntl(pipefd[0], F_GETFL);  // 获取原来的flag</span><br><span class="line">        flags |= O_NONBLOCK;            // 修改flag的值</span><br><span class="line">        fcntl(pipefd[0], F_SETFL, flags);   // 设置新的flag</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 有名管道</span><br><span class="line"></span><br><span class="line">◼ 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提 出了有名管道（FIFO），也叫命名管道、FIFO文件。 </span><br><span class="line"></span><br><span class="line">有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此 通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 ◼ </span><br><span class="line"></span><br><span class="line">一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的 I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一 个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的 名称也由此而来：先入先出。</span><br><span class="line"></span><br><span class="line">##### 与匿名管道区别：</span><br><span class="line"></span><br><span class="line">有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： </span><br><span class="line"></span><br><span class="line">1. FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 2. 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</span><br><span class="line"></span><br><span class="line">2. 通过命令创建有名管道 mkfifo 名字</span><br><span class="line"></span><br><span class="line">3. 通过函数创建有名管道 </span><br><span class="line">   int mkfifo(const char *pathname, mode_t mode); </span><br><span class="line"></span><br><span class="line">   ~~~c</span><br><span class="line">   创建fifo文件</span><br><span class="line">       1.通过命令： mkfifo 名字</span><br><span class="line">       2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">   </span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       #include &lt;sys/stat.h&gt;</span><br><span class="line">       int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">           参数：</span><br><span class="line">               - pathname: 管道名称的路径</span><br><span class="line">               - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                       是一个八进制的数</span><br><span class="line">           返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line">   ~~~</span><br><span class="line"></span><br><span class="line">4. 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 **open** 打开它，常见的文件 I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 </span><br><span class="line"></span><br><span class="line">5. FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是 从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</span><br><span class="line"></span><br><span class="line">##### 有名管道注意事项</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    有名管道的注意事项：</span><br><span class="line">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">    读管道：</span><br><span class="line">        管道中有数据，read返回实际读到的字节数</span><br><span class="line">        管道中无数据：</span><br><span class="line">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="line">            写端没有全部被关闭，read阻塞等待</span><br><span class="line">    </span><br><span class="line">    写管道：</span><br><span class="line">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">        管道读端没有全部关闭：</span><br><span class="line">            管道已经满了，write会阻塞</span><br><span class="line">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 同一路径下 有名管道创建并用于读写的例子</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">write.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    // 1.判断文件是否存在</span><br><span class="line">    int ret = access(&quot;fifo1&quot;, F_OK);</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">        printf(&quot;管道不存在，创建管道\n&quot;);</span><br><span class="line">        //2.创建管道文件</span><br><span class="line">        ret = mkfifo(&quot;fifo1&quot;, 0664);</span><br><span class="line"></span><br><span class="line">        if(ret == -1) &#123;</span><br><span class="line">            perror(&quot;mkfifo&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //以只写的方式打开管道</span><br><span class="line">    int fd=open(&quot;fifo1&quot;,O_WRONLY);</span><br><span class="line">    if(fd==-1)&#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写入数据</span><br><span class="line">    for (int i = 0; i &lt; 100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[1024];</span><br><span class="line">        //sprintf将字符串写入buf中</span><br><span class="line">        sprintf(buf,&quot;hello,%d\n&quot;,i);</span><br><span class="line">        printf(&quot;write data: %s\n&quot;,buf);</span><br><span class="line">        write(fd,buf,strlen(buf));</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">read.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">     //1. 打开管道文件</span><br><span class="line">     int fd = open(&quot;fifo1&quot;,O_RDONLY);</span><br><span class="line">     if(fd == -1)&#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //读数据</span><br><span class="line">     while(1)&#123;</span><br><span class="line">        char buf[1024] = &#123;0&#125;;</span><br><span class="line">        int len = read(fd,buf,sizeof(buf));</span><br><span class="line">        if(len == 0)&#123;</span><br><span class="line">            printf(&quot;写端断开连接了。\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;recv buf :%s\n&quot;,buf);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="2-5-内存映射"><a href="#2-5-内存映射" class="headerlink" title="2.5 内存映射"></a>2.5 内存映射</h3><p>Memory-mapped I&#x2F;O 是将磁盘文件的数据映射到内存，用户通过修改内存就可以修改磁盘文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">    - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="type">void</span> *addr: <span class="literal">NULL</span>, 由内核指定</span><br><span class="line">        - length : 要映射的数据的长度，这个值不能为<span class="number">0</span>。建议使用文件的长度。</span><br><span class="line">                获取文件的长度：stat lseek</span><br><span class="line">        - prot : 对申请的内存映射区的操作权限</span><br><span class="line">            -PROT_EXEC ：可执行的权限</span><br><span class="line">            -PROT_READ ：读权限</span><br><span class="line">            -PROT_WRITE ：写权限</span><br><span class="line">            -PROT_NONE ：没有权限</span><br><span class="line">            要操作映射内存，必须要有读的权限。</span><br><span class="line">            PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">        - flags :</span><br><span class="line">            - MAP_SHARED : <span class="comment">//映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span></span><br><span class="line">            - MAP_PRIVATE ：<span class="comment">//不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）,可以用内存映射来存输入，之后用于写入</span></span><br><span class="line">        - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">            - 通过open得到，open的是一个磁盘文件</span><br><span class="line">            - 注意：文件的大小不能为<span class="number">0</span>，open指定的权限不能和prot参数有冲突，也就是不小于需要的权限。</span><br><span class="line">                prot: PROT_READ                open:只读/读写 </span><br><span class="line">                prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">        - offset：偏移量，一般不用。必须指定的是<span class="number">4</span>k的整数倍，<span class="number">0</span>表示不偏移。</span><br><span class="line">    - 返回值：返回创建的内存的首地址</span><br><span class="line">        失败返回MAP_FAILED，(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line">    - 功能：释放内存映射</span><br><span class="line">    - 参数：</span><br><span class="line">        - addr : 要释放的内存的首地址</span><br><span class="line">        - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样</span><br></pre></td></tr></table></figure><h5 id="使用内存映射实现进程间通信："><a href="#使用内存映射实现进程间通信：" class="headerlink" title="使用内存映射实现进程间通信："></a>使用内存映射实现进程间通信：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">使用内存映射实现进程间通信：</span><br><span class="line">1.有关系的进程（父子进程）</span><br><span class="line">    - 还没有子进程的时候</span><br><span class="line">        - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">    - 有了内存映射区以后，创建子进程</span><br><span class="line">    - 父子进程共享创建的内存映射区（类似于匿名管道）</span><br><span class="line"></span><br><span class="line">2.没有关系的进程间通信</span><br><span class="line">    - 准备一个大小不是0的磁盘文件</span><br><span class="line">    - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 使用内存映射区通信（也就是映射同一块文件）</span><br><span class="line"></span><br><span class="line">注意：内存映射区通信，是非阻塞。</span><br></pre></td></tr></table></figure><h6 id="关系类进程通信"><a href="#关系类进程通信" class="headerlink" title="关系类进程通信"></a>关系类进程通信</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="comment">//创建内存映射区    </span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程，写入，父进程接受</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程读取</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,(<span class="type">char</span>*)ptr);<span class="comment">//相当于 把指针指向的内存地址的内容，写到buf中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写入</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;我是儿子，你好&quot;</span>);<span class="comment">//相当于往指针指向内存的位置写入这个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr,size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="非关系类进程通信"><a href="#非关系类进程通信" class="headerlink" title="非关系类进程通信"></a>非关系类进程通信</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">write.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程写入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建内存映射区    </span></span><br><span class="line">        <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;好哥们 你好\n&quot;</span>);       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭内存映射区</span></span><br><span class="line">        munmap(ptr,size);        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">read.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程读取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建内存映射区    </span></span><br><span class="line">        <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,(<span class="type">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s&quot;</span>,buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭内存映射区</span></span><br><span class="line">        munmap(ptr,size);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h5><ol><li><p>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<br>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p></li><li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<br>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p></li><li><p>如果文件偏移量为1000会怎样?<br>偏移量必须是4K的整数倍，返回MAP_FAILED</p></li><li><p>mmap什么情况下会调用失败?<br>- 第二个参数：length &#x3D; 0<br>    - 第三个参数：prot<br>    - 只指定了写权限<br>    - prot PROT_READ | PROT_WRITE<br>      第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY</p></li><li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?<br>- 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>    - 可以对新的文件进行扩展<br>    - lseek()<br>    - truncate()</p></li><li><p>mmap后关闭文件描述符，对mmap映射有没有影响？<br>int fd &#x3D; open(“XXX”);<br>mmap(,,,,fd,0);<br>close(fd);<br>映射区还存在，创建映射区的fd被关闭，没有任何影响。</p></li><li><p>对ptr越界操作会怎样？<br>void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p></li></ol><p>​       void *memcpy(void *dest, const void *src, size_t n);</p><h4 id="使用内存映射实现文件的拷贝"><a href="#使用内存映射实现文件的拷贝" class="headerlink" title="使用内存映射实现文件的拷贝"></a>使用内存映射实现文件的拷贝</h4><ul><li>使用内存映射实现文件拷贝的功能<br>思路：<br>1.对原始的文件进行内存映射<br>2.创建一个新文件（拓展该文件）<br>3.把新文件的数据映射到内存中<br>4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中<br>5.释放资源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新文件（拓展该文件）</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> * ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存拷贝 memcpy内存拷贝函数 在man 3 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名内存映射"><a href="#匿名内存映射" class="headerlink" title="匿名内存映射"></a>匿名内存映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名映射：不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//此处添加ANONYMOUS，表示映射没有任何文件支持，也就是匿名内存映射不需要任何文件支持，所以下一个文件描述符参数作为-1</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *) ptr, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-信号"><a href="#2-6-信号" class="headerlink" title="2.6 信号"></a>2.6 信号</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li><p>概述 : 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p></li><li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p><ol><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C<br>通常会给进程发送一个中断信号。</li><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给<br>相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的<br>内存区域。</li><li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU<br>时间超限，或者该进程的某个子进程退出。</li><li>运行 kill 命令或调用 kill 函数。</li></ol></li><li><p>使用信号的两个主要目的是：</p><ol><li>让进程知道已经发生了一个特定的事情。</li><li>强迫进程执行 它自己代码中的信号处理程序。</li></ol></li><li><p>信号的特点：</p><ol><li>简单</li><li>不能携带大量信息</li><li>满足某个特定条件才发送</li><li>优先级比较高</li></ol></li><li><pre><code class="shell">1. 查看系统定义的信号列表：kill –l前 31 个信号为常规信号，其余为实时信号2. ◼ 查看信号的详细信息：man 7 signal◼ 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件(Core文件包含了一些关于异常的信息) Stop 暂停当前进程 Cont 继续执行当前被暂停的进程3. 信号的几种状态：产生、未决、递达4. SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  * 这里注意kill 9不能杀死僵尸进程</span><br><span class="line">  * 可以用kill -l查看信号对应的编号</span><br><span class="line"></span><br><span class="line">##### kill() raise() abort()</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">    - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">    - 参数：</span><br><span class="line">        - pid ：</span><br><span class="line">            &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">            = 0 : 将信号发送给当前的进程组</span><br><span class="line">            = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">            &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="line">        - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">    kill(getppid(), 9);</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">    </span><br><span class="line">int raise(int sig);</span><br><span class="line">    - 功能：给当前进程或者线程发送信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - sig : 要发送的信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功 0</span><br><span class="line">        - 失败 非0</span><br><span class="line">    kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">void abort(void);</span><br><span class="line">    - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">    类似于: kill(getpid(), SIGABRT);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0) &#123;</span><br><span class="line">        // 子进程</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            printf(&quot;child process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if(pid &gt; 0) &#123;</span><br><span class="line">        // 父进程</span><br><span class="line">        printf(&quot;parent process\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;kill child process now\n&quot;);//这里传的是子进程pid</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### alarm() </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">    - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="line">            函数会给当前的进程发送一个信号：SIGALARM，（查表，会终止进程）</span><br><span class="line">    - 参数：</span><br><span class="line">        seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">                取消一个定时器，通过alarm(0)。</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 之前没有定时器，返回0</span><br><span class="line">        - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">- SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">    alarm(10);  -&gt; 返回0</span><br><span class="line">    过了1秒</span><br><span class="line">    alarm(5);   -&gt; 返回9</span><br><span class="line"></span><br><span class="line">alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 例子</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">//查看1秒计算机能数多少个数？</span><br><span class="line">/*</span><br><span class="line">    实际时间 = 内核时间 + 用户时间 + 消耗时间</span><br><span class="line">    进行文件的IO操作比较消耗时间</span><br><span class="line"></span><br><span class="line">    定时器，与进程的状态无关，alarm都会计时</span><br><span class="line">*/</span><br><span class="line">int main()&#123;</span><br><span class="line">    alarm(1);</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##### setitimer()</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    #include &lt;sys/time.h&gt;</span><br><span class="line">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="line">                        struct itimerval *old_value);</span><br><span class="line">   - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">        - which : 定时器以什么时间计时</span><br><span class="line">          ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="line">          ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">          ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line"></span><br><span class="line">        - new_value: 设置定时器的属性</span><br><span class="line">        </span><br><span class="line">            struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">            struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">            struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct timeval &#123;        // 时间的结构体</span><br><span class="line">                time_t      tv_sec;     //  秒数     </span><br><span class="line">                suseconds_t tv_usec;    //  微秒    </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        过10秒后，每个2秒定时一次</span><br><span class="line">       </span><br><span class="line">        - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">    </span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 0</span><br><span class="line">        失败 -1 并设置错误号</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##### signal 捕捉函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    typedef void (*sighandler_t)(int);</span><br><span class="line">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">        - 功能：设置某个信号的捕捉行为</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum: 要捕捉的信号</span><br><span class="line">            - handler: 捕捉到信号要如何处理</span><br><span class="line">                - SIG_IGN ： 忽略信号</span><br><span class="line">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">                回调函数：</span><br><span class="line">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">            失败，返回SIG_ERR，设置错误号</span><br><span class="line">            </span><br><span class="line">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 例子： 用setitimer配合signal捕捉</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">//设置回调函数</span><br><span class="line">void myAlarm(int num)&#123;</span><br><span class="line">    //这里可以查表得到信号14是SIGALRM</span><br><span class="line">    printf(&quot;捕捉到了信号编号是: %d\n&quot;,num);</span><br><span class="line">    printf(&quot;xxxxxxxxxxxx\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">  // 注册信号捕捉</span><br><span class="line">    // signal(SIGALRM, SIG_IGN);</span><br><span class="line">    // signal(SIGALRM, SIG_DFL);</span><br><span class="line">    // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span><br><span class="line">    signal(SIGALRM,myAlarm);</span><br><span class="line"></span><br><span class="line">    //设置间隔时间</span><br><span class="line">    struct itimerval new_value;</span><br><span class="line">    //时间变量必须要初始化</span><br><span class="line">    new_value.it_interval.tv_sec = 2;</span><br><span class="line">    new_value.it_interval.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    //延迟时间,到3s后开始计时</span><br><span class="line">    new_value.it_value.tv_sec = 3;</span><br><span class="line">    new_value.it_value.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">     //是非阻塞的   </span><br><span class="line">    int ret = setitimer(ITIMER_REAL,&amp;new_value,NULL);</span><br><span class="line">    printf(&quot;开始计时\n&quot;);</span><br><span class="line">    if(ret == -1)&#123;</span><br><span class="line">        perror(&quot;setitimer&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">//保存程序不关闭 阻塞</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 2.7信号集</span><br><span class="line"></span><br><span class="line">* 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</span><br><span class="line">* 在 PCB 中有两个非常重要的信号集。一个称之为 “**阻塞信号集**”（**信号掩码（也就是阻塞信号集）**可以设置，比如empty和add） ，另一个称之为“**未决信号集**” （只读）。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。</span><br><span class="line">* 信号的 “未决” 是一种**状态**，指的是从**信号的产生到信号被处理前**的这一段时间。</span><br><span class="line">* 信号的 “阻塞” 是一个**开关动作**，指的是**阻止信号被处理**，但不是阻止信号产生。</span><br><span class="line">* 信号的**阻塞就是让系统暂时保留信号留待以后发送**。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</span><br><span class="line">* 下图，进程的虚拟地址空间，包括用户区和内核区，内核区中有PCB进程控制块，PCB中有未决信号集和阻塞信号集 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~shell</span><br><span class="line">1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</span><br><span class="line"></span><br><span class="line">2.信号产生但是没有被处理 （未决）</span><br><span class="line">    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</span><br><span class="line">    - SIGINT信号状态被存储在第二个标志位上</span><br><span class="line">        - 这个标志位的值为0， 说明信号不是未决状态</span><br><span class="line">        - 这个标志位的值为1， 说明信号处于未决状态</span><br><span class="line">    </span><br><span class="line">3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</span><br><span class="line">    - 阻塞信号集默认不阻塞任何的信号</span><br><span class="line">    - 如果想要阻塞某些信号需要用户调用系统的API</span><br><span class="line"></span><br><span class="line">4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</span><br><span class="line">    - 如果没有阻塞，这个信号就被处理</span><br><span class="line">    - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">以下信号集相关的函数都是对     自定义的信号集!!     进行操作。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">    - 功能：清空信号集中的数据,将信号集中的所有的标志位置为<span class="number">0</span></span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">    - 功能：将信号集中的所有的标志位置为<span class="number">1</span></span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为<span class="number">1</span>，表示阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为<span class="number">0</span>，表示不阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置不阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：判断某个信号是否阻塞</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：需要操作的信号集</span><br><span class="line">        - signum：需要判断的那个信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">1</span> ： signum被阻塞</span><br><span class="line">        <span class="number">0</span> ： signum不阻塞</span><br><span class="line">        <span class="number">-1</span> ： 失败</span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空信号集的内容 初始化的时候常用</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="type">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sigprocmask-修改内核阻塞信号集"><a href="#sigprocmask-修改内核阻塞信号集" class="headerlink" title="sigprocmask() 修改内核阻塞信号集"></a>sigprocmask() 修改内核阻塞信号集</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">    - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    - 参数：</span><br><span class="line">        - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">            SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变;</span><br><span class="line">                假设内核中默认的阻塞信号集是mask， mask | <span class="built_in">set</span> <span class="comment">//(因为1代表阻塞，所以用或)</span></span><br><span class="line">            SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞;</span><br><span class="line">                mask &amp;= ~<span class="built_in">set</span> <span class="comment">//(先取反 再与）</span></span><br><span class="line">             <span class="comment">//这里要记住 | 运算的取消是 &amp;=~</span></span><br><span class="line">            SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line">        </span><br><span class="line">        - <span class="built_in">set</span> ：已经初始化好的用户自定义的信号集</span><br><span class="line">        - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="literal">NULL</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：<span class="number">-1</span></span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line">    - 功能：获取内核中的未决信号集</span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，保存的是内核中的未决信号集中的信息。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span></span><br><span class="line"><span class="comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置信号集，设置2 ，3号信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//把2,3号信号添加到set</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改内核中阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//获取当前未决的信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历前32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pendingset,i) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pendingset,i) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//解除阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction()信号捕捉函数"></a>sigaction()信号捕捉函数</h5><ul><li>最好用sigaction,而不是signal，因为标准可能不太一样</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">            - act ：捕捉到信号之后的处理动作</span><br><span class="line">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递<span class="literal">NULL</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功 <span class="number">0</span></span><br><span class="line">            失败 <span class="number">-1</span></span><br><span class="line"><span class="comment">/*sigaction的回调函数int类型参数，就是信号类型的宏定义；</span></span><br><span class="line"><span class="comment">这样可以用管道搭配epoll来读传入的信号：</span></span><br><span class="line"><span class="comment">1.用sig的回调函数向fd[1]写，传到fd[0]读端 </span></span><br><span class="line"><span class="comment">2.然后把fd[0]加入epoll实例，就可以IO多路复用，得到突然传入的sig，并且用Switch判断sig的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">        <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">        <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="comment">// 不常用</span></span><br><span class="line">        <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">        <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。回调函数执行完之后，会转换到系统的阻塞信号集。这里一般需要把该临时阻塞信号集清空sigemptyset()</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">        <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">        <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">        <span class="type">int</span>        sa_flags;</span><br><span class="line">        <span class="comment">// 被废弃掉了</span></span><br><span class="line">        <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉特性：</span></span><br><span class="line"><span class="number">1.</span> 信号捕捉过程中会使用临时的阻塞信号集，处理完后，切换恢复到内核的阻塞信号集</span><br><span class="line"><span class="number">2.</span> 在回调sa_handler函数的期间，默认会屏蔽该函数的调用，执行完之后，才能继续处理</span><br><span class="line"><span class="number">3.</span> 信号集只是标志位，不能支持排队</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);  <span class="comment">// 清空临时阻塞信号集</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SIGCHLD信号-回收子进程"><a href="#SIGCHLD信号-回收子进程" class="headerlink" title="SIGCHLD信号 - 回收子进程"></a>SIGCHLD信号 - 回收子进程</h5><ul><li><p>SIGCHLD信号产生的条件</p><ol><li>子进程终止时</li><li>子进程接收到 SIGSTOP 信号停止时</li><li>子进程处在停止态，接受到SIGCONT后唤醒时</li></ol><p>以上三种条件都会给父进程发送 SIGCHLD 信号，<strong>父进程默认会忽略该信号</strong></p></li></ul><h6 id="SIGCHLD-实现回收子进程-比较常用配合waitpid来批量回收子进程"><a href="#SIGCHLD-实现回收子进程-比较常用配合waitpid来批量回收子进程" class="headerlink" title="SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程"></a>SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程</h6><ul><li>不阻塞父进程；提前捕捉，防止全死完了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   使用SIGCHLD信号解决僵尸进程的问题。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子进程的Callback function</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,num);</span><br><span class="line">    <span class="comment">//回收子进程PCB</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//wait调用一次只能回收一个，如果多个子进程同时死了，例如4个，那么肯定会发送4次信号，但是有可能有些信号会被忽略掉，所以要循环把所有的死了的子进程都回收掉用waitpid()配合循环。</span></span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//回收了一个子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;回收死亡的子进程：%d\n&quot;</span>,ret);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//rer == 0还有子进程活着,等他们死</span></span><br><span class="line">            <span class="comment">//ret &lt; 0没有活着的子进程了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="comment">/*1. 这里理解好阻塞:阻塞是接受了不处理。</span></span><br><span class="line"><span class="comment">      2. 为什么先阻塞SIGCHLD就可以保证父进程能处理所有僵尸进程？设置了SIGCHLD在阻塞信号集中阻塞的1，你们只要是          只要曾经收到过SIGCHLD，未决就会保持1；等待之后父进程sigaction去处理，sigcation处理完之后置0；这里父进          程去处理的时候，只要未决是1，也就是不用考虑有多少个已经死了，只要知道有僵尸子进程，就可以用while循环加上          waitpid全部回收完成；</span></span><br><span class="line"><span class="comment">      补充：因为对SIGCHILD信号的默认处理是将其忽略（此时捕捉信号函数还没有注册），如果没有阻塞，直接忽略掉，那父进程就不知道之前发生了什么事情。</span></span><br><span class="line"><span class="comment">      3.《Linux/UNIX系统编程手册》指出为了保障可移植性，应用应在创建任何子进程之前就设置信号捕捉函数。【牛客789400243号】提出了这个观点，应该在fork之前就注册信号捕捉的。其实就是对应了书上这句话。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一些子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程在不阻塞情况下，回收子进程PCB</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//设置捕捉子进程死亡的SIGCHLD</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了不阻塞父进程自己的事情，在此处打开</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//父进程自己的事情</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid: %d\n&quot;</span>,getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid: %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8共享内存"><a href="#2-8共享内存" class="headerlink" title="2.8共享内存"></a>2.8共享内存</h3><ol><li>共享内存允许<strong>两个或者多个进程共享物理内存的同一块区域</strong>（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制<strong>无需内核介入</strong>（较少介入）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li><li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的<strong>速度更快</strong>。</li></ol><h5 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h5><ol><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的<strong>共享内存标识符</strong>。</li><li>使用 shmat() 来<strong>附上</strong>共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li><li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个<strong>指向进程的虚拟地址空间中该共享内存段的起点的指针</strong>。</li><li>调用 shmdt() 来<strong>分离</strong>共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li><li>调用 shmctl() 来<strong>删除</strong>共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</li></ol><h5 id="共享内存函数"><a href="#共享内存函数" class="headerlink" title="共享内存函数"></a>共享内存函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁 <span class="comment">//因为有多个进程指向，类似于智能指针，全部标记销毁就销毁</span></span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节<span class="number">8</span>个位</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>例子：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">read_shm.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个进程</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>,<span class="number">4096</span>,IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share memery id:%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="comment">//2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//3. 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">//4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.删除共享内存</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">write_shm.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个进程</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>,<span class="number">4096</span>,IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share memery id:%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="comment">//2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.删除共享内存</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="共享内存操作命令"><a href="#共享内存操作命令" class="headerlink" title="共享内存操作命令"></a>共享内存操作命令</h5><ol><li>ipcs 用法<br> ipcs -a &#x2F;&#x2F; 打印当前系统中<strong>所有的进程间</strong>通信方式的信息<br> ipcs -m &#x2F;&#x2F; 打印出<strong>使用共享内存</strong>进行进程间通信的信息<br> ipcs -q &#x2F;&#x2F; 打印出<strong>使用消息队列</strong>进行进程间通信的信息<br> ipcs -s &#x2F;&#x2F; 打印出<strong>使用信号进行进程间通信</strong>的信息</li><li>ipcrm 用法<br> ipcrm -M shmkey    &#x2F;&#x2F; 移除用shmkey创建的共享内存段<br> ipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段<br> ipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列<br> ipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列<br> ipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号<br> ipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号</li></ol><h5 id="基础问题："><a href="#基础问题：" class="headerlink" title="基础问题："></a>基础问题：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">问题1：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br><span class="line"></span><br><span class="line">问题2：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为0的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为0的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br><span class="line"></span><br><span class="line">问题3：共享内存和内存映射的区别</span><br><span class="line">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="line">    2.共享内存效果更高</span><br><span class="line">    3.内存</span><br><span class="line">        所有的进程操作的是同一块共享内存。</span><br><span class="line">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="line">    4.数据安全</span><br><span class="line">        - 进程突然退出</span><br><span class="line">            共享内存还存在</span><br><span class="line">            内存映射区消失</span><br><span class="line">        - 运行进程的电脑死机，宕机了</span><br><span class="line">            数据存在在共享内存中，没有了</span><br><span class="line">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="line"></span><br><span class="line">    5.生命周期</span><br><span class="line">        - 内存映射区：进程退出，内存映射区销毁</span><br><span class="line">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span><br><span class="line">            如果一个进程退出，会自动和共享内存进行取消关联。</span><br></pre></td></tr></table></figure><h3 id="2-9守护进程"><a href="#2-9守护进程" class="headerlink" title="2.9守护进程"></a>2.9守护进程</h3><h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><p> 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的<strong>控制终端（Controlling Terminal）</strong>，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。</p><p>默认情况下（没有重定向），每个进程的<strong>标准输入、标准输出和标准错误输出都指向控制终端</strong>，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p><p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</p><h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><p>进程组和会话在进程之间形成了一种两级层次关系：<strong>进程组是一组相关进程的集合，会话是一组相关进程组的集合</strong>。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p><p>进程组由一个或多个共享<strong>同一进程组标识符（PGID）</strong>的进程组成。一个进程组拥有一个进程组<strong>首进程</strong>，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。</p><p>进程组拥有一个生命周期，其开始时间为<strong>首进程创建组的时刻</strong>，结束时间为<strong>最后一个</strong><br><strong>成员进程退出组的时刻</strong>。一个进程可能会因为终止而退出进程组，也可能会因为加入<br>了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p><h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><p>◼ 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会<br>话 ID。新进程会继承其父进程的会话 ID（<strong>SID</strong>）。</p><p>◼ 一个会话中的所有进程<strong>共享单个控制终端</strong>。控制终端会在会话首进程首次打开一个终<br>端设备时被建立。一个终端最多可能会成为<strong>一个</strong>会话的控制终端。</p><p>◼ 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为<br>后台进程组。只有<strong>前台进程组中的进程才能从控制终端中读取输入</strong>。当用户在控制终<br>端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p><p>◼ 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p><ul><li>进程组、会话操作函数</li></ul><p>◼ pid_t getpgrp(void);<br>◼ pid_t getpgid(pid_t pid);<br>◼ int setpgid(pid_t pid, pid_t pgid);<br>◼ pid_t getsid(pid_t pid);<br>◼ pid_t setsid(void);</p><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>◼ 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是<br>Linux 中的<strong>后台服务进程</strong>。它是一个生存期较长的进程，通常独立于控制终端并且周<br>期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>◼ 守护进程具备下列特征：</p><ol><li>生命周期很长，守护进程会在系统启动的时候被<strong>创建并一直运行直至系统被关闭</strong>。</li><li>它在后台运行并且<strong>不拥有控制终端</strong>。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li></ol><ul><li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</li></ul><h6 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h6><p>◼ 执行一个 fork()，之后父进程退出，子进程继续执行。（1. 防止父进程死亡后出现shell提示符；2.防止该进程成为组进程的首进程）</p><p>◼ 子进程调用 setsid() 开启一个新会话。</p><p>◼ 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。<br>◼ 修改进程的当前工作目录，通常会改为根目录（&#x2F;）。<br>◼ 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>◼ 在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2()<br>使所有这些描述符指向这个设备。<br>◼ 核心业务逻辑</p><ul><li>例子：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个守护进程，每隔两秒获取系统时间，并且把这个时间写入到磁盘文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="comment">//捕捉到定时信号之后，获取系统时间，写入磁盘文件</span></span><br><span class="line">    <span class="type">time_t</span> tm =time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">// //直接打印,但是文件描述符 1 2 3都已经重定向了，所以打印不到终端</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf,&quot;%d-%d-%d,%d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon,loc-&gt;tm_mday,</span></span><br><span class="line">    <span class="comment">// loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化时间，写入磁盘文件中</span></span><br><span class="line">    <span class="type">char</span>* str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR|O_CREAT|O_APPEND,<span class="number">0664</span>);</span><br><span class="line">    write(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//守护进程创建步骤</span></span><br><span class="line">    <span class="comment">//1.创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.子进程开启新会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置掩码 信号掩码（也就是阻塞信号集）</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改进程的当前工作目录（注意权限）</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/klchen/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.关闭、重定向文件描述符(让标准输入、输出、错误，也就是0 1 2重定向到那个设备)</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕捉定时信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myFun;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec =<span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec =<span class="number">0</span>; </span><br><span class="line">    setitimer(ITIMER_REAL,&amp;val,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持进程不关闭</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Linux多线程开发"><a href="#3-Linux多线程开发" class="headerlink" title="3.Linux多线程开发"></a>3.Linux多线程开发</h2><h3 id="3-1线程概述"><a href="#3-1线程概述" class="headerlink" title="3.1线程概述"></a>3.1线程概述</h3><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机<br>制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p><ul><li><p><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p></li><li><p>线程是<strong>轻量级的进程</strong>（<strong>LWP</strong>：Light Weight Process），在 Linux 环境下线程的本<br>质仍是进程。</p></li><li><p>查看指定进程的 LWP 号：ps –Lf pid</p></li><li><p>共享资源<br> 进程 ID 和父进程 ID<br> 进程组 ID 和会话 ID<br> 用户 ID 和 用户组 ID<br> 文件描述符表<br> 信号处置<br> 文件系统的相关信息：文件权限掩码<br>（umask）、当前工作目录<br> 虚拟地址空间（除栈、.text）&#x2F;&#x2F;这两个会被划分</p></li><li><p>非共享资源<br> 线程 ID<br> 信号掩码<br> 线程特有数据<br> error 变量<br> 实时调度策略和优先级<br> 栈，本地变量和函数的调用链接信息</p></li><li><p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p></li></ul><h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><ol><li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</li><li>调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。</li><li>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</li><li>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。</li></ol><h3 id="3-2线程操作"><a href="#3-2线程操作" class="headerlink" title="3.2线程操作"></a>3.2线程操作</h3><h5 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span><br><span class="line">称之为子线程。</span><br><span class="line">程序中默认只有一个进程，fork()函数调用，<span class="number">2</span>个进程</span><br><span class="line">程序中默认只有一个线程，pthread_create()函数调用，<span class="number">2</span>个线程。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">    - 功能：创建一个子线程</span><br><span class="line">    - 参数：</span><br><span class="line">        - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span><br><span class="line">        - attr : 设置线程的属性，一般使用默认值，<span class="literal">NULL</span></span><br><span class="line">        - start_routine : <span class="comment">//函数指针，这个函数是子线程需要处理的逻辑代码,注意函数返回值void*,俺的理解是调用函数指针后，还是需要返回值告诉主线程创建子线程及子线程工作的成功与否，与前面的sigaction信号触发后的回调函数不一样，那个不需要返回执行正确与否</span></span><br><span class="line">        - arg : 给第三个参数使用，传参</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号。这个错误号和之前errno不太一样。</span><br><span class="line">        获取错误号的信息：  <span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure><ul><li>例子-gcc pthread_create.c -o pthread_create -lpthread</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意线程不是标准库 ，需要指定第三方库名称 -l pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 子线程创建的callback Fuction, 子线程需要处理的逻辑代码，传入参数指定为任意类型指针 2. 此处返回的是void*类型 返回任意类型指针 </span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg: %d\n&quot;</span>,*((<span class="type">int</span>*)arg));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main()函数都在主线程中执行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试callback的传入参数</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个子线程,测试回调函数及其参数</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,(<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *error = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s&quot;</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">    功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span><br><span class="line">    参数：</span><br><span class="line">        retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。(类似于<span class="keyword">return</span> (<span class="type">void</span>*)&amp;value;)</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    功能：获取当前的线程的线程ID</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">    功能：比较两个线程ID是否相等</span><br><span class="line">    不同的操作系统，<span class="type">pthread_t</span>类型的实现不一样，有的是无符号的长整型，有的</span><br><span class="line">    是使用结构体去实现的。</span><br></pre></td></tr></table></figure><ul><li>例子-线程退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//相当于pthread_exit(NULL);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//mian thread已经退出，之后代码不会运行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="连接已终止的线程-线程回收"><a href="#连接已终止的线程-线程回收" class="headerlink" title="连接已终止的线程 - 线程回收"></a>连接已终止的线程 - 线程回收</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line">    - 功能：和一个已经终止的线程进行连接</span><br><span class="line">            回收子线程的资源</span><br><span class="line">            这个函数是阻塞函数，调用一次只能回收一个子线程</span><br><span class="line">            一般在主线程中使用</span><br><span class="line">    - 参数：</span><br><span class="line">        - thread：需要回收的子线程的ID</span><br><span class="line">        - retval: 接收子线程退出时的返回值</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">0</span> : 成功</span><br><span class="line">        非<span class="number">0</span> : 失败，返回的错误号</span><br></pre></td></tr></table></figure><ul><li>例子-回收子线程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">//退出并且设置返回值</span></span><br><span class="line">    pthread_exit((<span class="type">void</span>*)&amp;num);<span class="comment">//相当于 return (void*)&amp;num              </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> * error1 = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s&quot;</span>,error1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程的事情</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i != <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld,main thread tid:%ld&quot;</span>,tid,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主进程调用pthread_exit()回收子线程的资源</span></span><br><span class="line">    <span class="type">int</span> *thread_return;</span><br><span class="line">    <span class="comment">//二级指针，因为传出参数是指针，需要用二级指针指向他</span></span><br><span class="line">    ret = pthread_join(tid,(<span class="type">void</span>**)&amp;thread_return);</span><br><span class="line">    <span class="keyword">if</span> (ret !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *error2 = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>,error2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data: %d\n&quot;</span>,*thread_return);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程回收成功!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span><br><span class="line">      <span class="number">1.</span>不能多次分离，会产生不可预料的行为。</span><br><span class="line">      <span class="number">2.</span>不能去连接一个已经分离的线程，会报错。</span><br><span class="line">    - 参数：需要分离的线程的ID</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号</span><br></pre></td></tr></table></figure><ul><li>例子：线程分离</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分离后，对分离的子线程进行连接 ,连接不上了哦 pthread_join()</span></span><br><span class="line">    <span class="comment">// ret = pthread_join(tid, NULL);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) &#123;</span></span><br><span class="line">    <span class="comment">//     char * errstr = strerror(ret);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;error3 : %s\n&quot;, errstr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：取消线程（让线程终止）</span><br><span class="line">        取消某个线程，可以终止某个线程的运行，</span><br><span class="line">        但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</span><br><span class="line">        取消点cancellaction point：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//printf是一个取消点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    - 初始化线程属性变量</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    - 释放线程属性的资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line">    - 获取线程分离的状态属性</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">    - 设置线程分离的状态属性</span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建线程属性变量</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">//初始化attr</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性变量为分离</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//创建的时候添加参数attr，设置分离</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,&amp;attr,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *errst = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1:%s\n&quot;</span>,errst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出线程id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld,main thread id: %ld\n&quot;</span>,tid,pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放线程资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3线程同步"><a href="#3-3线程同步" class="headerlink" title="3.3线程同步"></a>3.3线程同步</h3><ul><li><p>线程同步</p><ol><li>线程的主要优势在于，能够通过<strong>全局变量来共享信息</strong>。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li><li><strong>临界区</strong>是指访问某一<strong>共享资源的代码片段</strong>，并且这段代码的执行应为<strong>原子操作</strong>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</li><li><strong>线程同步</strong>：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li></ol></li><li><p>互斥量</p></li></ul><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共<br>享资源的原子访问。</p><ol><li>互斥量有两种状态：已锁定（locked）和未锁（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法 。</li><li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问</li><li>同一资源时将采用如下协议 ：<br>⚫ 针对共享资源锁定互斥量<br>⚫ 访问共享资源<br>⚫ 对互斥量解锁</li></ol><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">互斥量的类型 <span class="type">pthread_mutex_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">    - 初始化互斥量</span><br><span class="line">    - 参数 ：</span><br><span class="line">        - mutex ： 需要初始化的互斥量变量</span><br><span class="line">        - attr ： 互斥量相关的属性，<span class="literal">NULL</span></span><br><span class="line">    - <span class="keyword">restrict</span> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。</span><br><span class="line">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex = xxx;</span><br><span class="line">        <span class="type">pthread_mutex_t</span> * mutex1 = mutex;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 释放互斥量的资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 解锁</span><br></pre></td></tr></table></figure><ul><li>例子 - 用三个线程并发卖票，保证同步互斥</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建全局的互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> ticket = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//子线程 共享函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sellticket</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"><span class="comment">//卖票</span></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第 %d 张票\n&quot;</span>,pthread_self(),ticket--);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//注意加锁之后要保证能够解锁，特别注意break,exit()这些直接退出的</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">6000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收子线程资源，阻塞</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放互斥资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        <span class="comment">//主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p> 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互<br>斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。<br>◼ <strong>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象</strong>，<br>若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p><ul><li><p>死锁的几种场景：</p><ol><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占锁资源</li></ol></li><li><p>演示死锁</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1, mutex2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">workA</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="comment">//首先，在 workA 中使用 pthread_mutex_lock(&amp;mutex1) 对线程A进行加锁，但是由于 cpu 执行的速度很快，导致在 workB 中，还没有使用 pthread_mutex_lock(&amp;mutex2) 对线程B进行加锁，workA就继续向下执行，因为资源 B 并没有被线程 B 加锁，所以在 workA 中的 pthread_mutex_lock(&amp;mutex2) 并未处于阻塞状态</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果B已经锁住了，那这里A就阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workA....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">workB</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这个因为A已经锁了，B阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workB....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, workA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, workB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>读写锁<br>◼ 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的<strong>绝对排它性</strong>，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。<br>◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。<br>为了满足当前能够<strong>允许多个读出，但只允许一个写入的需求</strong>，线程提供了读写锁来实现。</p><ul><li>读写锁的特点：<ol><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作。</li><li>写是独占的，写的优先级高。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 <span class="type">pthread_rwlock_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line">案例：<span class="number">8</span>个线程操作同一个全局变量。</span><br><span class="line"><span class="number">3</span>个线程不定时写这个全局变量，<span class="number">5</span>个线程不定时的读这个全局变量</span><br></pre></td></tr></table></figure><ul><li>例子 - 读写锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8个线程操作一个全局变量，3个写，5个读</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> num =<span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//写区锁</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write,tid: %ld,num: %d\n&quot;</span>,pthread_self(),num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//读区锁</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程创建</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>],rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i],<span class="literal">NULL</span>,writeNum,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i],<span class="literal">NULL</span>,readNum,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(wtid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(rtid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁，主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥结构-粗略版本的生产消费者模型，可能会导致已放弃 (核心已转储)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//队列方式读取，实际上是back指针，插入的时候用头插法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者 不断添加节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode -&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode -&gt;num = rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d,tid: %ld\n&quot;</span>,newNode-&gt;num,pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 获取节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">custmer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//同一块临界区，设置为都互斥</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node,num: %d,tid: %ld\n&quot;</span>,tmp-&gt;num,pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没了，快做\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//5个生产者线程，5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>],ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i],<span class="literal">NULL</span>,custmer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(ptid[i]);</span><br><span class="line">        pthread_detach(ctid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出主线程，释放锁</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完整的生产者消费者模型代码 - 固定缓冲区大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">int</span> *buf;</span><br><span class="line"><span class="type">int</span> bufSize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> bufPtr;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="comment">//三个信号量</span></span><br><span class="line"><span class="type">sem_t</span> full, empty, mutex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (bufPtr &lt; bufSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//信号量模型</span></span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        buf[++bufPtr] = bufPtr;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//信号量模型</span></span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        count = (count + <span class="number">1</span>) % __INT32_MAX__;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid[%ld], count[%d], data[%d]\n&quot;</span>, pthread_self(), count, buf[bufPtr--]);</span><br><span class="line"> </span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化三个信号量</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, bufSize);</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化读写指针、缓冲区</span></span><br><span class="line">    bufPtr = <span class="number">-1</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    buf = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * bufSize);</span><br><span class="line">    <span class="comment">//创建6个线程，一个作生产者，5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ppid, cpids[<span class="number">5</span>];</span><br><span class="line">    pthread_create(&amp;ppid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;cpids[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//detach分离，线程自动回收资源</span></span><br><span class="line">    pthread_detach(ppid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(cpids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程结束</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>某个条件满足之后开启或者解除阻塞;</p><ul><li>《Liunx&#x2F;UNIX系统编程手册》第531页有句话，条件变量并不保存状态信息，只是传递应用程序状态信息的一种通讯机制。发送信号时若无任何线程在等待该条件变量，这个也就会不了了之。线程如在此后等待该条件变量，只有当再次收到此变量的下一信号时，方可解除阻塞状态。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">条件变量的类型 <span class="type">pthread_cond_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">    - 等待，调用了该函数，线程会阻塞。<span class="comment">//1.这个函数调用阻塞的时候，会对互斥锁mutex解锁；当收到signal或者broadcasr的时候，取消阻塞，这个时候会重新加上锁mutex</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">    - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    - <span class="comment">//唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    - 唤醒<span class="comment">//所有的等待的线程</span></span><br></pre></td></tr></table></figure><ul><li>例子：资源不足的时候，条件变量wait等待生产者，生产者生产后，条件变量signal通知生产者</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="comment">//创建条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//队列方式读取，实际上是back指针，插入的时候用头插法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者 不断添加节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode -&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode -&gt;num = rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d,tid: %ld\n&quot;</span>,newNode-&gt;num,pthread_self());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生产一个，就同志消费者，唤醒一个等待的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 获取节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">custmer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//同一块临界区，设置为都互斥</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node,num: %d,tid: %ld\n&quot;</span>,tmp-&gt;num,pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*没有数据，需要等待</span></span><br><span class="line"><span class="comment">            当函数调用阻塞的时候，对互斥锁进行解锁，</span></span><br><span class="line"><span class="comment">            当不阻塞的时候，继续向下执行，会重新加锁</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没了，快做\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="comment">//usleep(100);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//5个生产者线程，5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>],ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i],<span class="literal">NULL</span>,custmer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(ptid[i]);</span><br><span class="line">        pthread_detach(ctid[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">信号量的类型 <span class="type">sem_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">    - 初始化信号量</span><br><span class="line">    - 参数： </span><br><span class="line">        - sem : 信号量变量的地址</span><br><span class="line">        - pshared : <span class="number">0</span> 用在线程间 ，非<span class="number">0</span> 用在进程间</span><br><span class="line">        - value : 信号量中的值</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 释放资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 对信号量加锁，调用一次对信号量的值<span class="number">-1</span>，如果值为<span class="number">0</span>，就阻塞</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 对信号量解锁，调用一次对信号量的值+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line">init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    sem_wait(&amp;psem);</span><br><span class="line">    sem_post(&amp;csem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer() &#123;</span><br><span class="line">    sem_wait(&amp;csem);</span><br><span class="line">    sem_post(&amp;psem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例子 - 用信号量实现生产者消费者</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">customer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Linux网络编程"><a href="#4-Linux网络编程" class="headerlink" title="4.Linux网络编程"></a>4.Linux网络编程</h2><h3 id="4-1网络基础"><a href="#4-1网络基础" class="headerlink" title="4.1网络基础"></a>4.1网络基础</h3><p>看pdf</p><h3 id="4-2-socket通信基础"><a href="#4-2-socket通信基础" class="headerlink" title="4.2 socket通信基础"></a>4.2 socket通信基础</h3><h5 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介</h5><p>所谓 socket（套接字），就是对<strong>网络中不同主机上的应用进程之间进行双向通信的端点的抽象</strong>。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制</strong>。</p><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为<strong>内核借助缓冲区形成的伪文件</strong>。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于<strong>本地</strong>进程间通信，而套接字多应用于<strong>网络进程间</strong>数据的传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 套接字通信分两部分：</span></span><br><span class="line">- 服务器端：被动接受连接，一般不会主动发起连接</span><br><span class="line">- 客户端：主动向服务器发起连接</span><br><span class="line"> </span><br><span class="line">socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。</span><br></pre></td></tr></table></figure><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>现代 CPU 的<strong>累加器</strong>一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在<strong>内存中排列的顺序</strong>将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于<strong>字节、字等的存储机制</strong>有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如<br>果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。</p><ul><li><strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数</strong><br><strong>据当然就无需谈顺序的问题了)。</strong></li><li>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整<br>数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地<br>址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地<br>址处。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用union查找字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>)&amp;&amp;(test.bytes[<span class="number">1</span>] == <span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>)&amp;&amp;(test.bytes[<span class="number">1</span>] == <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h5><ul><li><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。<br>解决问题的方法是：<br>    发送端总是把要发送的数据转换成<strong>大端字节序数据后再发送</strong>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p></li><li><p><strong>网络字节顺序</strong>是 TCP&#x2F;IP 中规定好的一种数据表示格式，它<strong>与具体的 CPU 类型、操作系统等无关</strong>，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。<br>BSD Socket提供了封装好的转换接口，方便程序员使用。</p><ol><li>从主机字节序到网络字节序的转换函数：htons、htonl；</li><li>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network  网络字节序</span><br><span class="line">s - <span class="type">short</span>  <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">l  - <span class="type">long</span>  <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口 因为端口本身是unsigned short类型</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"><span class="comment">// 转IP因为端口本身是unsigned int类型</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// 网络字节序 - 主机字节序</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//htons 两个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//htonl 一般转化ip 四个字节</span></span><br><span class="line">    <span class="type">char</span>  buf[<span class="number">4</span>] = &#123;<span class="number">196</span>,<span class="number">168</span>,<span class="number">1.100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)buf;</span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span>*)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h4><p>客户端和服务器通信，需要IP Port ….，所以封装好了一个socket地址。</p><p>&#x2F;&#x2F; socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。</p><h5 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h5><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span>     sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure><ol><li>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议<br>族（protocol family，也称 domain）和对应的地址族入下所示</li></ol><ul><li>宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。</li></ul><ol start="2"><li>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</li></ol><p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line"><span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure><h5 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h5><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr <em>*退化成了（void *）**的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再</em>*强制类型转化为所需的地址类型**。</p><p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>//这个用较多</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span> <span class="comment">//这个用较多</span></span><br><span class="line">  <span class="type">in_port_t</span> sin_port;     <span class="comment">/* Port number. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* Internet address. */</span>  <span class="comment">//这个用较多</span></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line">       <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">socklen_t</span> 是sockaddr_in的长度类型</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin6_family;</span><br><span class="line">  <span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">  <span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">  <span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><ul><li>所有<strong>专用</strong> socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要<strong>转化为通用</strong> socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</li></ul><h3 id="4-3-IP地址转换"><a href="#4-3-IP地址转换" class="headerlink" title="4.3 IP地址转换"></a>4.3 IP地址转换</h3><p>字符串ip-整数 ，主机-网络字节序的转换</p><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用<strong>点分十进制字符串</strong>表示 IPv4 地址，以及用<strong>十六进制字符串</strong>表示 IPv6 地址。但编程中我们需要先把它们<strong>转化为整数（二进制数）方能使用</strong>。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p><ul><li>旧接口- 以下函数比较久，且只使用于IPv4，而且是不可重用的函数，比如第三个因为直接用了那个结构体变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下函数比较久，且只使用于IPv4，而且是不可重用的函数，比如第三个因为直接用了那个结构体变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//转换成整数</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="comment">//转换成整数，保存在结构体in_addr中，成功返回1，失败返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"><span class="comment">//网络字节序的证书转换成点分十进制的字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><ul><li>新接口-下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET  AF_INET6</span><br><span class="line">  src:需要转换的点分十进制的IP字符串</span><br><span class="line">  dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET  AF_INET6</span><br><span class="line">  src: 要转换的ip的整数的地址</span><br><span class="line">  dst: 转换成IP地址字符串保存的地方</span><br><span class="line">  size：第三个参数的大小<span class="comment">//（数组的大小）</span></span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure><ul><li>IP地址转换例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建点分十进制ip地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.163.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ipv4字符串转化网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET,buf,&amp;num);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络字节序的整数转化为IPv4字符串</span></span><br><span class="line">        <span class="comment">//15个字符加上一个字符串结束符</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这里获取后，使用str和ip其实是一样</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = inet_ntop(AF_INET,&amp;num,ip,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str:%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s\n&quot;</span>,ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ip == str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="4-4TCP通信流程"><a href="#4-4TCP通信流程" class="headerlink" title="4.4TCP通信流程"></a>4.4TCP通信流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 和 UDP -&gt; 传输层的协议</span></span><br><span class="line">UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠</span><br><span class="line">TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输</span><br><span class="line"> </span><br><span class="line">              UDP   TCP</span><br><span class="line">是否创建连接 无连接 ||面向连接</span><br><span class="line">是否可靠  不可靠 ||可靠的</span><br><span class="line">连接的对象个数   一对一、一对多、多对一、多对多 ||支持一对一</span><br><span class="line">传输的方式 面向数据报  ||面向字节流</span><br><span class="line">首部开销 <span class="number">8</span>个字节 ||最少<span class="number">20</span>个字节</span><br><span class="line">适用场景 实时应用（视频会议，直播）  ||可靠性高的应用（文件传输）</span><br></pre></td></tr></table></figure><h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">  - 监听：监听有客户端的连接</span><br><span class="line">  - 套接字：这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">  - 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字</span><br><span class="line">（fd）</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line"> - 接收数据</span><br><span class="line"> - 发送数据</span><br><span class="line"><span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于通信的套接字（fd）</span><br><span class="line"><span class="number">2.</span> 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line"><span class="number">3.</span> 连接成功了，客户端可以直接和服务器通信</span><br><span class="line">  - 接收数据</span><br><span class="line">  - 发送数据</span><br><span class="line"><span class="number">4.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><h3 id="4-4套接字函数"><a href="#4-4套接字函数" class="headerlink" title="4.4套接字函数"></a>4.4套接字函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">  - 参数：</span><br><span class="line">    - domain: 协议族</span><br><span class="line">       AF_INET : ipv4</span><br><span class="line">       AF_INET6 : ipv6</span><br><span class="line">       AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">      SOCK_STREAM : 流式协议<span class="comment">//TC一般 用这个</span></span><br><span class="line">      SOCK_DGRAM : 报式协议<span class="comment">//UDP等</span></span><br><span class="line">    - protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">      - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">      - SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">    - 返回值：</span><br><span class="line">      - 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">      - 失败：<span class="number">-1</span>    </span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命名</span></span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定 <span class="comment">//也就是讲文件描述符告诉连接方</span></span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">      - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">      - addrlen : 第二个参数结构体占的内存大小</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// cat /proc/sys/net/core/somaxconn可以查看，本机是4096</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">  - 参数：</span><br><span class="line">    - sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">    - backlog : 未连接的和已经连接的和的最大值， <span class="comment">//一般给个 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 用于监听的文件描述符</span><br><span class="line">      - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">      - addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">  - 返回值：</span><br><span class="line">      - 成功 ：用于通信的文件描述符</span><br><span class="line">      - <span class="number">-1</span> ： 失败</span><br><span class="line">       </span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 用于通信的文件描述符</span><br><span class="line">      - addr : 客户端要连接的服务器的地址信息</span><br><span class="line">      - addrlen : 第二个参数的内存大小</span><br><span class="line">  - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure><h3 id="4-5-TCP通信并发实现"><a href="#4-5-TCP通信并发实现" class="headerlink" title="4.5 TCP通信并发实现"></a>4.5 TCP通信并发实现</h3><h5 id="TCP通信-单连"><a href="#TCP通信-单连" class="headerlink" title="TCP通信 单连"></a>TCP通信 单连</h5><ol><li>服务器端设置端口999；客户端的端口是随机分配的，只要去连接服务器端的999就行</li><li>服务器端要去连的IP是任意的；客户端要去连接的IP是服务器端的192.168.31.128</li></ol><h6 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务器端两个文件描述符</span></span><br><span class="line"><span class="comment">1. 监听文件描述符lfd，相当于创建socket分配了，只不过后续要绑定到struct sockaddr_in saddr结构体（ip，port）上；</span></span><br><span class="line"><span class="comment">2.连接文件描述符cfd,在accept之后分配，只不过针对当前客户端的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit(0):正常运行程序并退出程序; exit(1):非正常运行导致退出程序,exit（-1）：非正常运行导致退出程序，与1类似；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span> </span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//方法一：设置ip，保持网络字节序；这儿注意一下结构体嵌套，最后存的变量</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET,&quot;192.168.31.128&quot;,saddr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="comment">//方法二：直接写in_addr_t类型的变量算了；INADDR_ANY是linux下的任博 </span></span><br><span class="line">    <span class="comment">//设置ip号</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4，接受客户端连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出客户端数据</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">    inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">//获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">    <span class="comment">//5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//服务器接受客户端数据</span></span><br><span class="line">        <span class="comment">//cfd是客户端socket发过来的文件描述符</span></span><br><span class="line">        <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受了num个字节   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受完了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">    <span class="type">char</span>* data = <span class="string">&quot;连上了，我是服务器端&quot;</span>;</span><br><span class="line">        write(cfd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.断开关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端用自己socket生成的fd写读，并且把fd发给服务器端，服务器端用针对该客户端的cfd</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *data = <span class="string">&quot;这是客户端&quot;</span>;</span><br><span class="line">        write(fd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小作业-读取输入并且回射"><a href="#小作业-读取输入并且回射" class="headerlink" title="小作业-读取输入并且回射"></a>小作业-读取输入并且回射</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit(0):正常运行程序并退出程序; exit(1):非正常运行导致退出程序,exit（-1）：非正常运行导致退出程序，与1类似；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//方法一：设置ip，保持网络字节序；这儿注意一下结构体嵌套，最后存的变量</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET,&quot;192.168.31.128&quot;,saddr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="comment">//方法二：直接写in_addr_t类型的变量算了；INADDR_ANY是linux下的任博</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9988</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4，接受客户端连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出客户端数据</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">    inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">//获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">    <span class="comment">//5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//服务器接受客户端数据</span></span><br><span class="line">        <span class="comment">//cfd是客户端socket发过来的文件描述符</span></span><br><span class="line">        <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受了num个字节   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受完了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">    <span class="comment">//char* data = &quot;连上了，我是服务器端&quot;;</span></span><br><span class="line">        <span class="comment">// char data[1024];</span></span><br><span class="line">        <span class="comment">// scanf(&quot;%s&quot;,data);</span></span><br><span class="line">        <span class="comment">// printf(&quot;请输入\n&quot;);</span></span><br><span class="line">        write(cfd,recvBuf,<span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.断开关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9988</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//申请内存并且清空</span></span><br><span class="line">        <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,data);</span><br><span class="line">        write(fd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是<strong>客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等</strong>。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手<br>来关闭一个连接。<br>三次握手的目的是保证双方互相之间建立了连接。<br>三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手</p><h6 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h6><ul><li>16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或<br>应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号</li><li>32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输<br>方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个<br>TCP 报文段中，<strong>序号值被系统初始化为某个随机值 ISN</strong>（Initial Sequence Number，初始序号<br>值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上<br>该报文段所携带数据的第一个字节在整个字节流中的<strong>偏移</strong>。例如，某个 TCP 报文段传送的数据是字<br>节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从<br>B 到 A）的 TCP 报文段的序号值也具有相同的含义</li><li>32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是<br>收到的 <strong>TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度</strong> 。假设主机 A 和主机 B 进行<br>TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段<br>的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。</li><li>6 位标志位包含如下几项：<ol><li>URG 标志，表示紧急指针（urgent pointer）是否有效。</li><li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</li><li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾<br>出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</li><li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。</li><li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。</li><li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文<br>段。</li></ol></li><li>16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是<strong>接收</strong><br><strong>通告窗口</strong>（Receiver Window，RWND）。它告诉对方<strong>本端的 TCP 接收缓冲区还能容纳多少</strong><br><strong>字节的数据</strong>，这样对方就可以控制发送数据的速度</li><li>16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验<br>TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。<br>这也是 TCP 可靠传输的一个重要保障</li><li>16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一<br>个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏<br>移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li></ul><h6 id="三次握手连接过程"><a href="#三次握手连接过程" class="headerlink" title="三次握手连接过程"></a>三次握手连接过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：</span><br><span class="line">  <span class="number">1.</span>客户端将SYN标志位置为<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>生成一个随机的<span class="number">32</span>位的序号seq=J ， 这个序号后边第三次握手的时候是可以携带数据（数据的大小）</span><br><span class="line">第二次握手：</span><br><span class="line">  <span class="number">1.</span>服务器端接收客户端的连接： ACK=<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>服务器会回发一个确认序号： ack=客户端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br><span class="line">  <span class="number">3.</span>服务器端会向客户端发起连接请求： SYN=<span class="number">1</span></span><br><span class="line">  <span class="number">4.</span>服务器会生成一个随机序号：seq = K</span><br><span class="line">第三次握手：</span><br><span class="line">  <span class="number">1.</span>客户单应答服务器的连接请求：ACK=<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>客户端回复收到了服务器端的数据：ack=服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br></pre></td></tr></table></figure><h5 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h5><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的<br>拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中<strong>间节点阻塞掉包</strong>，<br>谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种<br>技术，即<strong>容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包</strong><br><strong>（称窗口尺寸）。</strong><br>TCP 中采用滑动窗口来进行传输控制，<strong>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于</strong><br><strong>接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0<br>时，发送方一般不能再发送数据报。</p><ul><li>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构</li></ul><p>窗口理解为缓冲区的大小<br>滑动窗口的大小会随着发送数据和接收数据而变化。<br>通信的双方都有发送缓冲区和接收数据的缓冲区<br>服务器：<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）<br>客户端<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发送方的缓冲区：</span><br><span class="line">  白色格子：空闲的空间</span><br><span class="line">  灰色格子：数据已经被发送出去了，但是还没有被接收</span><br><span class="line">  紫色格子：还没有发送出去的数据</span><br><span class="line">接收方的缓冲区：</span><br><span class="line">  白色格子：空闲的空间</span><br><span class="line">  紫色格子：已经接收到的数据</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span></span><br><span class="line"><span class="meta"># win: 滑动窗口</span></span><br><span class="line"><span class="number">1.</span> 客户端向服务器发起连接，客户单的滑动窗口是<span class="number">4096</span>，一次发送的最大数据量是<span class="number">1460</span></span><br><span class="line"><span class="number">2.</span> 服务器接收连接情况，告诉客户端服务器的窗口大小是<span class="number">6144</span>，一次发送的最大数据量是<span class="number">1024</span></span><br><span class="line"><span class="number">3.</span> 第三次握手</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span><span class="number">-9</span> 客户端连续给服务器发送了<span class="number">6</span>k的数据，每次发送<span class="number">1</span>k</span><br><span class="line"><span class="number">5.</span> 第<span class="number">10</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">2</span>k,窗</span><br><span class="line">口大小是<span class="number">2</span>k</span><br><span class="line"><span class="number">6.</span> 第<span class="number">11</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">4</span>k,窗</span><br><span class="line">口大小是<span class="number">4</span>k</span><br><span class="line"><span class="number">7.</span> 第<span class="number">12</span>次，客户端给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">8.</span> 第<span class="number">13</span>次，客户端主动请求和服务器断开连接，并且给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">9.</span> 第<span class="number">14</span>次，服务器回复ACK <span class="number">8194</span>, a:同意断开连接的请求 b:告诉客户端已经接受到方才发的<span class="number">2</span>k的数据</span><br><span class="line">c:滑动窗口<span class="number">2</span>k</span><br><span class="line"><span class="number">10.</span>第<span class="number">15</span>、<span class="number">16</span>次，通知客户端滑动窗口的大小</span><br><span class="line"><span class="number">11.</span>第<span class="number">17</span>次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</span><br><span class="line"><span class="number">12.</span>第<span class="number">18</span>次，第四次挥手，客户端同意了服务器端的断开请求</span><br></pre></td></tr></table></figure><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。</p><h5 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。</span><br><span class="line"> </span><br><span class="line">思路：</span><br><span class="line">  <span class="number">1.</span> 一个父进程，多个子进程</span><br><span class="line">  <span class="number">2.</span>父进程负责等待并接受客户端的连接</span><br><span class="line">  <span class="number">3.</span>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信</span><br></pre></td></tr></table></figure><h6 id="server-process"><a href="#server-process" class="headerlink" title="server_process"></a>server_process</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycleChild</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//子进程回收完</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//回收该子进程完成</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d被回收了\n&quot;</span>,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用SIGCHLD回收子进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recycleChild;</span><br><span class="line">    <span class="comment">//注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不停处理新客户端的链接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每连接上一个客户端，创建一个子进程处理</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程    </span></span><br><span class="line">            <span class="comment">//获取客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">            inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">            <span class="comment">//获取端口</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//不停读写</span></span><br><span class="line">            <span class="comment">//服务器读取客户端数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//接受了num个字节   </span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//接受完了</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">                write(cfd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子进程退出，等待回收 多进程别忘了回收子进程资源！！！！</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="client"><a href="#client" class="headerlink" title="client"></a>client</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf,<span class="string">&quot;recvBuf: %d\n&quot;</span>,i++);</span><br><span class="line">        <span class="comment">//输入 把\0也写入</span></span><br><span class="line">        write(fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多线程实现并发服务器-类似于线程池"><a href="#多线程实现并发服务器-类似于线程池" class="headerlink" title="多线程实现并发服务器 - 类似于线程池"></a>多线程实现并发服务器 - 类似于线程池</h5><h6 id="server-process-1"><a href="#server-process-1" class="headerlink" title="server_process"></a>server_process</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传到选定子线程的数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程通信</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line">    <span class="comment">//不停读写</span></span><br><span class="line">        <span class="comment">//服务器读取客户端数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> num = read(pinfo-&gt;fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//接受了num个字节   </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//接受完了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">            write(pinfo-&gt;fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子线程退出，记得分离！！！！！</span></span><br><span class="line">        close(pinfo-&gt;fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.连接</span></span><br><span class="line">        <span class="comment">//初始化数据</span></span><br><span class="line">        <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos)/<span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="comment">//清空数据       The  bzero()  function erases the data in the n bytes of the memory starting at the location pointed to by s, by writing zeros (bytes containing &#x27;\0&#x27;) to that area.</span></span><br><span class="line">            bzero(&amp;sockinfos[i],<span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">            <span class="comment">//设置初始值</span></span><br><span class="line">            sockinfos[i].fd=<span class="number">-1</span>;</span><br><span class="line">            sockinfos[i].tid=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从线程数组中找到可用的子线程，进行连接通信</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].tid == <span class="number">-1</span>)&#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有空闲线程,等会，重新找</span></span><br><span class="line">            <span class="keyword">if</span>(i == max <span class="number">-1</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr,&amp;cliaddr,len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建子进程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid,<span class="literal">NULL</span>,working,pinfo);</span><br><span class="line">        <span class="comment">//子线程分离</span></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="client-和前面一样"><a href="#client-和前面一样" class="headerlink" title="client - 和前面一样"></a>client - 和前面一样</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf,<span class="string">&quot;recvBuf: %d\n&quot;</span>,i++);</span><br><span class="line">        <span class="comment">//输入 把\0也写入</span></span><br><span class="line">        write(fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h5><ul><li>上图红线是发送方，虚线是接收方</li></ul><p>2MSL（Maximum Segment Lifetime）<br>主动断开连接的一方, 最后进入一个 TIME_WAIT状态, 这个状态会持续: 2msl</p><ul><li>msl: 官方建议: 2分钟, 实际是30s</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方</span><br><span class="line">必须处于TIME_WAIT 状态并持续 <span class="number">2</span>MSL 时间。</span><br><span class="line">这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。</span><br><span class="line">主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，</span><br><span class="line">被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。<span class="comment">//事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。</span></span><br><span class="line">    <span class="comment">//为什么不需要第五次挥手？如果被动关闭方没有接受到ACK，肯定对继续传送FIN，这时候主动方就知道第四次的ACK没穿送到位</span></span><br></pre></td></tr></table></figure><ul><li>半关闭</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2</span><br><span class="line">状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发</span><br><span class="line">送的数据，但是 A 已经不能再向 B 发送数据。<span class="comment">//为什么四次：第二次和第三次需要分开 ！服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</span></span><br></pre></td></tr></table></figure><ul><li>从程序的角度，可以使用 API 来控制实现<strong>半连接状态</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区别于close()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">   该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发</span><br><span class="line">出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以</span><br><span class="line">SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用 close 中止一个连接，但它只是<strong>减少描述符的引用计数</strong>，并不直接关闭连接，只有当描述符的引用<br>计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也可选择中止一个方<br>向的连接，只中止读或只中止写。<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用<br>进程都调用了 close，套接字将被释放。</li><li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。<br>但如果一个进程 close(sfd) 将不会影响到其它进程。</li></ol><h5 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h5><ul><li><p>在不调用端口复用的时候， 如果服务器端处于time_wait状态，就会占用当前端口号，直到释放掉。</p><p>比如，如果重启服务器的话，就会显示地址已经使用，导致不能重启</p></li><li><p>端口复用最常用的用途是:</p><ol><li>防止服务器重启时之前绑定的端口还未释放</li><li>程序突然退出而系统<strong>没有释放端口</strong></li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> </span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - sockfd : 要操作的文件描述符</span><br><span class="line">        - level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">        - optname : 选项的名称</span><br><span class="line">            - SO_REUSEADDR</span><br><span class="line">            - SO_REUSEPORT</span><br><span class="line">        - optval : 端口复用的值（整形）</span><br><span class="line">            - <span class="number">1</span> : 可以复用</span><br><span class="line">            - <span class="number">0</span> : 不可以复用</span><br><span class="line">        - optlen : optval参数的大小</span><br><span class="line">端口复用，设置的时机是在服务器绑定bind端口之前。</span><br><span class="line">setsockopt();</span><br><span class="line">bind();</span><br></pre></td></tr></table></figure><ul><li>查看网络相关信息的命令<br>netstat<br> 参数：-a 所有的socket<br>   -p 显示正在使用socket的程序的名称<br>   -n 直接使用IP地址，而不通过域名服务器</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int optval = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accpet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client&#x27;s ip is %s, and port is %d\n&quot;</span>, cliIp, cliPort );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小写转大写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            recvBuf[i] = <span class="built_in">toupper</span>(recvBuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大写字符串发给客户端</span></span><br><span class="line">        ret = send(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-IO多路复用"><a href="#4-6-IO多路复用" class="headerlink" title="4.6  IO多路复用"></a>4.6  IO多路复用</h3><ul><li>I&#x2F;O 多路复用使得<strong>程序能同时监听多个文件描述符</strong>，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的<br>系统调用主要有 select、poll 和 epoll</li></ul><h5 id="IO多路复用概述"><a href="#IO多路复用概述" class="headerlink" title="IO多路复用概述"></a>IO多路复用概述</h5><p>又叫IO多路转接，IO指的是针对内存</p><ul><li><p>BIO模型（线进程和客户端一一对应 accept、read会阻塞）的缺点：</p><ol><li><p>线程或者进程会消耗资源；</p></li><li><p>线程或者进程的调度消耗CPU资源；</p></li><li><p>根本问题：BOLCKING阻塞</p></li></ol></li><li><p>非阻塞，忙轮询的模型：</p><ol><li><p>提高了程序的执行效率；</p></li><li><p>但是轮询需要占用更多的CPU和系统资源</p></li></ol></li><li><p>NIO模型：</p><ol><li>需要不停调用，read就要调用n次</li></ol></li><li><p>IO多路转接技术：<br>委托内核，比较快，而且直接可以知道哪些有数据，不需要全部read一遍（select需要）</p><ol><li>select只会告诉你有几个文件描述符，有数据到达</li><li>epoll很勤快，她不仅会告诉你有几个快递到了，还会告诉你是哪个快递公司的快递</li></ol></li></ul><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><blockquote><p>主旨思想：</p><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li><li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O<br>  操作时，该函数才返回。<br>  a.这个函数是阻塞<br>  b.函数对文件描述符的检测的操作是由内核完成的</li><li>在返回时，它会告诉进程有多少（哪些）描述符要进行I&#x2F;O操作。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128   1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">//需要检测的文件描述符，传入内核，然后通过传入传出参数得到</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">     fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">   - nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span><span class="comment">//也就是检测位+1，因为数组从0开始</span></span><br><span class="line">      - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">        - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">      - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">        - <span class="comment">//委托内核检测写缓冲区是不是还可以写数据（不满的就可以写） 一般不检测</span></span><br><span class="line"> - exceptfds : 检测发生异常的文件描述符的集合 <span class="comment">//一般用不到</span></span><br><span class="line">      - ti meout : 设置的超时时间 <span class="comment">//检测的最大时间，因为不能一直阻塞，除非设置NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">       <span class="type">long</span>   tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">       <span class="type">long</span>   tv_usec;     <span class="comment">/* microseconds */</span></span><br><span class="line">     &#125;;</span><br><span class="line">- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化<span class="comment">//永久阻塞</span></span><br><span class="line">        - tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">       - tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">         </span><br><span class="line">   - 返回值 :</span><br><span class="line">  - &gt;<span class="number">1</span> : 失败</span><br><span class="line">      - &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>对应 3 4 100 101的fd：<ol><li>先定义reads 1024bit（0-1023），然后监听 3 4 100 101的fd放到reads中</li><li>用select把reads读到内核中，并且检测，检测到有数据的置位1，没数据置位0，（比如只有3 4 有数据）</li><li>然后从内核态拷贝到用户态（用户态遍历之后知道3 4 有数据），然后对有数据的进行通信</li></ol></li></ul><h6 id="select实现多路转接"><a href="#select实现多路转接" class="headerlink" title="select实现多路转接"></a>select实现多路转接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    listen(lfd,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多路转接模型</span></span><br><span class="line">        <span class="comment">//创建fd_set集合，存放需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset,tmp;<span class="comment">//底层表示1024个文件描述符</span></span><br><span class="line">        <span class="comment">//清空rdset</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">        <span class="comment">//添加lfd</span></span><br><span class="line">    FD_SET(lfd,&amp;rdset);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        tmp = rdset;</span><br><span class="line">        <span class="comment">//调用系统函数，让内核帮检测哪个有数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>,&amp;tmp,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有数据变化</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明有文件描述符对应的缓冲区数据有ret个发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd,&amp;tmp))&#123;</span><br><span class="line">                <span class="comment">//表示有新的客户端连接进来</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//新的文件描述符加入到集合中 </span></span><br><span class="line">                FD_SET(cfd,&amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//内核判断集合中有数据的文件描述符后，依次读取数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd+<span class="number">1</span>;i &lt;= maxfd;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i,&amp;tmp))&#123;</span><br><span class="line">                    <span class="comment">//说明这个文件描述符对应的客户端发来数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(i,&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        FD_CLR(i,&amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                        write(i,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul><li><p>select() 的缺点：<br>1.每次调用select，都需要把fd集合从用户态<strong>拷贝</strong>到内核态，这个开销在fd很多时会很大<br>2.同时每次调用select都需要在内核<strong>遍历传递进来的所有fd</strong>，这个开销在fd很多时也很大<br>3.select<strong>支持的文件描述符数量太小</strong>了，默认是1024<br>4.<strong>fds集合不能重用</strong>，每次都需要重置</p></li><li><p>poll解决了缺点3 4</p></li><li><p>poll接口说明</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span>  fd;     <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line"><span class="type">short</span> events;   <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line"><span class="type">short</span> revents;   <span class="comment">/* 文件描述符实际发生的事件 */</span>              <span class="comment">//调用poll的时候会传出</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">    - <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">    - timeout : 阻塞时长</span><br><span class="line">      <span class="number">0</span> : 不阻塞</span><br><span class="line">      <span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">      &gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">  - 返回值：</span><br><span class="line">    <span class="number">-1</span> : 失败</span><br><span class="line">    &gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure><h6 id="poll实现多路转接"><a href="#poll实现多路转接" class="headerlink" title="poll实现多路转接"></a>poll实现多路转接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul><li>直接在内核操作，内核用rbtree比较快，事件驱动，红黑树节点上注册有回调函数，事件到来后执行回调函数</li><li>去掉拷贝到内核的开销，并且能告知哪些文件描述符发送改变，而不只是个数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检</span></span><br><span class="line">测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向</span><br><span class="line">链表）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">-1</span> : 失败</span><br><span class="line">        &gt; <span class="number">0</span> : 文件描述符<span class="comment">//操作epoll实例的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">            - epfd : epoll实例对应的文件描述符</span><br><span class="line">            - op : 要进行什么操作</span><br><span class="line">                EPOLL_CTL_ADD:  添加 <span class="comment">//记得提前设置一个epoll_event结构</span></span><br><span class="line">                EPOLL_CTL_MOD:  修改</span><br><span class="line">                EPOLL_CTL_DEL:  删除 <span class="comment">//删除处理，第四的个参数为NULL</span></span><br><span class="line">            - fd : 要检测的文件描述符</span><br><span class="line">            - event : 检测文件描述符什么事情</span><br><span class="line"><span class="comment">// 检测函数                </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - events : 传出参数，保存了发送了变化的文件描述符的信息 <span class="comment">//之后遍历读取处理</span></span><br><span class="line">        - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">        - timeout : 阻塞时间</span><br><span class="line">            - <span class="number">0</span> : 不阻塞</span><br><span class="line">            - <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">            - &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">                </span><br><span class="line">    - 返回值：</span><br><span class="line">         - 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">         - 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure><h6 id="epoll实现多路转接"><a href="#epoll实现多路转接" class="headerlink" title="epoll实现多路转接"></a>epoll实现多路转接</h6><p>建立epoll实例，添加EPOLLIN，用epoll_wait返回所有事件，可以得到所有事件；<br>然后按照事件类型逐个处理，把新连接进来的客户端添加到epoll实例中监听，把处理好的事件从epoll实例中去掉；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd,epevs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd =epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)&#123;</span><br><span class="line">                <span class="comment">//监听的文件描述符有数据到达，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="comment">//添加到需要监听的部分 可以重用之前的epoll_event数据结构</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;epev);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//过滤写事件，也就是说对于不同时间要单独处理</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从epoll实例中删除掉</span></span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,curfd,<span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                    write(curfd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);    </span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Epoll的工作模式"><a href="#Epoll的工作模式" class="headerlink" title="Epoll的工作模式"></a>Epoll的工作模式</h5><ul><li>LT 模式 （水平触发）<br>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br> 读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>   a.用户不读数据，数据一直在缓冲区，epoll 会一直通知<br>   b.用户只读了一部分数据，epoll会通知<br>   c.缓冲区的数据读完了，不通知</li></ul><blockquote><p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这<br>种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操<br>作。如果你不作任何操作，内核还是会继续通知你的。</p></blockquote><ul><li><p>ET 模式（边沿触发）</p><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br> 读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>   a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了<br>   b.用户只读了一部分数据，epoll不通知<br>   c.缓冲区的数据读完了，不通知</p></li></ul><blockquote><p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述<br>符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，<br>并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述<br>符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成<br>未就绪），内核不会发送更多的通知（only once）。<br>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll<br>工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写<br>操作把处理多个文件描述符的任务饿死。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    - EPOLLET<span class="comment">//边沿触发 用的时候|上前面的检测事件</span></span><br></pre></td></tr></table></figure><h6 id="水平触发-默认"><a href="#水平触发-默认" class="headerlink" title="水平触发 - 默认"></a>水平触发 - 默认</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd,epevs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd =epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)&#123;</span><br><span class="line">                <span class="comment">//监听的文件描述符有数据到达，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="comment">//添加到需要监听的部分 可以重用之前的epoll_event数据结构</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;epev);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//过滤写事件，也就是说对于不同时间要单独处理</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从epoll实例中删除掉</span></span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,curfd,<span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                    write(curfd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);    </span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        <span class="comment">//fgets获取stdin的输入，阻塞</span></span><br><span class="line">        fgets(sendBuf,<span class="keyword">sizeof</span>(sendBuf),<span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="comment">//usleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="边沿触发-EPOLLET"><a href="#边沿触发-EPOLLET" class="headerlink" title="边沿触发 - EPOLLET"></a>边沿触发 - EPOLLET</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-7-UDP通信"><a href="#4-7-UDP通信" class="headerlink" title="4.7  UDP通信"></a>4.7  UDP通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">        - 参数：</span><br><span class="line">            - sockfd : 通信的fd</span><br><span class="line">            - buf : 要发送的数据</span><br><span class="line">            - len : 发送数据的长度</span><br><span class="line">            - flags : <span class="number">0</span></span><br><span class="line">            - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">            - addrlen : 地址的内存大小</span><br><span class="line">                </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">        - 参数：</span><br><span class="line">            - sockfd : 通信的fd</span><br><span class="line">            - buf : 接收数据的数组</span><br><span class="line">            - len : 数组的大小</span><br><span class="line">            - flags : <span class="number">0</span></span><br><span class="line">            - src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span> <span class="comment">//传出参数 不需要最后两个参数都可以指定NULL</span></span><br><span class="line">            - addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure><h5 id="UDP实现流程"><a href="#UDP实现流程" class="headerlink" title="UDP实现流程"></a>UDP实现流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        recvfrom(fd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP: %s,Port: %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ipbuf,<span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>,recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        sendto(fd,recvbuf,<span class="built_in">strlen</span>(recvbuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf,<span class="string">&quot;hello,i am client %d\n&quot;</span>,num++);</span><br><span class="line">        sendto(fd,sendBuf,<span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        recvfrom(fd,sendBuf,<span class="keyword">sizeof</span>(sendBuf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>,sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>广播和多播都用UDP</li></ul><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广<br>播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。<br>a.只能在局域网中使用。<br>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> </span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">    - sockfd : 文件描述符</span><br><span class="line">    - level : SOL_SOCKET</span><br><span class="line">    - optname : SO_BROADCAST</span><br><span class="line">    - optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播<span class="comment">//1</span></span><br><span class="line">    - optlen : optval的大小</span><br><span class="line"><span class="comment">//使用的时候创建广播地址的套接字IP地址设置为广播地址，也就是最后一位255</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置广播属性</span></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd,SOL_SOCKET,SO_BROADCAST,&amp;op,<span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建广播地址  因为这里服务端是主动给别人发送数据了，不需要手动绑定一个端口了，但是底层肯定还会分配一个端口给他的。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="comment">//广播地址</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.255&quot;</span>,&amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.通信</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> sendbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendbuf,<span class="string">&quot;hello,client...%d\n&quot;</span>,num++);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        sendto(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据: %d\n&quot;</span>,num);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.客户端绑定本地接受的ip和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    cliaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">int</span> ret = bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        recvfrom(fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h5><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。<br>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方<br>案。多播数据报只应该由对它感兴趣的接口接收，也就是说由<strong>运行相应多播会话应用系统的主机上</strong><br><strong>的接口接收</strong>。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网<br>使用。<br>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据</p><ul><li>组播地址：<br>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从  224.0.0.0 到 239.255.255.255 ，<br>并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">- level : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> //</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    // 客户端加入到多播组：</span></span><br><span class="line"><span class="class">    - <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">    - optname : IP_ADD_MEMBERSHIP</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* IP multicast address of group.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">// 组播的IP地址</span></span><br><span class="line">    <span class="comment">/* Local IP address of interface.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>多播通信示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 初始化多播地址 从表中选一个多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="comment">// 2.客户端绑定IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-本地套接字"><a href="#4-8-本地套接字" class="headerlink" title="4.8 本地套接字"></a>4.8 本地套接字</h3><ul><li>本地套接字的作用：本地的进程间通信<br>有关系的进程间的通信<br>没有关系的进程间的通信<br>本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 本地套接字通信的流程 - tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件:  sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">    <span class="type">char</span> sun_path[UNIX_PATH_MAX];   <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="number">1.</span> 创建监听的套接字</span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span> <span class="comment">//对local socket的数据结构</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 监听</span><br><span class="line">    listen(lfd, <span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span> 等待并接受连接请求</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">6.</span> 关闭连接</span><br><span class="line">    close();</span><br><span class="line"><span class="comment">// 客户端的流程</span></span><br><span class="line"><span class="number">1.</span> 创建通信的套接字</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的IP 端口</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 连接服务器</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">5.</span> 关闭连接</span><br><span class="line">    close();</span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-WebServer项目"><a href="#5-WebServer项目" class="headerlink" title="5.WebServer项目"></a>5.WebServer项目</h2><h3 id="5-1-阻塞非阻塞、同步异步"><a href="#5-1-阻塞非阻塞、同步异步" class="headerlink" title="5.1 阻塞非阻塞、同步异步"></a>5.1 阻塞非阻塞、同步异步</h3><ul><li>典型的一次IO的两个阶段是什么？数据就绪 和 数据读写</li></ul><ol><li>数据就绪：根据系统IO操作（现在只考虑网络IO）的就绪状态<br>阻塞<br>非阻塞</li><li>数据读写：根据应用程序和内核的交互方式<br>同步<br>异步</li></ol><ul><li>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO</li></ul><blockquote><p> 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为<br> 阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。<br> 同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是<br> 由请求方A<strong>自己来完成</strong>的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时<br> （或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以<br> 处理其它逻辑了，当<strong>B监听到事件处理</strong>完成后，会用事先约定好的通知方式，通知A处理结果。</p></blockquote><p> 同步阻塞 同步非阻塞异步阻塞异步非阻塞</p><h3 id="5-2-Unix-x2F-Linux上的五种IO模型"><a href="#5-2-Unix-x2F-Linux上的五种IO模型" class="headerlink" title="5.2 Unix&#x2F;Linux上的五种IO模型"></a>5.2 Unix&#x2F;Linux上的五种IO模型</h3><h5 id="a-阻塞-blocking"><a href="#a-阻塞-blocking" class="headerlink" title="a.阻塞 blocking"></a>a.阻塞 blocking</h5><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必<br>须等这个函数返回才能进行下一步动作</p><ol><li>有等待 阻塞 2. 有数据拷贝 同步</li></ol><h5 id="b-非阻塞-non-blocking（NIO）"><a href="#b-非阻塞-non-blocking（NIO）" class="headerlink" title="b.非阻塞 non-blocking（NIO）"></a>b.非阻塞 non-blocking（NIO）</h5><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调<br>用总是<strong>立即返回</strong>，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两<br>种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 <strong>EAGAIN</strong>。</p><h5 id="c-IO复用（IO-multiplexing）"><a href="#c-IO复用（IO-multiplexing）" class="headerlink" title="c.IO复用（IO multiplexing）"></a>c.IO复用（IO multiplexing）</h5><p>Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是<br>这些函数可以<strong>同时(非)阻塞地处理多个IO操作</strong>。而且可以同时对多个读操作、写操作的IO函数进行<strong>检测</strong>。直到有数<br>据可读或可写时，才真正调用IO操作函数。&#x2F;&#x2F;主要不是处理高并发，而是同时处理多个IO的优点</p><h5 id="d-信号驱动（signal-driven）"><a href="#d-信号驱动（signal-driven）" class="headerlink" title="d.信号驱动（signal-driven）"></a>d.信号驱动（signal-driven）</h5><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进<br>程收到SIGIO 信号，然后处理 IO 事件 </p><p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需<br>要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率 </p><p>&#x2F;&#x2F;从内核空间拷贝到用户空间还是需要拷贝，也就是同步操作，不常用</p><h5 id="e-异步（asynchronous）"><a href="#e-异步（asynchronous）" class="headerlink" title="e.异步（asynchronous）"></a>e.异步（asynchronous）</h5><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方<br>式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> aio_fildes;       <span class="comment">/* File desriptor.  */</span></span><br><span class="line">  <span class="type">int</span> aio_lio_opcode;       <span class="comment">/* Operation to be performed.  */</span></span><br><span class="line">  <span class="type">int</span> aio_reqprio;      <span class="comment">/* Request priority offset.  */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">void</span> *aio_buf;   <span class="comment">/* Location of buffer.  */</span></span><br><span class="line">  <span class="type">size_t</span> aio_nbytes;        <span class="comment">/* Length of transfer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value.  */</span></span><br><span class="line">  <span class="comment">/* Internal members.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line">  <span class="type">int</span> __abs_prio;</span><br><span class="line">  <span class="type">int</span> __policy;</span><br><span class="line">  <span class="type">int</span> __error_code;</span><br><span class="line">  <span class="type">__ssize_t</span> __return_value;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">  <span class="type">__off_t</span> aio_offset;       <span class="comment">/* File offset.  */</span></span><br><span class="line">  <span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">__off64_t</span> aio_offset;     <span class="comment">/* File offset.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-Web-Server网页服务器"><a href="#5-3-Web-Server网页服务器" class="headerlink" title="5.3 Web Server网页服务器"></a>5.3 Web Server网页服务器</h3><h5 id="网页服务器简介"><a href="#网页服务器简介" class="headerlink" title="网页服务器简介"></a>网页服务器简介</h5><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主<br>要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自<br>客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返<br>回一个 Error 信息。</p><p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则<br>先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请<br>求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针<br>对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在<br>TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的<br>头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p><blockquote><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（<strong>默认端口为80,HTTPS是443</strong>）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，<strong>HTTP可以在任何互联网协议上，或其他网络上实现</strong>。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 <strong>TCP 作为其传输层</strong>。<br>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p></blockquote><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客<br>户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方<br>法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版<br>本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求&#x2F;响应的步骤：</p><ol><li>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接<br>字连接。例如，<a href="http://www.baidu.com.(url)/">http://www.baidu.com。（URL）</a></li><li>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求<br>头部、空行和请求数据 4 部分组成。</li><li>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个<br>响应由状态行、响应头部、空行和响应数据 4 部分组成。</li><li>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连<br>接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li><li>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应<br>头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据<br>HTML 的语法对其进行格式化，并在浏览器窗口中显示。</li></ol><ul><li>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</li></ul><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</li><li>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三<br>次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</li><li>释放 TCP 连接;</li><li>浏览器将该 HTML 文本并显示内容。</li></ol><p>HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客<br>户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端<br>在没有接收到请求之前不会发送响应</p><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; </span><br><span class="line">BIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752; </span><br><span class="line">BDORZ=FFFB88E999055A3F8A630C64834BD6D0; </span><br><span class="line">__yjs_duid=1_d05d52b14af4a339210722080a668ec21614320694782; BD_HOME=1; </span><br><span class="line">H_PS_PSSID=33514_33257_33273_31660_33570_26350; </span><br><span class="line">BA_HECTOR=8h2001alag0lag85nk1g3hcm60q</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=</span><br></pre></td></tr></table></figure><h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Bdpagetype</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Bdqid</span><span class="punctuation">: </span>0xf3c9743300024ee4</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>private</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=utf-8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 26 Feb 2021 08:44:35 GMT</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Fri, 26 Feb 2021 08:44:35 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BDSVRTM=13; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BD_HOME=1; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>H_PS_PSSID=33514_33257_33273_31660_33570_26350; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=172800</span><br><span class="line"><span class="attribute">Traceid</span><span class="punctuation">: </span>1614329075128412289017566699583927635684</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span><span class="punctuation">: </span>IE=Edge,chrome=1</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br></pre></td></tr></table></figure><h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h5><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态<br>的短语，彼此由空格分隔。<br>状态代码的第一个数字代表当前响应的类型：<br>1xx消息——请求已被服务器接收，继续处理<br>2xx成功——请求已成功被服务器接收、理解、并接受<br>3xx重定向——需要后续操作才能完成这一请求<br>4xx请求错误——请求含有词法错误或者无法被执行<br>5xx服务器错误——服务器在处理某个正确请求时发生错误<br>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍<br>然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><p>更多状态码：<a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin</a></p><h4 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h4><p>服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor<br>和 Proactor，同步 I&#x2F;O 模型通常用于实现 Reactor 模式，异步 I&#x2F;O 模型通常用于实现 Proactor 模式。</p><h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><p>要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作<br>线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做<br>任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><ul><li>使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是</li></ul><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll<br>内核事件表中注册该 socket 上的写就绪事件。</li><li>当主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li></ol><h5 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h5><p>Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻<br>辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p><ol><li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，<br>以及读操作完成时如何通知应用程序（这里以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据<br>已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求<br>后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以<br>及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据<br>已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><h5 id="模拟-Proactor-模式"><a href="#模拟-Proactor-模式" class="headerlink" title="模拟 Proactor 模式"></a>模拟 Proactor 模式</h5><p>使用同步 I&#x2F;O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向<br>工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下<br>来要做的只是对读写的结果进行逻辑处理。<br>使用同步 I&#x2F;O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更<br>多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事<br>件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 <strong>CPU 数量差不多</strong>。线程池中的所<br>有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子<br>线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主<br>线程选择哪个子线程来为新任务服务，则有多种方式：</p><ul><li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流<br>选取）算法，但更优秀、更智能的算法将使任务在各个<strong>工作线程中更均匀地分配</strong>，从而减轻服务器<br>的整体压力。</li><li>主线程和所有子线程通过一个共享的工作队列来同步，<strong>子线程都睡眠在该工作队列上</strong>。当有新的任<br>务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线<br>程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在<br>工作队列上</li></ul><blockquote><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量<br>N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来<br>说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集<br>型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一<br>般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导<br>致资源浪费。</p></blockquote><ul><li><p>设置线程池目的：</p><p>空间换时间，浪费服务器的硬件资源，换取运行效率。</p><ol><li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li><li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中<br>获取，无需动态分配。</li><li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源</li></ol></li></ul><h4 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h4><p>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个<br>问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该<br>socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于<br>是就出现了两个线程同时操作一个 socket 的局面。<strong>一个socket连接在任一时刻都只被一个线程处理</strong>，可<br>以使用 epoll 的 EPOLLONESHOT 事件实现。<br>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异<br>常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事<br>件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思<br>考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个<br>socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进<br>而让其他工作线程有机会继续处理这个 socket。</p><h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。<br>有的应用层协议头部包含数据包类型字段，每种类型可以<strong>映射为逻辑单元的一种执行状态</strong>，服务器可以<br>根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE( Package _pack ) </span><br><span class="line">&#123;</span><br><span class="line">    PackageType _type = _pack.GetType();</span><br><span class="line">    <span class="keyword">switch</span>( _type )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            process_package_A( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            process_package_B( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。<br>状态之间的转移是需要状态机内部驱动，如下代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE() </span><br><span class="line">&#123;</span><br><span class="line">    State cur_State = type_A;</span><br><span class="line">        <span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">    &#123;</span><br><span class="line">        Package _pack = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span>( cur_State )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_package_state_A( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_package_state_B( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状<br>态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过<br>getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据<br>包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一<br>趟循环时，它将执行新的状态对应的逻辑。</li></ul><h4 id="服务器压力测试"><a href="#服务器压力测试" class="headerlink" title="服务器压力测试"></a>服务器压力测试</h4><p>Webbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发</p><ul><li>测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。</li><li>展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量。</li></ul><p>基本原理：Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的<br>结果通过pipe 告诉父进程，父进程做最终的统计结果。</p><h2 id="Ubuntu一些小操作"><a href="#Ubuntu一些小操作" class="headerlink" title="Ubuntu一些小操作"></a>Ubuntu一些小操作</h2><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><h4 id="文本文件上传"><a href="#文本文件上传" class="headerlink" title="文本文件上传"></a>文本文件上传</h4><p>​文本文件的换行符</p><p>Windows : \r\n</p><p>Linux : \n</p><p>可以在 Notepad ++ 里观察到此区别</p><p>视图 | 显示符号 | 显示行尾符</p><h4 id="修改格式"><a href="#修改格式" class="headerlink" title="修改格式"></a>修改格式</h4><p>换行符的转换：</p><p>编辑 | 文档格式转换 | 转换为 UNIX格式</p><p>注意：只有在编辑 SHELL 脚本时，才需要转换</p><p>其他格式的文件一般都不需要转换，如*.xml, *.java</p><p><strong>演示</strong>：Shell脚本的编辑 。。</p><ol><li><p>用 Notepad++打开编辑 mytest.sh</p></li><li><p>转成 Unix格式 \n</p></li><li><p>上传至Linux</p></li><li><p>chmod +x mytest.sh</p></li><li><p>运行 .&#x2F;mytest.sh</p></li></ol><h3 id="命令类"><a href="#命令类" class="headerlink" title="命令类"></a>命令类</h3><h5 id="1-归档"><a href="#1-归档" class="headerlink" title="1. 归档"></a>1. 归档</h5><p>tar , 即 tape archive 档案打包</p><p>创建档案包</p><p>tar  -cvf  example.tar  example</p><p>其中，</p><p>  c ,  表示 create 创建档案</p><p>  v , 表示 verbose 显示详情</p><p>  f ,  表示 file</p><p>也可以多个目录打包 tar -cvf xxx.tar file1 file2 file3 </p><p>还原档案包</p><p>tar  -xvf  example.tar</p><p>tar  -xvf  example.tar  -C  outdir</p><p>其中，-C 参数指定目标目录，默认解到当前目录下</p><h5 id="2-压缩解压"><a href="#2-压缩解压" class="headerlink" title="2. 压缩解压"></a>2. 压缩解压</h5><p>先前的tar格式并没有压缩，体积较大</p><p>并档并压缩</p><p>tar  -zcvf  example.tar.gz  example</p><p>解压缩</p><p>tar  -zxvf  example.tar.gz</p><p>tar  -zxvf  example.tar.gz  -C  outdir</p><p>通常我们所见的，都是 *.tar.gz 这种格式</p><h5 id="7z"><a href="#7z" class="headerlink" title="7z"></a>7z</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install p7zip-full</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">7z a -t7z -r filename.7z ./*</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">7z x filename.7z -r -o./* </span><br></pre></td></tr></table></figure><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>定义环境变量</p><p>export OUTDIR&#x3D;&#x2F;opt&#x2F;</p><p>显示环境变量</p><p>echo ${OUTDIR}</p><p>查看所有环境变量</p><p>printenv</p><h5 id="查看当前进程"><a href="#查看当前进程" class="headerlink" title="查看当前进程"></a>查看当前进程</h5><p>进程id：echo $$</p><p>终端设备：tty</p><h6 id="找函数"><a href="#找函数" class="headerlink" title="找函数"></a>找函数</h6><p>man 2 xxx</p><p>或者 man xxx +tab键</p><h5 id="查看网络相关信息的命令"><a href="#查看网络相关信息的命令" class="headerlink" title="查看网络相关信息的命令"></a>查看网络相关信息的命令</h5><p>netstat<br> 参数：-a 所有的socket<br>   -p 显示正在使用socket的程序的名称<br>   -n 直接使用IP地址，而不通过域名服务器</p><p> netstat -anp|grep xxxx<br>查看端口号占用信息</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><h4 id="利用Core文件查看异常的信息"><a href="#利用Core文件查看异常的信息" class="headerlink" title="利用Core文件查看异常的信息"></a>利用Core文件查看异常的信息</h4><ol><li>用ulimit -a查看Core文件允许产生的大小，一般是0；然后改为一定值 ulimit -c 1024</li><li>然后用-g调试编译.c文件</li><li>然后调试改文件，输入core-file core就能看到</li><li>这里系统版本不同，生成不出来Core文件</li></ol><p>bt打印堆栈</p><h4 id="Linux下的时间设置"><a href="#Linux下的时间设置" class="headerlink" title="Linux下的时间设置"></a>Linux下的时间设置</h4><p>时钟时间 ＝ 阻塞时间 ＋ 就绪时间 ＋运行时间；</p><p>其中：运行时间&#x3D;用户CPU时间（用户的进程获得了CPU资源以后，在用户态执行的时间。）+系统CPU时间（用户进程获得了CPU资源以后，在内核态的执行时间。）；</p><ul><li>因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务</li></ul><h5 id="前后台进程"><a href="#前后台进程" class="headerlink" title="前后台进程"></a>前后台进程</h5><p>默认前台进程，阻塞</p><p>加上&amp;改为后台进程，改为非阻塞 ，但是注意要去查看，并且kill -9：<code>./sigprocmask&amp;</code></p><h5 id="段错误究竟是怎么发生的？段错误的复现为什么这么难？"><a href="#段错误究竟是怎么发生的？段错误的复现为什么这么难？" class="headerlink" title="段错误究竟是怎么发生的？段错误的复现为什么这么难？"></a>段错误究竟是怎么发生的？段错误的复现为什么这么难？</h5><p>段错误是个迷，有的人碰到过几次，有的人怎么也碰不到，这是由于神秘莫测的调度算法导致的。【潇潇_暮雨】小伙伴提出了，这是调用了不可重入的函数。《Linux&#x2F;UNIX系统编程手册》第21.1.2节 对可重入函数进行了详细的解释，有兴趣的可以去翻一下。</p><p>可重入函数的意思是：函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。通俗点讲，就是存在一个函数，A线程执行一半，B线程抢过CPU又来调用该函数，执行到1&#x2F;4倍A线程抢回执行权。在这样不断来回执行中，不出问题的，就是可重入函数。多线程中每个线程都有自己的堆栈，所以如果函数中只用到局部变量肯定是可重入的，没问题的。但是更新了全局变量或静态数据结构的函数可能是不可重入的。假设某线程正在为一个链表结构添加一个新的链表项，而另外一个线程也视图更新同一链表。由于中间涉及多个指针，一旦另一线程中断这些步骤并修改了相同指针，结果就会产生混乱。但是并不是一定会出现，一定是A线程刚好在修改指针，另外一线程又去修改才会出现。这就是为什么该问题复现难度较高的原因。</p><p>作者在文中指出，将静态数据结构用于内部记账的函数也是不可重入的。其中最明显的例子就是stdio函数库成员（printf()、scanf()等），它们会为缓冲区I&#x2F;O更新内部数据结构。所以，如果在捕捉信号处理函数中调用了printf()，而主程序又在调用printf()或其他stdio函数期间遭到了捕捉信号处理函数的中断，那么有时就会看到奇怪的输出，设置导致程序崩溃。虽然printf()不是异步信号安全函数，但却频频出现在各种示例中，是因为在展示对捕捉信号处理函数的调用，以及显示函数中相关变量的内容时，printf()都不失为一种简单而又便捷的方式。真正的应用程序应当避免使用该类函数。</p><p>printf函数会使用到一块缓冲区，这块缓冲区是使用malloc或类似函数分配的一块静态内存。所以它是不可重入函数</p><h4 id="虚拟地址空间层次划分"><a href="#虚拟地址空间层次划分" class="headerlink" title="虚拟地址空间层次划分"></a>虚拟地址空间层次划分</h4><p>从操作系统层级上看，虚拟地址空间主要分为两个部分内核区和用户区。</p><p><strong>一、内核区</strong></p><ol><li>内核空间为内核保留，<strong>不允许应用程序读写该区域的内容</strong>或直接调用内核代码定义的函数</li><li><strong>内核总是驻留在内存中</strong>，是操作系统的一部分。</li><li>系统中<strong>所有进程</strong>对应的<strong>虚拟地址空间的内核区</strong>都会<strong>映射到同一块物理内存</strong>上（<strong>系统内核只有一个</strong>）</li></ol><p><strong>二、用户区</strong></p><p><strong>每个进程的虚拟地址空间都是从 0 地址开始的</strong>，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G（以 32 位系统的虚拟地址空间为例），里边分为多个区块。</p><p>各分区由低地址到高地址依次是：</p><ol><li><strong>保留区:</strong> 位于虚拟地址空间的最底部，<strong>未赋予物理地址</strong>。任何对它的引用都是非法的，程序中的<strong>空指针（NULL）指向的就是这块内存地址</strong>。</li><li><strong>.text段: 代码段也称正文段或文本段</strong>，通常用于存放程序的<strong>执行代码</strong> (即 CPU 执行的<strong>机器指令，二进制</strong>)，代码段一般情况下是<strong>只读</strong>的，这是对执行代码的一种保护机制。</li><li><strong>.data段</strong>: <strong>数据段</strong>通常用于存放程序中<strong>已初始化且初值不为 0 的全局变量和静态变量</strong>。数据段属于**静态内存分配 (静态存储区)**，可读可写。</li><li><strong>.bss段: 未初始化以及初始为 0 的全局变量和静态变量</strong>，操作系统会将这些<strong>未初始化变量初始化为 0</strong>；</li><li><strong>堆(heap)<strong>：用于存放进程运行时</strong>动态分配的内存</strong>。<ul><li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li><li>堆向高地址扩展 (即 “向上生长”)，是<strong>不连续</strong>的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而<strong>链表从低地址向高地址遍历</strong>。</li></ul></li><li><strong>内存映射区(mmap)：**作为内存映射区**加载磁盘文件**，或者</strong>加载程序运作过程中需要调用的动态库**。</li><li><strong>栈(stack):</strong> 存储<strong>函数内部声明的非静态局部变量，函数参数，函数返回地址等信息</strong>，栈内存由<strong>编译器自动分配释放</strong>。<strong>栈</strong>和堆相反地址 <strong>“向下生长”</strong>，分配的<strong>内存是连续</strong>的。</li><li><strong>命令行参数</strong>：存储进程执行的时候<strong>传递给 main() 函数的参数，argc，argv []</strong></li><li><strong>环境变量</strong>: 存储和进程相关的环境变量，比如：<strong>工作路径</strong>，<strong>进程所有者</strong>等信息</li></ol><h2 id="C函数记录"><a href="#C函数记录" class="headerlink" title="C函数记录"></a>C函数记录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>；</span><br><span class="line"></span><br><span class="line">第一个参数：（buffer）</span><br><span class="line">这个参数就是接收字符串的字符数组。其大小必须要大于所接收的字符串的大小，否则的话会有空间不够从而导致内存溢出的风险。（这里比较大小时还要考虑到字符串最后的 ‘\0’）</span><br><span class="line"></span><br><span class="line">第二个参数：（format）</span><br><span class="line">这个参数就是要传的字符串了。</span><br><span class="line"></span><br><span class="line">其余参数：</span><br><span class="line">剩下的参数其实算是对第二个参数format的补充，可有可无，视情况而定</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">perror(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">作用：调用系统或者库函数有错的时候，发出错误信息</span><br></pre></td></tr></table></figure><pre><code> sizeof 和strlen 有本质上的区别。sizeof 是C 语言的一种单目运算符，如++、–等，并不是函数，sizeof 的优先级为2 级，比/、% 等3 级运算符优先级高，sizeof以字节的形式给出操作数的存储空间的大小。而 strlen 是一个函数，是由 C 语言的标准库提供的。strlen 计算的 是字符串的长度。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format [, argument] … )</span>;</span><br><span class="line">    跟 <span class="built_in">printf</span> 在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出;</span><br><span class="line"><span class="number">1.</span> 可以用<span class="built_in">sprintf</span>来将其他类型转换字符串类想</span><br><span class="line"><span class="number">2.</span> 可以生成字符串，拼接 格式等</span><br><span class="line">     <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello,%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>输入一串格式化的字符串，经过处理后可以将 %s %f %d等占位符替换为对应的数据；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">… 表示函数的参数个数可变，典型的如<span class="built_in">printf</span>()</span><br><span class="line"></span><br><span class="line">第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>  <span class="comment">// 重载了func函数，不重载也行</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">char</span> *res = <span class="literal">NULL</span>; </span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    res = func(format, ap);  </span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> res ;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>        <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;函数与<span class="built_in">sprintf</span>()函数对应，只是在函数调用时，把上面的...对应的一个个变量用va_list调用所替代。在函数调用前ap要通过va_start()宏来动态获取。</span><br><span class="line"><span class="number">2.</span> 结构体va_list用来存参数列表，</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>  //<span class="title">I</span>/<span class="title">O</span> <span class="title">vector</span>，与<span class="title">readv</span>和<span class="title">wirtev</span>操作相关的结构体</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/uio.h&gt;</span><br><span class="line"><span class="comment">/* Structure for scatter/gather I/O. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">     <span class="type">void</span> *iov_base; <span class="comment">/* Pointer to data. */</span></span><br><span class="line">     <span class="type">size_t</span> iov_len; <span class="comment">/* Length of data. */</span></span><br><span class="line">&#125;;</span><br><span class="line">成员iov_base指向一个缓冲区，这个缓冲区是存放readv所接收的数据或是writev将要发送的数据。</span><br><span class="line">成员iov_len确定了接收的最大长度以及实际写入的长度。   </span><br><span class="line">readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）</span><br><span class="line">    </span><br><span class="line">HTTP响应的时候配合writev(),写入响应头和体</span><br><span class="line">    writev(m_sockfd,m_iv,m_iv_count);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 计算机网络 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法 - 基础算法</title>
      <link href="/2023/11/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1. 快排"></a>1. 快排</h3><p>分治，选一个数，左边都小于等于数，右边都大于等于数，换完之后x不一定在分界点</p><ul><li>难点是划分</li><li>scanf比流输入快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = IntStream.range(<span class="number">0</span>, n).map(i -&gt; in.nextInt()).toArray();</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, n).mapToObj(i -&gt; arr[i] + <span class="string">&quot; &quot;</span>).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l ,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l -<span class="number">1</span>, j = r +<span class="number">1</span>, x = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; x)&#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; x)&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quick_sort(arr, l, j);</span><br><span class="line">        quick_sort(arr,j+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l ,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j-- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j ) <span class="built_in">swap</span> (q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-归并"><a href="#2-归并" class="headerlink" title="2. 归并"></a>2. 归并</h3><ol><li>[L,R]-&gt;[L, mid], [mid + 1, R]</li><li>递归排序[L, mid], [mid + 1, R]</li><li>归并，将左右两个有序序列合并为一个有序序列</li></ol><ul><li>重点是合二为一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N], temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先划分</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(p, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(p, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt;= p[j]) temp[k++] = p[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++] = p[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) temp[k++] = p[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) temp[k++] = p[j++];</span><br><span class="line">    <span class="comment">//还给p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span> ; i&lt;= r; i++, j++) p[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(p, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-求逆序对"><a href="#2-1-求逆序对" class="headerlink" title="2.1 求逆序对"></a>2.1 求逆序对</h4><p>当q[j]加入归并的下一个值时，q[i]之前的数都小于等于q[j],q[i]之后的数都大于q[j]。</p><p>所以此时q[j]加入合并消除的逆序对是q[i]到q[mid]之间的所有的数(之间的数都大于q[j])。</p><p>注意：我之前写错的方式使用了j - i + 1，但是j到mid + 1之间数本来就在j之前，没有消除逆序对，所以正确的应该是mid - i + 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N],temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">merge_sort</span>(p, l, mid) + <span class="built_in">merge_sort</span>(p, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 归并过程</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt;= p[j]) temp[k++] = p[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = p[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>; <span class="comment">// 消除的逆序对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)  &#123;</span><br><span class="line">      temp[k++] = p[i++];</span><br><span class="line">      <span class="comment">// 扫尾不用加上下面这句，因为之前合并的时候mid - i + 1意思是当前i以后的所有数字都大于j，包含了扫尾的那些数，然后每个j都处理了一次，在扫尾的时候就不用重复处理了</span></span><br><span class="line">        <span class="comment">// 这时候i就是mid-1</span></span><br><span class="line">      <span class="comment">// res += mid - i + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) temp[k++] = p[j++];</span><br><span class="line">    <span class="comment">// 物归原主</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) p[i] = temp[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">merge_sort</span>(p, <span class="number">0</span>, n<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-整数二分"><a href="#3-整数二分" class="headerlink" title="3.整数二分"></a>3.整数二分</h3><p>一般有单调性可以二分，有时候没有单调性也能二分。二分的本质不是单调性，是边界性。</p><ul><li><p>分为两个部分，<strong>一半部分满足条件，另一半不满足条件，就能够找到这个边界</strong></p></li><li><p>按照边界是属于左半边还是右半边的条件，可以分为两个模板。两个模板分别要记熟悉，否则边界条件经常错误。</p></li><li><p>注意这里是求得的边界情况是满足check()函数的最后一个边界，也是就是边界情况考虑&lt;&#x3D; 或者 &gt;&#x3D;,因为最后返回的值是l</p></li></ul><blockquote><p>实际做的思路：</p><ol><li><p>先写一个mid &#x3D; l + r &gt;&gt; 1，写一个check函数，把结果控制在边界位置;</p></li><li><p>想一下如何更新l 和 r ,如果l &#x3D; mid 那就要补上加一 mid &#x3D; l + r + 1 &gt;&gt; 1 ，如果 r &#x3D; mid 就不用补上</p></li><li><p>l 和 r 相差 1，这个不变</p></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个大于等于 x 的数</span></span><br><span class="line"><span class="keyword">if</span> (p[mid] &gt;=  x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个小于等于x的数</span></span><br><span class="line"><span class="keyword">if</span> (p[mid] &lt;= x) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-1-求数占的区间"><a href="#3-1-求数占的区间" class="headerlink" title="3.1 求数占的区间"></a>3.1 求数占的区间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q; </span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= a[mid]) r = mid; <span class="comment">// [l, mid]和[mid + 1, r]</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[l] != num) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,l);</span><br><span class="line">        </span><br><span class="line">         l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span> (num &gt;= a[mid]) l = mid; <span class="comment">// [l, mid - 1]和[mid, r]</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[l] != num) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-浮点数二分"><a href="#4-浮点数二分" class="headerlink" title="4.浮点数二分"></a>4.浮点数二分</h3><ol><li>不用怎么考虑边界问题，小到一定的位数1e-6就可以把边界当做答案</li><li>精度问题可以自己调整： 如果题目保留4位小数，精度写1e-6; 5位，1e-7;至少要多2</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-大整数"><a href="#5-大整数" class="headerlink" title="5.大整数"></a>5.大整数</h3><ol><li>存储： 大整数存储一般倒着存到数组中，因为加法可能要进位，在数组尾部加一个数更方面，否则正着放需要全部都往后移</li></ol><h4 id="5-1-高精度加法"><a href="#5-1-高精度加法" class="headerlink" title="5.1 高精度加法"></a>5.1 高精度加法</h4><p>反向存储，输出反向输出 （因为要进位，需要在高位上补数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 别忘了第一位 可能进位</span></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-高精度减法"><a href="#5-2-高精度减法" class="headerlink" title="5.2 高精度减法"></a>5.2 高精度减法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 去掉前置 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A,vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B [i]) <span class="keyword">return</span> A[i] - B[i] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-高精度乘以低精度"><a href="#5-3-高精度乘以低精度" class="headerlink" title="5.3 高精度乘以低精度"></a>5.3 高精度乘以低精度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 要么A没算完，要么t不等于0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-4-高精度除以低精度"><a href="#5-4-高精度除以低精度" class="headerlink" title="5.4 高精度除以低精度"></a>5.4 高精度除以低精度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6. 前缀和"></a>6. 前缀和</h3><p>快速求出一段元素的和</p><ul><li>把边界S[0] &#x3D; 0,然后从S[1]开始往后存，因为要用S[r] - S[l-1]来计算前缀和，所以把边界0先存进去</li></ul><h4 id="6-1-一维前缀和"><a href="#6-1-一维前缀和" class="headerlink" title="6.1 一维前缀和"></a>6.1 一维前缀和</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="6-2-二维前缀和"><a href="#6-2-二维前缀和" class="headerlink" title="6.2 二维前缀和"></a>6.2 二维前缀和</h4><ul><li>注意是x1 - 1， y1 - 1；这个写的时候要想好，别忘了-1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="7-差分"><a href="#7-差分" class="headerlink" title="7. 差分"></a>7. 差分</h3><p>差分和前缀和是逆运算。如果B数组是A数组的前缀和，那么A是B的差分，也就是 a[i] &#x3D; b[i] - b[i-1];</p><ul><li>首先是假想一个B数组是差分数组，使得a &#x3D; f(b)。 b[i] &#x3D; a[i] - a[i-1]; b[1] &#x3D; a[1];</li><li>差分不用考虑差分数组的构造，直接插一遍元素就行insert(i, i, a[i])。因为按照原理，假定a数组最开始全是0，那么一开始b就是a的差分数组，对于每一个a[i]，相当于插入一个数，只不过是插入的范围是 i 到 i。</li><li>这里insert既做了差分的初始化，又做了插入数据的操作。</li></ul><h4 id="7-1-一维差分"><a href="#7-1-一维差分" class="headerlink" title="7.1 一维差分"></a>7.1 一维差分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B是A的差分数组，给区间[l, r]中的A每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><h5 id="7-1-1-差分例题"><a href="#7-1-1-差分例题" class="headerlink" title="7.1.1 差分例题"></a>7.1.1 差分例题</h5><p>向A数组一定区间插入数c，这样的插入有很多组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把插入的操作从O(N) 转到 O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="comment">// 初始化差分数组</span></span><br><span class="line">        <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">// b[i] = a[i] - a[i-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间插入c</span></span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还原A</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = b[i] + a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-二维差分"><a href="#7-2-二维差分" class="headerlink" title="7.2 二维差分"></a>7.2 二维差分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br><span class="line">    </span><br><span class="line">    <span class="number">1.</span><span class="built_in">insert</span>()函数 b[x1][y1] += c, [x1][y2 + <span class="number">1</span>] -= c, b[x2 + <span class="number">1</span>][y1] -=c, b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] +=c;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> 所以还原A矩阵就是a [i][j] = b[i][j]+ a[i<span class="number">-1</span>][j] + a[i][j<span class="number">-1</span>] - a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><h3 id="8-双指针"><a href="#8-双指针" class="headerlink" title="8. 双指针"></a>8. 双指针</h3><ul><li>从暴力的N2变成O(N),利用单调关系</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不满足 j++</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ; <span class="comment">// 右边是 i，左边是j，也就是对于每个i，j最左能到什么情况。而j具有单调性，只能往右走(因为上一次的j就是移动到不满足check(i,j)函数为止)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h3 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9. 位运算"></a>9. 位运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>求n的二进制表示中第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n <span class="comment">// 如果是n是1100，lowbit(n) = 100</span></span><br><span class="line">    <span class="comment">// 原理是 x&amp;-x = x&amp;(~x +1) x取反再加1</span></span><br><span class="line">    <span class="comment">// -x 是 </span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 反转第k位二进制数 k = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2.</span>..</span><br><span class="line">    i^(<span class="number">1</span> &lt;&lt; k); <span class="comment">// 0变1, 1变0.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于有符号整数：</span><br><span class="line">正数的原码符号位是<span class="number">0</span>， 负数的符号位是<span class="number">1</span>，符号位一般是最高位    </span><br><span class="line">正数的反码等于本身，负数的反码除将其绝对值的原码的每一位取反而得到的：用于表示负数</span><br><span class="line">正数的补码等于本身，负数的补码等于绝对值的原码的符号位改为<span class="number">1</span>，然后加<span class="number">1</span>来表示的：计算机中没有减法，减法看做是加法的补码操作</span><br><span class="line">    （在计算机中负数用原码的补码来表示）</span><br><span class="line">    比如  <span class="number">6</span>是<span class="number">00.</span>.<span class="number">.0110</span>， <span class="number">-5</span>是 <span class="number">11.</span>.<span class="number">.1001</span></span><br></pre></td></tr></table></figure><h3 id="10-离散化"><a href="#10-离散化" class="headerlink" title="10.离散化"></a>10.离散化</h3><p>数域跨度很大，实际用到的数个数不大，数很<strong>稀疏</strong>（总不能开个很大的数组求前缀和吧，所以需要用到映射）</p><ul><li><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p></li><li><p>离散化首先需要排序去重：</p></li><li><pre><code class="cpp">1. 排序：sort(alls.begin(),alls.end())2. 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// 离散化，映射到数组a[i]中，下标是离散化后对应的自然数，值是原数</span><br><span class="line">vector&lt;int&gt; alls; // 存储所有待离散化的值</span><br><span class="line">sort(alls.begin(), alls.end()); // 将所有值排序</span><br><span class="line">alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素</span><br><span class="line"></span><br><span class="line">// 二分求出x对应的离散化的值</span><br><span class="line">int find(int x) // 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l = 0, r = alls.size() - 1;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r + 1; // 映射到1, 2, ...n 之后前缀和好处理边界0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>unique()函数底层实现原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>])<span class="comment">//如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];<span class="comment">//每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;<span class="comment">//返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p>把查询左右端点数l,r和之前插入数的下标x都放进去。alls排序、去重</p><p>映射后离散的数组成一个连续的数组，找到l和r对于数组中的位置，前缀和相减就是区间和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">//存储下标</span></span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= alls[mid]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取add</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;c);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 query</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理插入 产生a[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-区间合并"><a href="#11-区间合并" class="headerlink" title="11. 区间合并"></a>11. 区间合并</h3><ul><li>记得先排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>()); <span class="comment">//优先左端点排序，然后右端点排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>; <span class="comment">// 维护一个当前的区间，左端点一定是最小的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;<span class="comment">// 分散的区间，一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); <span class="comment">// 包含两种情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-静态单链表"><a href="#1-静态单链表" class="headerlink" title="1. 静态单链表"></a>1. 静态单链表</h3><blockquote><h4 id="重要性："><a href="#重要性：" class="headerlink" title="重要性："></a>重要性：</h4><p>因为c++中new比较慢，用数组模拟链表，这样的静态链表会比较快。</p><p>而且写出数组写法比较短，之后写邻接表，写图论都用这数组模拟的方法。</p><ol start="2"><li>cpp的编译器会开O2优化（会进行一系列的优化操作，包括但不限于内联函数、循环展开、常量传播、死代码消除和指令调度等。这些优化操作可以使生成的机器代码更加高效，从而提高程序的性能）<br>但是在算法题的时候没有开优化，所以用数组模拟比STL快一些</li></ol><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>用数组模拟要提前设置好 head 或者 左右节点，然后别忘了下标变过了，单链表是从0开始，双链表从2开始，题目给出第i个结点时，注意下标写法。</p></blockquote><ul><li>静态链表因为有idx，更体现第几次插入的之间的顺序关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="comment">// 这里head是一个指针记录的作用，只是存了头结点的下标，区别于dummy节点，那是一个实质节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除下标为k的后面一个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k点后面</span></span><br><span class="line"><span class="comment">// 知道前一个节点的下标后插入才能实现O（1），否则链表需要依次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-静态双链表"><a href="#2-静态双链表" class="headerlink" title="2. 静态双链表"></a>2. 静态双链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-模拟栈-x2F-模拟队列"><a href="#3-模拟栈-x2F-模拟队列" class="headerlink" title="3. 模拟栈 &#x2F; 模拟队列"></a>3. 模拟栈 &#x2F; 模拟队列</h3><p>数组模拟栈的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><h4 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h4></li></ol><p>注意空间的利用 当tt和hh到达N的时候，重新利用之前的数组空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// y总的模板tt是 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算机处理表达式"><a href="#4-计算机处理表达式" class="headerlink" title="4.计算机处理表达式"></a>4.计算机处理表达式</h3><blockquote><ol><li><p>前缀表达式：操作符在操作数的前面，比如 +-543<br><strong>计算过程：</strong>从右向左扫描，遇到数字入栈，遇到运算符，对两数做计算，结果入栈，一直到最左端</p></li><li><p>中缀表达式：操作符在操作数的中间，这也是人类最容易识别的算术表达式 3+4-5</p><p><strong>计算过程：</strong>一般是二元运算，还有（）的问题</p></li><li><p>后缀表达式：操作符在操作数的后面，比如 34+5-<br><strong>计算过程：</strong>从左往右扫描，遇到数字入栈，遇到运算符，对两数做计算，结果入栈，一直到最左端</p></li></ol><ul><li>后缀表达式是树的后续遍历，不需要括号，中缀是中序遍历，需要括号；树的叶子结点是数字，根节点是表达式</li></ul></blockquote><p>中缀表达式：如何判断某颗子树被遍历完 《&#x3D;&#x3D;》 <strong>当前的运算符优先级 &lt;&#x3D; 上一个优先级</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前计算表达式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) x = a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) x = a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) x = a * b;</span><br><span class="line">    <span class="keyword">else</span> x = a / b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">                x = x * <span class="number">10</span> + str[j ++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i = j - <span class="number">1</span>; <span class="comment">// 别忘了更新i</span></span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">             op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;<span class="comment">// 计算时为空 或者 上一步的运算符比这一步等级高 就能进行计算</span></span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c]) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-单调栈"><a href="#5-单调栈" class="headerlink" title="5. 单调栈"></a>5. 单调栈</h3><p>老是忘记写法，多记几次</p><p>左边第一个小的数 i从0开始 维护一个递增的栈</p><p>右边第一个小的数 i从 n-1开始 维护一个递增的栈</p><blockquote><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>在左边或者右边维护一个栈， 栈是单调递增或者递减的</p><h4 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h4><ol><li>先想暴力的，发现有些没有用的数可以删掉，然后发现单调性</li><li>维护单调性，如果求极值就维护左右两端点，如果是求其中值就用二分</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ; <span class="comment">// 维护单调栈</span></span><br><span class="line">    stk[ ++ tt] = i; <span class="comment">// 别忘了插入当前的数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-单调队列"><a href="#6-单调队列" class="headerlink" title="6. 单调队列"></a>6. 单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p><blockquote><p>单调队列解决滑动窗口，不仅处理尾部来保证单调性，而且要处理窗口滑动导致的极值消失问题</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-KMP"><a href="#7-KMP" class="headerlink" title="7. KMP"></a>7. KMP</h3><p>求出模式串 P 在字符串 S 中所有出现的位置的起始下标</p><blockquote><p>想一个ne数组，就是前缀和后缀相同的最大长度。这样，当前位置不匹配的时候，就可以直接下移到ne[j]的位置匹配了。</p><ol><li>求得这个ne数组，和以下的kmp类似</li><li>搜索kmp，不匹配就退到ne[j]，匹配就j++，如果整个子串都匹配完了就输出出来，然后再退到ne[j];</li></ol></blockquote><p>求ne，就是自己和自己匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"></span><br><span class="line">求!!!模式串(子串)!!!的Next数组：</span><br><span class="line">    <span class="comment">// i从2开始 , 因为ne[1] = 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// j 没有退回起点，并且当前的s[i]不能和p[j+1]匹配(这个j是从0开始的)</span></span><br><span class="line">    <span class="comment">// j表示的是退回的坐标点， j = 0表示退回到起点，下一个是第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j]; <span class="comment">//尝试失败，退一步</span></span><br><span class="line">    <span class="comment">// 如果能匹配了，则更新j到j + 1</span></span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="comment">// 不管这样，都要设置ne[i]</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 注意i从1开始读取</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// j 没有退回起点，并且当前的s[i]不能和p[j+1]匹配(这个j是从0开始的)</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">// 字母可以往匹配，往后一个</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="comment">// 整个p都能匹配,匹配成功一个子串</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Trie树-字典树"><a href="#8-Trie树-字典树" class="headerlink" title="8. Trie树 字典树"></a>8. Trie树 字典树</h3><p>高效地存储和查找<strong>字符串集合</strong>的数据结构；</p><p>一般字母类型不会很多，把单词存起来成为一棵树，然后可以用于查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// son[][] 存储树的每个结点的子节点 也就是每行是一个节点，列是26个字母</span></span><br><span class="line"><span class="comment">// cnt[] 存储每个节点结尾的单词数量</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 往下找子节点，如果不存在就添加子节点</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; </span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 某一结点没找到，返回</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-并查集"><a href="#9-并查集" class="headerlink" title="9. 并查集"></a>9. 并查集</h3><blockquote><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol><li>讲两个集合合并</li><li>询问两个元素是否在一个集合中 （判断是否连通，是否在一个连通子集中）</li></ol><h3 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h3><p>搜索是O(1)很快</p><p>每个集合用一颗树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><ol><li><p>如何判断树根 if (p[x] &#x3D;&#x3D; x)</p></li><li><p>如何求x的集合编号 while (p[x] !&#x3D; x) x &#x3D; p[x];</p></li><li><p>如何合并两个集合，p[x]是x的集合编号，p[y]是y的集合编号，p[x] &#x3D; y</p></li></ol><h3 id="记："><a href="#记：" class="headerlink" title="记："></a>记：</h3><ol><li>记find函数写法（初始化）</li><li>其他额外维护的size[]和distance[]的维护，额外去想</li></ol></blockquote><h4 id="1-朴素并查集"><a href="#1-朴素并查集" class="headerlink" title="1) 朴素并查集"></a>1) 朴素并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// p[x] = find(p[x]);是路径压缩，把非根节点的p[x]都指向祖宗节点</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); </span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h4 id="2）-维护size的并查集"><a href="#2）-维护size的并查集" class="headerlink" title="2） 维护size的并查集"></a>2） 维护size的并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> p[N], size[N];</span><br><span class="line">   <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">       <span class="keyword">return</span> p[x];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">       p[i] = i;</span><br><span class="line">       size[i] = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line"><span class="keyword">if</span> (find[a] != find[b])</span><br><span class="line">   &#123;</span><br><span class="line">       size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">   p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3）-维护到祖宗节点距离的并查集"><a href="#3）-维护到祖宗节点距离的并查集" class="headerlink" title="3） 维护到祖宗节点距离的并查集"></a>3） 维护到祖宗节点距离的并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">   <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回x的祖宗节点 ；顺便做了路径压缩并且得到x到祖宗的距离</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">           d[x] += d[p[x]]; <span class="comment">// 递归p[x]，最终得到x到根节点的距离</span></span><br><span class="line">           p[x] = u;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> p[x];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">       p[i] = i;</span><br><span class="line">       d[i] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">   p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">   d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-堆"><a href="#10-堆" class="headerlink" title="10. 堆"></a>10. 堆</h3><blockquote><h3 id="手写一个堆"><a href="#手写一个堆" class="headerlink" title="手写一个堆:"></a>手写一个堆:</h3><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><ul><li>堆是一个完全二叉树，除了最后一层都是满的；</li><li>（小根）堆的每个店都小于等于两个子节点，根节点是堆的最小值；</li></ul><h3 id="存储："><a href="#存储：" class="headerlink" title="存储："></a>存储：</h3><p>一维数组存储堆，左二子是2x，右儿子是2x+1</p><ul><li>2*0&#x3D;0，建堆从1开始做</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置 ph[j] = k, hp[k] = j</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里a b是堆位置输入的，所以hp[a]才有意义，ph[a]没什么意义</span></span><br><span class="line">    <span class="comment">// 这里把两个数组都swap一下，对应映射交换</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和左节点和右节点更小的点交换，递归down</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和父节点交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-模拟堆操作"><a href="#1-模拟堆操作" class="headerlink" title="1) 模拟堆操作"></a>1) 模拟堆操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], cnt, m;</span><br><span class="line"><span class="type">int</span> hp[N], ph[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里a b是堆位置输入的，所以hp[a]才有意义，ph[a]没什么意义</span></span><br><span class="line">    <span class="comment">// 这里把两个数组都swap一下，对应映射交换</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[t] &gt; h[<span class="number">2</span> * u]) t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[t] &gt; h[<span class="number">2</span> * u + <span class="number">1</span>]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>, u);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k]; <span class="comment">// 执行heap_swap后的ph[k]可能就是不原来的ph[k]了,所以先存一个ph[k]</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-哈希"><a href="#11-哈希" class="headerlink" title="11. 哈希"></a>11. 哈希</h3><h4 id="1）-拉链法"><a href="#1）-拉链法" class="headerlink" title="1） 拉链法"></a>1） 拉链法</h4><p>N取<code>质数</code>，减少哈希冲突</p><p>初始化记得把主链全部初始化为-1 memset(h, -1, sizeof h)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）-开放寻址法"><a href="#2）-开放寻址法" class="headerlink" title="2） 开放寻址法"></a>2） 开放寻址法</h4><p>需要提前设置null为不在N范围内的值，作为初始值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-字符串哈希"><a href="#12-字符串哈希" class="headerlink" title="12. 字符串哈希"></a>12. 字符串哈希</h3><p>用O(1) 快速比较两个字符串相等</p><p>这种做法假装忽略哈希冲突</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line">N取<span class="number">2</span><span class="number">-3</span>倍的量级，质数</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-STL技巧"><a href="#13-STL技巧" class="headerlink" title="13. STL技巧"></a>13. STL技巧</h3><p>vector, 变长数组，倍增的思想： 系统为某一个程序分配空间时，所需时间与空间大小无关，与申请次数有关<br>    size()  返回元素个数<br>    empty()  返回是否为空<br>    clear()  清空<br>    front()&#x2F;back()<br>    push_back()&#x2F;pop_back()<br>    begin()&#x2F;end()<br>    []<br>    支持比较运算，按字典序</p><p>pair&lt;int, int&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    <strong>支持比较运算</strong>，以first为第一关键字，以second为第二关键字（字典序）</p><p>string，字符串<br>    size()&#x2F;length()  返回字符串长度<br>    empty()<br>    clear()<br>    substr(起始下标，**(子串长度)**)  返回子串<br>    c_str()  返回字符串所在字符数组的起始地址</p><p>queue, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    front()  返回队头元素<br>    back()  返回队尾元素<br>    pop()  弹出队头元素</p><p>priority_queue, 优先队列，<strong>默认是大根堆</strong><br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;</p><p>stack, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素</p><p>deque, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()&#x2F;back()<br>    push_back()&#x2F;pop_back()<br>    push_front()&#x2F;pop_front()<br>    begin()&#x2F;end()<br>    []</p><p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()&#x2F;end()<br>    ++, – 返回前驱和后继，<strong>时间复杂度 O(logn)</strong></p><p>​    set&#x2F;multiset<br>​        insert()  插入一个数<br>​        find()  查找一个数<br>​        count()  返回某一个数的个数<br>​        erase()<br>​            (1) 输入是一个数x，删除所有x   O(k + logn)<br>​            (2) 输入一个迭代器，删除这个迭代器<br>​        <strong>lower_bound()&#x2F;upper_bound()</strong><br>​            lower_bound(x)  返回大于等于x的最小的数的迭代器<br>​            upper_bound(x)  返回大于x的最小的数的迭代器<br>​    map&#x2F;multimap<br>​        insert()  插入的数是一个pair<br>​        erase()  输入的参数是pair或者迭代器<br>​        find()<br>​        []  注意multimap不支持此操作。 时间复杂度是 O(logn)<br>​        lower_bound()&#x2F;upper_bound()</p><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的<strong>时间复杂度是 O(1)</strong><br>    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，–</p><p><code>bitset</code>, 圧位 代替布尔数组，用位判断<br>    bitset&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    &#x3D;&#x3D;, !&#x3D;<br>    []</p><p>​    count()  返回有多少个1</p><p>​    any()  判断是否至少有一个1<br>​    none()  判断是否全为0</p><p>​    set()  把所有位置成1<br>​    set(k, v)  将第k位变成v<br>​    reset()  把所有位变成0<br>​    flip()  等价于~<br>​    flip(k) 把第k位取反</p><h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><h3 id="1-树和图的存储"><a href="#1-树和图的存储" class="headerlink" title="1. 树和图的存储"></a>1. 树和图的存储</h3><p>树是无环连通图。树是一种特殊的图，与图的存储方式相同。</p><p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p><p>因此我们可以只考虑有向图的存储。</p><p>(1) 邻接矩阵：g[a][b] 存储边a-&gt;b <strong>一般处理稠密图</strong></p><p>(2) 邻接表： <strong>一般处理稀疏图</strong> 多用邻接表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="comment">// 如果是无向边 需要开M = N * 2；e[M], ne[M], 因为要add两次</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 权重 w[N];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    <span class="comment">// 权重 w[idx] = c;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><p>动态内存开图用 vector<int> obj[N];</p><h3 id="2-树与图的遍历"><a href="#2-树与图的遍历" class="headerlink" title="2. 树与图的遍历"></a>2. 树与图的遍历</h3><p>时间复杂度 O(n+m), n 表示点数，m 表示边数</p><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th>特点</th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(h)</td><td>思路比较怪或者空间要求高 爆搜</td></tr><tr><td>BFS</td><td>queue</td><td>O(2^h)</td><td>最短路性质，按层搜索所以第一个搜到的结果是最短路</td></tr></tbody></table><ul><li>h为深度</li></ul><h4 id="1）-DFS"><a href="#1）-DFS" class="headerlink" title="1） DFS"></a>1） DFS</h4><p>相当于进行递归。 没什么模板，主要的是思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前层 做选择</span></span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里经常写错。</span></span><br><span class="line"><span class="comment">        首先u是节点编号，h[u]是u节点的下标idx，e[idx]就是idx对应的节点，</span></span><br><span class="line"><span class="comment">        每次要往下找节点的ne[i]，所以需要用到下标i，判断节点是否遍历st[j]到要用到节点编号，所以用到j</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> j = e[i]; </span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销当前层</span></span><br><span class="line">    st[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="回溯操作"><a href="#回溯操作" class="headerlink" title="回溯操作"></a>回溯操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~~~cpp</span><br><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">if 满⾜结束条件:</span><br><span class="line">result.add(路径)</span><br><span class="line">return</span><br><span class="line">for 选择 in 选择列表:</span><br><span class="line">做选择</span><br><span class="line">backtrack(路径, 选择列表)</span><br><span class="line">撤销选择</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure><h5 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 判断有效性 比如N皇后问题中的有效性数组</span><br><span class="line">2. 判断最优性，如果比之前的最优解差就剪枝</span><br></pre></td></tr></table></figure><h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2) BFS"></a>2) BFS</h4><p>最短路问题，只有边权都是1时，用BFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最短路还需要定义距离d[N],设置 memset(d, -1, sizeof d) ;d[1] = 0 表示第一个点的距离0 ，其余-1作为未被遍历过条件</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 第一次bfs到的作为最短答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            <span class="comment">// d[j] = d[t] + 1;</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常常求最短次数，那就用一个数组或者哈希记录次数，只记录bfs第一次得到的数据</li></ul><h3 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3. 拓扑排序"></a>3. 拓扑排序</h3><p>若一个由图中所有点构成的序列 AA 满足：对于图中的每条边 (x,y)(x,y)，xx 在 AA 中都出现在 yy 之前，则称 AA 是该图的一个拓扑序列。也就是有向边都是从前指向后。</p><p><strong>一个有向无环图（拓扑图），存在拓扑序列</strong></p><p>入度：一个点有几条边进来</p><p>出度：一个点有几条边出去</p><p>证明：一个有向无环图，必定至少有一个入度为 0 的点</p><p><strong>原理：</strong> </p><ol><li>每次轮到入度为0的数作为起点，往后获取后继；后继入度–，当入度 &#x3D;&#x3D; 0，轮到这个节点</li><li>入队q的顺序，恰好是拓扑序</li><li>拓扑序的顺序不唯一</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;<span class="comment">// 出队只是把指针往后移，没有清除，且恰好是拓扑序。需要拓扑序直接遍历q就行</span></span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最短路问题"><a href="#4-最短路问题" class="headerlink" title="4.最短路问题"></a>4.最短路问题</h3><p>分为：   单源最短路 ：一个起点，到一个终点</p><p>​多源汇最短路 ：多个起点</p><p>n 表示点的数量；m 表示边的数量</p><p>所以边稀疏的时候用堆优化的Dijkstra算法，稠密图用朴素的Dijkstra算法</p><p><strong>难点：</strong>建图，抽象转化为最短路问题，侧重于实现</p><h4 id="1）-朴素Dijkstra算法"><a href="#1）-朴素Dijkstra算法" class="headerlink" title="1） 朴素Dijkstra算法"></a>1） 朴素Dijkstra算法</h4><p>O(N^2)</p><p><strong>用于稠密图</strong>， m比较大的，边多的题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每个循环确定一个点的最小距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 这便是n-1，因为第一个点已经确定最短距离是0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*不在st中的，距离最近的点*/</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"><span class="comment">/*t加入st中*/</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*用t更新其他点的距离*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）-堆优化的Dijkstra算法"><a href="#2）-堆优化的Dijkstra算法" class="headerlink" title="2） 堆优化的Dijkstra算法"></a>2） 堆优化的Dijkstra算法</h4><p>O(mlogn + m)</p><p>用于稀疏图，m比较小的。 </p><p>原理： 用堆压缩每次查找不在st中的距离最短的点，压缩到n；但是更新其他点的距离需要维护堆，mlogn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3）-Bellman-Ford算法"><a href="#3）-Bellman-Ford算法" class="headerlink" title="3） Bellman-Ford算法"></a>3） Bellman-Ford算法</h4><p>一般只处理k次边，边权是负数的问题。 其他就用spfa</p><p>O(mn)</p><p>处理有负权边的图中最短路问题；</p><p>有负权回路的图，可能没有最短路，因为如果环的总数是负数，那最短路可能是负无穷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="comment">// 松弛所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 每次备份dis数组，使得一条边只松弛一次，避免串联。避免上一条松弛完结果松弛下一条</span></span><br><span class="line">        <span class="built_in">memcpy</span>(last, dis, <span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dis[e.b] = <span class="built_in">min</span> (dis[e.b], last[e.a] + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 不能用==, 因为负权边存在，导致正无穷被减了</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）-spfa算法"><a href="#4）-spfa算法" class="headerlink" title="4） spfa算法"></a>4） spfa算法</h4><p>队列优化的Bellman-Ford算法。 </p><p>平均O(m), 最坏O(nm)</p><blockquote><p>spfa算法还可以都处理正负权边，一般情况比Dijkstra算法还快，但是出题人可能会卡最坏情况，那就需要用堆优化的Dijkstra</p></blockquote><p>长的有点像Dijkstra算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中，重复存队列是无意义的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只有dis[j]更短了，才需要加到q中，以接着更新临边的dist[]</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-spfa判断图中是否存在负环"><a href="#5-spfa判断图中是否存在负环" class="headerlink" title="5)  spfa判断图中是否存在负环"></a>5)  spfa判断图中是否存在负环</h4><p>时间复杂度是  O(nm)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组并且把点全放到q中：dist数组是0，只会更新小于0的权边，也就是负权边，当存在负权环的时候，会不停的更新，此时输出true</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-floyd算法"><a href="#6-floyd算法" class="headerlink" title="6) floyd算法"></a>6) floyd算法</h4><p>O(N^3) 求解多源最短路问题</p><p>一般是多次多点查询，查任意d[a][b]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5. 最小生成树"></a>5. 最小生成树</h3><p>最小生成树：连接一个连通无向图的所有顶点和边的树，且权值之和最小的树</p><p>稠密图一般用朴素Prim， 稀疏图用Kruskal</p><h4 id="1）-朴素Prim算法"><a href="#1）-朴素Prim算法" class="headerlink" title="1） 朴素Prim算法"></a>1） 朴素Prim算法</h4><p>朴素 稠密 邻接矩阵</p><blockquote><p>dist[i]  无穷&lt;– dist[1] &#x3D; 0</p><p>for （int i &#x3D; 0；i &lt; n; i++)</p><p>找到集合外距离最近的点t</p><p>用t更新其他点到<code>集合</code>的距离</p><p>st[t] &#x3D; true; </p></blockquote><ul><li>和Dijkstra有点像，但是更新的到集合的距离</li></ul><p>时间复杂度是 O(n^2+m), nn 表示点数，mm 表示边数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;<span class="comment">/*获取集合外最小距离点*/</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"><span class="comment">/*加入集合*/</span> </span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">// 如果没有连通的点，impossible</span></span><br><span class="line">        res += dist[t]; <span class="comment">// 先更新res，防止之后被更新的了dist[t]</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*更新其他边*/</span> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Kruskal算法"><a href="#2-Kruskal算法" class="headerlink" title="2)  Kruskal算法"></a>2)  Kruskal算法</h4><p>堆优化的Prim算法 写起来复杂，且没有Kruskal算法好，一般不用，不记</p><blockquote><ol><li><p>将所有边按权重从小到大排序 O(mlogm)</p></li><li><p>枚举每条边a, b, w； </p><p>if a, b不连通</p><p>​将这条边加入到集合中</p></li></ol></blockquote><p>就是每次加小权重边的贪心思想</p><p>时间复杂度是 O(mlogm), nn 表示点数，mm 表示边数时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-染色法判别二分图"><a href="#6-染色法判别二分图" class="headerlink" title="6. 染色法判别二分图"></a>6. 染色法判别二分图</h3><p>二分图（Bipartite Graph），又称作二部图，是一种图论中的特殊图，可以将图中的顶点分为两个互不相交的集合，使得同一集合内的顶点没有边相连。</p><p>二分图 当且仅当 图中不存在奇数环</p><p>O(n + m) , n表示点数，m表示边数</p><p>原理： dfs对所有点染色，如果下一个点 已经被染色 并且 和上一个同色，false</p><p>由于图中不含奇数环，所以染色过程中一定没有矛盾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="comment">// 如果下一个点 已经被染色 并且 和上一个同色，false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 染色法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历所有点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="comment">// 从这个点出发 染色相连的点</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-二分图的最大匹配-匈牙利算法"><a href="#7-二分图的最大匹配-匈牙利算法" class="headerlink" title="7. 二分图的最大匹配 匈牙利算法"></a>7. 二分图的最大匹配 匈牙利算法</h3><p>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p><p>O(nm)，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) <span class="comment">// 没有匹配男生，或者那个男的可以找到下家</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="1-质数"><a href="#1-质数" class="headerlink" title="1. 质数"></a>1. 质数</h3><h4 id="试除法-判断质数"><a href="#试除法-判断质数" class="headerlink" title="试除法 判断质数"></a>试除法 判断质数</h4><p>O(sqrt(n))</p><p><strong>原理</strong>：i能整除n，那么n&#x2F;i也能整除n，都是成对出现的，那只需要枚举小的那个数</p><p>只需要枚举到根号n就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 不要写成根号n，比较慢；也不要写i*i &lt; n可能存在int移除</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="试除-分解质因数法"><a href="#试除-分解质因数法" class="headerlink" title="试除 分解质因数法"></a>试除 分解质因数法</h4><p>O(sqrt(n))</p><p><strong>原理</strong>：n中最多只包含一个大于sqr(n)的质因子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 从小到大分解质因子，修改x</span></span><br><span class="line">        <span class="comment">// i 一定是质数 ： </span></span><br><span class="line">        因为如果i能被<span class="number">2</span>到i<span class="number">-1</span>的数整除，那么n一定能被<span class="number">2</span>到i<span class="number">-1</span>中的数整除，因为n是i的倍数（n能被i整除）</span><br><span class="line">        因为在枚举到i之前已经把n中<span class="number">2</span>到i<span class="number">-1</span>的质因子除干净了，此时n中不含<span class="number">2</span>到i<span class="number">-1</span>的质因子，由于n为i的倍数，所以i中也不包含<span class="number">2</span>到i<span class="number">-1</span>的质因子</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="comment">// 最多只有一个大于根号n的质因子</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="朴素筛法-求范围内所有素数"><a href="#朴素筛法-求范围内所有素数" class="headerlink" title="朴素筛法 求范围内所有素数"></a>朴素筛法 求范围内所有素数</h4><p>O(Nlog(N)) 不管是素数还是合数，都筛掉他的倍数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把素数存起来</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i; <span class="comment">// [2, p-1]都没有被筛掉，所以是素数</span></span><br><span class="line">        <span class="comment">// 不管是素数还是合数，都筛掉他的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) </span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="诶氏筛法-求范围内所有素数"><a href="#诶氏筛法-求范围内所有素数" class="headerlink" title="诶氏筛法 求范围内所有素数"></a>诶氏筛法 求范围内所有素数</h4><p>O(Nlog(log（N)) 只用素数，都筛掉所有的合数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;<span class="comment">// 把素数存起来</span></span><br><span class="line">            primes[cnt ++ ] = i; <span class="comment">// [2, p-1]都没有被筛掉，所以是素数</span></span><br><span class="line">            <span class="comment">// 只用素数，都筛掉所有的合数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) <span class="comment">// 把每个数的倍数删掉 : i 是一个质数， i的倍数都筛掉</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法-求范围内所有素数"><a href="#线性筛法-求范围内所有素数" class="headerlink" title="线性筛法 求范围内所有素数"></a>线性筛法 求范围内所有素数</h4><p>O(N) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 用最小质因子去筛合数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]一定是小于i的最小质因子,所以primes[j]*i的最小质因子就是primes[j];</span></span><br><span class="line">            <span class="comment">//2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是prime[j]，</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了。因为i有最小质因子primes[j]&lt;primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，</span></span><br><span class="line">            <span class="comment">// 此时应该退出循环，增加i，然后把primer[j]重新从小开始</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-约数"><a href="#2-约数" class="headerlink" title="2. 约数"></a>2. 约数</h3><p>和求质因数一样，约数也是成对出现，遍历到根号n，只遍历较小的约数就行，顺便把不同的另一个约数也插入</p><h4 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数个数-和-约数之和"><a href="#约数个数-和-约数之和" class="headerlink" title="约数个数 和 约数之和"></a>约数个数 和 约数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck // 分解质因子</span><br><span class="line">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="line">约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) //可以用while (a--) t = (t*p + 1) % mod;</span><br></pre></td></tr></table></figure><p>这些p取质数</p><h5 id="给定-n-个正整数-ai，请你输出这些数的乘积的约数之和，答案对-1e9-7-取模。"><a href="#给定-n-个正整数-ai，请你输出这些数的乘积的约数之和，答案对-1e9-7-取模。" class="headerlink" title="给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 1e9+7 取模。"></a>给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 1e9+7 取模。</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line">    <span class="comment">// 每个数约数及其次数，总乘数的约束及其次数</span></span><br><span class="line">    <span class="keyword">while</span> ( n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, primes[i] ++;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公式</span></span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = prime.first, a = prime.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a--) t = (t*p + <span class="number">1</span>) % mod;</span><br><span class="line">        res =  res * t % mod;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="辗转相除法-求最大公约数"><a href="#辗转相除法-求最大公约数" class="headerlink" title="辗转相除法 求最大公约数"></a>辗转相除法 求最大公约数</h4><p>欧几里得算法 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：（）表示最大公约数，</p><ol><li><p>首先(a, b) &#x3D; (a, ka + b), 那么可以用辗转相减法求（a,b) :基本上思路就是大数减去小数，<strong>一直减到能算出来为止</strong></p></li><li><p>由(78，14)到(8，14)完全可以一步到位，因为(78，14)&#x3D;(14×5+8，14)&#x3D;(8，14)，由此就诞生出我们的辗转相除法.</p></li></ol><p>​即：(a， b) &#x3D; (a % b， b) &#x3D; （b, a %b）</p><p>相当于每一步都把数字进行缩小，等式右边就是每一步对应的缩小结果。</p><p>对（a， b）连续使用辗转相除，直到小括号内右边数字为0，小括号内左边的数就是两数最大公约数</p><h3 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3. 欧拉函数"></a>3. 欧拉函数</h3><h4 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h4><p>互质： 公约数只有1的两个数</p><p>欧拉函数：1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h4><p>借用线性筛素数的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            <span class="comment">// 质数的欧拉函数 i-1</span></span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">             <span class="comment">// primes[j]是i的最小质因子, 也是rimes[j] * i的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将基数NN修正为primes[j]倍，最终结果为phi[i] * primes[j]</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// primes[j]不是i的质因子，只是primes[j] * i的最小质因子，因此不仅需要将基数NN修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)</span></span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速幂"><a href="#4-快速幂" class="headerlink" title="4. 快速幂"></a>4. 快速幂</h3><p>O(n∗logb)</p><p>求 m^k mod p，时间复杂度 O(logk)。</p><p>把m^k 转化为 m^（2^0 + 2^1 + 2^2 +…)，</p><p>如何预处理 m^（2^b) mod p这些值， 每个数就是前面的数 平方 再mod p</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * m % p;</span><br><span class="line">        <span class="comment">// 下一个底数和次数 m^（2^b) , 下一个 k</span></span><br><span class="line">        a = a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><p><strong>逆元：</strong>a &#x2F; b ≡ a * x (mod n)，则x是b的逆元。 数b与逆元x的关系 1 ≡ b * x (mod n)</p><p><strong>费马小定理：</strong>当n为质数时b ^ (n - 1) ≡ 1 (mod n)</p><p>拆一个b出来可得 b * b ^ (n - 2) ≡ 1 (mod n)<br>故当n为质数时，b n 互质，b的乘法逆元 <code>b的乘法逆元 = b ^ (n - 2) mod n</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> % c;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);</span><br><span class="line">        <span class="comment">// 题目中限定了 p 一定是质数，所以如果ab不互质，即 a 和 p 有公因子，那么 a 就一定是 p 的倍数</span></span><br><span class="line">        <span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">qmi</span>(a, p<span class="number">-2</span>, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-扩展欧几里得算法"><a href="#5-扩展欧几里得算法" class="headerlink" title="5.扩展欧几里得算法"></a>5.扩展欧几里得算法</h3><h4 id="裴蜀定理："><a href="#裴蜀定理：" class="headerlink" title="裴蜀定理："></a>裴蜀定理：</h4><p>有一对任意正整数a, b, 那么一定存在整数系数x, y, 使得ax + by &#x3D; (a, b) 。()表示最大公约数</p><p>而且这个（a,b）是a和b能凑出来的最小的数</p><p>证明： </p><ol><li><p>因为a b能凑出来的数一定是（a,b）的倍数，所以最小的数是(a,b)</p></li><li><p>求出系数 x y</p></li></ol><h4 id="扩展欧几里得算法求-系数x-y"><a href="#扩展欧几里得算法求-系数x-y" class="headerlink" title="扩展欧几里得算法求 系数x, y"></a>扩展欧几里得算法求 系数x, y</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exgcd-解线性同余方程"><a href="#exgcd-解线性同余方程" class="headerlink" title="exgcd 解线性同余方程"></a>exgcd 解线性同余方程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x= <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b *x; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        <span class="comment">// b 是(a, m)的倍数 才有解</span></span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="comment">// 结果需要扩大 b/d 倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>) x * (b/d) % m);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高斯消元-求解线性方程组"><a href="#6-高斯消元-求解线性方程组" class="headerlink" title="6. 高斯消元 求解线性方程组"></a>6. 高斯消元 求解线性方程组</h3><p>O(N^3)</p><p>划成上三角矩阵，然后判断解的情况：唯一解、 无解、 去穷多解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="comment">// 按照每列遍历</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到该列最大值的行</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line">        <span class="comment">// 如果最大是0，已经完成变换        </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 把绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line">        <span class="comment">// 把当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--) a[r][i] /= a[r][c];</span><br><span class="line">        <span class="comment">// 用当前行将下面所有列消0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j-- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++)</span><br><span class="line">            <span class="comment">// 如果存在0 = 非0 无解 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 无穷多解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="comment">// 消掉除了对角线的项，最后化成 xi = 常数项</span></span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-组合数"><a href="#7-组合数" class="headerlink" title="7. 组合数"></a>7. 组合数</h3><h4 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h4><p>组合数的递推式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="comment">/* 考虑边界情况：</span></span><br><span class="line"><span class="comment">        1.c[0][j] = 0 </span></span><br><span class="line"><span class="comment">        2.c[i][0] = 1</span></span><br><span class="line"><span class="comment">        3. i &lt; j 时，0 不存在</span></span><br><span class="line"><span class="comment">        4. i = j 是，1 </span></span><br><span class="line"><span class="comment">    */</span> </span><br></pre></td></tr></table></figure><h4 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span><br><span class="line">如果取模的数是质数，可以用费马小定理求逆元</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-NIM游戏"><a href="#8-NIM游戏" class="headerlink" title="8. NIM游戏"></a>8. NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An !&#x3D; 0</p><p>异或： 结果是0 ，则每个位上的1数量是偶数</p><p>先手必败态：走不到任何一个必败状态，</p><p>先手必胜状态： 可以走到某个必败状态</p><p>扩展：k-NIM游戏，每次最多拿k个</p><h4 id="公平组合游戏ICG"><a href="#公平组合游戏ICG" class="headerlink" title="公平组合游戏ICG"></a>公平组合游戏ICG</h4><p>若一个游戏满足：</p><ol><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        res ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>&lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h4><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h4 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h4><p>设S表示一个非负整数集合.定义mex(S)为求出不属于集合S的最小非负整数运算,即:<br>mes(S)&#x3D;min{x};<br>例如:S&#x3D;{0,1,2,4},那么mes(S)&#x3D;3;</p><h4 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h4><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) &#x3D; mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。</p><h4 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h4><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br><strong>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：</strong><br><strong>SG(G) &#x3D; SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</strong></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p><strong>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。</strong><br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p><p>终点定义为0，其他的SG(x)定义为，不能走到的最小的整数</p><p> 集合-Nim游戏 只能取 集合s[N]中任意值的数量石子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出每一堆的sg</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] !=  <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="comment">// 每个节点的往下子节点的值存在set中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要用递归的话，最好定义局部变量，防止改变原值</span></span><br><span class="line">        <span class="type">int</span> sum = s[i];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= sum) S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x - sum));</span><br><span class="line">        <span class="comment">// 延伸到终点的sg值后，再从后往前排查出所有数的sg值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小的没有出现的自然数的操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ;i ++)</span><br><span class="line">        <span class="keyword">if</span> (!S.<span class="built_in">count</span>(i))</span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cin &gt;&gt; s[i];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        res ^= <span class="built_in">sg</span>(x); <span class="comment">// 所有堆的sg异或起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h4 id="考虑Dp问题角度："><a href="#考虑Dp问题角度：" class="headerlink" title="考虑Dp问题角度："></a>考虑Dp问题角度：</h4><ol><li><p>状态表示 f(i,j) ,如何表示当前状态。<br>1）表示的集合是什么  2）f(i,j)这个值 表示集合的属性是什么（最大值、最小值、数量等</p></li><li><p>状态计算，如何一步步计算到需要的结果</p><p>主要是把集合划分</p></li></ol><p>化零为整，化整为零</p><h4 id="Dp优化："><a href="#Dp优化：" class="headerlink" title="Dp优化："></a>Dp优化：</h4><p>一般是对DP的代码或者方程做一个等价变形；</p><p>需要先把基本的方程写出来，</p><h4 id="一维优化："><a href="#一维优化：" class="headerlink" title="一维优化："></a>一维优化：</h4><p>背包问题中，如果状态转移用到的是上一层的则是由大到小遍历，如果用的是本层的，就是由小到大遍历</p><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h3><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>dp[i][w] 表示对于前i个物品，容量为w的背包的最大价值</p><ol><li>按照状态找：<br>dp[i][w] 表示对于前i个物品，容量为w的背包的最大价值<br>dp[i][w] &#x3D; max(dp[i-1][w],  dp[i-1][w-wt[i-1]] + val[i-1]);</li><li>到达当前dp[i][w]状态的情况综合，放入第i个物品，或者不放第i物品</li><li>先凑答案就是dp[N][W]的情况，这时候dp的下标是比单个val和wt的下标大一个的，因为前者是size,后者是下标</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> n, m;</span><br><span class="line"> cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="number">1.</span> y总</span><br><span class="line">         <span class="comment">//f[i][j] = f[i -1][j];</span></span><br><span class="line">         <span class="comment">//if (j &gt;= v[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);</span></span><br><span class="line"><span class="number">2.</span> 我的分类讨论，集合划分为装第i件和不装第i件。</span><br><span class="line">             <span class="comment">// 前置条件 j-v[i]不能小于0，也就是存不下第i个,那只能选不存第i个的情况</span></span><br><span class="line">         <span class="keyword">if</span> (j &lt; v[i])</span><br><span class="line">         &#123;</span><br><span class="line">             f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">         &#125;<span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j- v[i]] + w[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ol start="4"><li>一维优化： 因为每次更新f[i][] 只用到了 f[i-1][]这两层， 可以用滚动数组优化。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">         <span class="comment">// 这里更新使用的是f[i -1][j - v[i]]，所以要在f[j - v[i]]还表示f[i -1][j - v[i]]时，还没有更新到f[i][j - v[i]]。j从大到小遍历，求解 f[j] 的时候，还没有更新f[j - v[i]],也就是 f[j - v[i]]是上一层 i -1的原值</span></span><br><span class="line">        <span class="comment">// 这里 j &gt;= v[i]保证了更新条件</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><p>每种物品都有无限件可用</p><ol><li>状态计算： <code>f[i,j] = max (f[i - 1][j - v[i]*k] + w[i] * k)</code></li></ol><p>10^9 TLE </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span> (f[i][j], f[i <span class="number">-1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>两重for之后，要存第i类物品，是需要看还剩下多少空间的，要看之前缺 i 元的情况数</p><p>或者用数学推导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// f[i][j] = f[i-1][j] + f[i-1][j-v[i]] + f[i-1][j-v[i]*2] + ...+f[i-1][j-v[i]*s];</span><br><span class="line">// f[i][j-v[i]] =        f[i-1][j-v[i]] + f[i-1][j-v[i]*2] + ...+f[i-1][j-v[i]*s];</span><br><span class="line"></span><br><span class="line">所以f[i][j] = f[i-1][j] + f[i][j-v[i]];</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span> (f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>一维优化</li></ol><blockquote><p> 最终发现 完全背包问题和01背包问题的差别就是j层遍历的顺序不一样。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m ; j++)</span><br><span class="line">        <span class="comment">// 这里从小到大遍历，和原先的f[i][j] = max (f[i][j], f[i][j - v[i]] + w[i]);一致</span></span><br><span class="line">            f[j] = <span class="built_in">max</span> (f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3. 多重背包问题"></a>3. 多重背包问题</h3><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><ol><li>朴素做法还是 <code>f[i,j] = max (f[i - 1][j - v[i]*k] + w[i] * k)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ).</span><br><span class="line">                f[i][j] = <span class="built_in">max</span> (f[i][j], f[i <span class="number">-1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二进制优化</li></ol><p>把NVS转化为NVlogS复杂度。</p><p>把一种物体按照2进制打包，成为2不同次数量的包，加上一个余数c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12000</span>, M = <span class="number">2010</span>; <span class="comment">// N = 1000 * (log(2000)/log(2))</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="comment">// 二进制优化，从1开始分（1,2,4,8.16.....比s小的2倍数，c（余数））</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">                f[j]= <span class="built_in">max</span> (f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-分组背包问题"><a href="#4-分组背包问题" class="headerlink" title="4. 分组背包问题"></a>4. 分组背包问题</h3><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i是组号，j是组内编号。</p><ul><li>每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；</li><li>每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">1</span><br><span class="line">3 4</span><br><span class="line">1</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 按组读取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j ++) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按组更新，分组01背包，大到小遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span> (j  &gt;= v[i][k]) f[j] = <span class="built_in">max</span> (f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-线性dp"><a href="#5-线性dp" class="headerlink" title="5. 线性dp"></a>5. 线性dp</h3><p>一维 二维 状态表示 </p><h3 id="6-区间dp"><a href="#6-区间dp" class="headerlink" title="6. 区间dp"></a>6. 区间dp</h3><p>状态用区间表示</p><h3 id="7-计数类dp-数位统计dp"><a href="#7-计数类dp-数位统计dp" class="headerlink" title="7. 计数类dp 数位统计dp"></a>7. 计数类dp 数位统计dp</h3><h3 id="8-状态压缩dp"><a href="#8-状态压缩dp" class="headerlink" title="8. 状态压缩dp"></a>8. 状态压缩dp</h3><p>用一个数来表示一个状态，减少复杂度</p><h4 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h4><p>状态压缩dp： 把状态用二进制数表示: </p><p>f[i, j]是前面i-1列已经摆好，且从第i-1列伸到i列的所有方案的状态是j(二进制表示) ，属性是个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先放横着的，再放竖着的。</span></span><br><span class="line"><span class="comment">// 总方案数就是脂肪横着的小方块的方案数</span></span><br><span class="line"><span class="comment">// f[i, j]是前面i-1列已经摆好，且从第i-1列伸到i列的所有方案的状态是j(二进制表示) ，属性是个数</span></span><br><span class="line"><span class="comment">// 判断合法： 所有连续空着的位置的长度必须是偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态压缩dp： 把状态用二进制表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL f[N][M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 预处理，状态不能有奇数个连续的0</span></span><br><span class="line">        <span class="comment">// i &lt; 1 &lt;&lt; n ，比如行数是3，则000 - 111 也就是0 - (1 &lt;&lt; n - 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果这个位的值是1，那查看之前0的数目是多少</span></span><br><span class="line">                <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 奇数个0 转态不合法</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后几个0</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;</span><br><span class="line">            st[i] = is_valid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理，i-1到i伸出来 的 和i-2到i-1伸出来的 不能有冲突, 不在同一行存在i-1和i-2两次伸出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 伸出来部分不能有冲突，位置上不能有两个1</span></span><br><span class="line">            <span class="comment">// 2. 状态不能有奇数个连续的0,两个都填充了一个列后，列的状态也需要是合法的</span></span><br><span class="line">            <span class="comment">// 初始化 因为while</span></span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])</span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 因为while</span></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈密顿距离"><a href="#哈密顿距离" class="headerlink" title="哈密顿距离"></a>哈密顿距离</h4><p>二进制数表示状态，经过的点1，没经过的点0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] 表示0到j点，经过状态i的路径，属性是路径最小值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="comment">// 从0走到0</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) <span class="comment">// 到达j点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span> ((i &gt;&gt; k) &amp; <span class="number">1</span>) <span class="comment">// 需要包含k点</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-(<span class="number">1</span> &lt;&lt; j)][k]+ w[k][j]);<span class="comment">// 使用不经过j点后到达的k点的方案</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-树形dp"><a href="#9-树形dp" class="headerlink" title="9. 树形dp"></a>9. 树形dp</h3><p>dfs结合</p><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h4><p>f[i][0] 不选择节点i的子树的happy值和， f[i][1] 选择节点i的子树happy值的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N],idx;</span><br><span class="line"><span class="comment">// f[i][0] 不选择节点i的子树的happy值和， f[i][1] 选择节点i的子树happy值的和</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>]; </span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">bool</span> has_father[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span> (f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; happy[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        has_father[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (has_father[root]) root ++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-记忆化搜索"><a href="#10-记忆化搜索" class="headerlink" title="10. 记忆化搜索"></a>10. 记忆化搜索</h3><h4 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h4><p>单纯用暴搜，因为每个格子作为起点的往后能走几步是一定的，所以dfs有很多重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>], ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &lt; a[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">            num += t ;</span><br><span class="line">            res = <span class="built_in">max</span>(res, num);</span><br><span class="line">            num -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            len = <span class="built_in">max</span>(len, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dp-记忆化搜索"><a href="#dp-记忆化搜索" class="headerlink" title="dp 记忆化搜索"></a>dp 记忆化搜索</h5><p>用dp记录了每个格子作为起点的往后能走几步。减少了复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], f[N][N];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学一下这种写法，dp(x, y)递归的写法</span></span><br><span class="line"><span class="comment">// 此时不知道dp[x][y]有没有求过，初始化为-1作为判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>], ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &lt; a[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">dp</span>(nx, ny);</span><br><span class="line">            v = <span class="built_in">max</span>(v, t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            len = <span class="built_in">max</span>(len, <span class="built_in">dp</span>(i, j));</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>没有固定的模板，按步骤贪心，选择当前最好的情况，举一些例子试试贪心想法对不对，证明比较难</p><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h4><p>给定 N 个闭区间 [ai,bi][ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p><p>右端点排序</p><p>证明： AnS &lt;&#x3D; cnt &amp;&amp; Ans &gt;&#x3D;cnt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照右端点进行排序，左端点比上一个右端点大，就说明需要新增点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;w) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先定一个无限小的ed，这种把第一个区间res+1的技巧</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (range[i].l &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大不相交区间"><a href="#最大不相交区间" class="headerlink" title="最大不相交区间"></a>最大不相交区间</h4><p>给定 N 个闭区间 [ai,bi][ai,bi]，在数轴上选择若干区间，使得选中的区间之间互不相交</p><p>这题也是证明难，按照前一题的证明思路</p><p>证明： AnS &lt;&#x3D; cnt &amp;&amp; Ans &gt;&#x3D;cnt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range&amp; w) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; range[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h4><p>给定 N 个闭区间 [ai,bi][ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小</p><ol><li>枚举到一个区间，和前面所有组都有交集，只能新开一个组； 这次以<strong>左端点</strong>排序</li></ol><p>2。 判断满足所有组的Max_r是不是小于新添加区间的L[i],可以用小根堆维护，只要最小的Max_r小于L[i]，则可以放，不需要开新组，就放到最小组中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100030</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r ;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;w) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;  i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= r.l) heap.<span class="built_in">push</span>(r.r); <span class="comment">// 连最小的组都不能加入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 把区间加入最小的组</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h4><p>给定 N 个闭区间 [ai,bi][ai,bi] 以及一个线段区间 [s,t][s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span> (range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r, range[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="comment">// 找不到覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; st)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找完全覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= ed)</span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Huffam树"><a href="#Huffam树" class="headerlink" title="Huffam树"></a>Huffam树</h3><h4 id="合并果园"><a href="#合并果园" class="headerlink" title="合并果园"></a>合并果园</h4><p>核心思想是让权值大的叶子离根最近</p><p>经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。</p><ol><li>最小的两个点，深度一定是最深，且可以互为兄弟</li><li>最小的两个点合并能得到最优解， 再往后求n-1哈夫曼树的问题，继续合并最小两个点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次合并权值最小的两个点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="comment">// 每次合并权值最小的两个点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += b + a;</span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += b + a;</span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h3><h4 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大排队</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(t, t + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res += t[i] * (n - i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h3><h4 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h4><p>在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN</p><p>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><p>一维的选址问题就是求中间点，二维的选址问题求曼哈顿距离的话就是分别求xy，如果是欧几里得问题就是求费马点没有高效的算法用一些随机方法试试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res += <span class="built_in">abs</span>(a[i] - a[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h3><h4 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h4><p>这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。</p><p>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span> , <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII cow[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);</span><br><span class="line">        cow[i] = &#123;w + s, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(cow, cow + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2e9</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w = cow[i].second, s = cow[i].first - cow[i].second;</span><br><span class="line">        res = <span class="built_in">max</span> (res, sum - s);</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网 - 网络是怎样连接的</title>
      <link href="/2023/11/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E9%93%BE%E6%8E%A5%E7%9A%84/"/>
      <url>/2023/11/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E9%93%BE%E6%8E%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h1><h2 id="探索浏览器内容"><a href="#探索浏览器内容" class="headerlink" title="探索浏览器内容"></a>探索浏览器内容</h2><h3 id="生成HTTP请求消息"><a href="#生成HTTP请求消息" class="headerlink" title="生成HTTP请求消息"></a>生成HTTP请求消息</h3><p>URL(uniform resource locator)统一资源定位符<br>FTP (file transfer protocol)文件传送协议<br>HTTP(hypertext transfor protocol) 超文本传送协议<br>TCP（transmission control protocol）传输控制协议<br>UDP（user datagram protocol）用户数据报协议<br>IP（internet protocol）网络互联协议</p><p>浏览器是综合性的客户端软件，需要不同的URL来判断使用哪个功能<br>URL开头部分指明了访问方法(协议)；</p><h4 id="HTTP定义了客户端与服务器之间交互的消息内容和步骤："><a href="#HTTP定义了客户端与服务器之间交互的消息内容和步骤：" class="headerlink" title="HTTP定义了客户端与服务器之间交互的消息内容和步骤："></a>HTTP定义了客户端与服务器之间交互的<strong>消息内容</strong>和<strong>步骤</strong>：</h4><p>内容包括：<br>URI(identifier)：存放网页数据的文件名或者CGI程序的文件名<br>其中CGI(common gateway iterface)通用网关接口 ：web服务器调用其他程序的规则<br>方法：<br>GET POST HEAD OPTIONS PUT DELETE TRACE CONNECT</p><p>Web服务器对其中内容进行解析，完成工作后，结果存放在响应消息中，包括状态码、头字段、网页数据</p><h3 id="向DNS服务器查询Web服务器的IP地址"><a href="#向DNS服务器查询Web服务器的IP地址" class="headerlink" title="向DNS服务器查询Web服务器的IP地址"></a>向DNS服务器查询Web服务器的IP地址</h3><p>TCP&#x2F;IP结构 用集线器链接的计算机形成子网，通过路由器连接成一个大的网络；<br>数据以包的形式传送；</p><p>IP地址： 网络号和主机号；共32位，8比特为一组，十进制表示，圆点隔开；<br>子网掩盖码：写在IP地址右侧，表示IP地址的结构，也可以用网络号的位数表示‘</p><p>DNS(dommain name system)域名服务器系统：用于为各种信息关联相应的名称；<br>DNS解析器用于域名解析，包含在 操作系统的Socket库（操作系统中用于调用网络功能的程序组件几何）中；</p><h3 id="DNS服务器大接力"><a href="#DNS服务器大接力" class="headerlink" title="DNS服务器大接力"></a>DNS服务器大接力</h3><p>控制流程转移；web浏览器——》Socket向DNS查询IP地址——》操作系统内部协议栈；</p><p>DNS接受客户端的查询信息：域名  、Class 、记录类型（A表示IP地址，MX表示邮件服务器）；</p><h4 id="域名层次结构："><a href="#域名层次结构：" class="headerlink" title="域名层次结构："></a>域名层次结构：</h4><ol><li>内部网络服务器数量有限的情况下，可以都保存在一台DNS服务器中；</li><li>多台DNS服务器接力,分层次从后往前缩小，最下层的www为服务器名<br>com的上一层为根域，写法可以省略，根域的IP地址只有13个且不变，一般已经配置在DNS服务器程序中了</li></ol><h4 id="客户端查询过程："><a href="#客户端查询过程：" class="headerlink" title="客户端查询过程："></a>客户端查询过程：</h4><p>最近的DNS服务器——》没有则从根目录自顶向下查找；<br>如果有域名缓存，可以从缓存位置向下查找；</p><p>缓存：使用过的数据存放在离使用该数据较近的高速存储装置中，以提高后续访问速度</p><h4 id="收发数据的操作："><a href="#收发数据的操作：" class="headerlink" title="收发数据的操作："></a>收发数据的操作：</h4><ul><li>1.创建套接字（调用socket）、2.接管道连接到服务器端的套接字上、3.收发数据、4.断开管道并删除套接字；</li></ul><ol><li>创建套接字完成后系统返回 <strong>描述符</strong>，应用程序通过描述符来识别套接字；</li><li>connect连接用到：描述符（应用程序用来识别套接字的机制）、服务器IP地址、端口号（这两个是服务器和客户端实现互相识别对方套接字的机制）</li><li>write和read：接收缓存区</li><li>close：客户端和服务器一端先断开，然后断开操作传到另一端</li></ol><h2 id="用电信号传输TCP-x2F-IP数据——协议栈和网卡"><a href="#用电信号传输TCP-x2F-IP数据——协议栈和网卡" class="headerlink" title="用电信号传输TCP&#x2F;IP数据——协议栈和网卡"></a>用电信号传输TCP&#x2F;IP数据——协议栈和网卡</h2><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908192019506.png" alt="image-20220908192019506"></p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>应用程序——Socket库和解析器——<em>操作系统中的TCP、UDP、IP</em>——网卡驱动程序——硬件网卡</p><p>浏览器、邮件等一般应用程序收发数据时用TCP，DNS查询等收发较短的控制数据时用UDP；<br>网络包：网络中数据的小包（几十到几千字节）；<br>IP协议将网络包发送给通信对象</p><p>套接字作用：记录了用于控制通信操作的各种控制信息，协议栈根据这些信息判断下一步的行动；<br>processID：操作系统为了标识应用程序分配的编号；</p><p>应用程序调用socket创建套接字，协议栈首先分配内存空间，然后写入初始状态，返回描述符给应用程序</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>TCP头部大概有<strong>双方的端口号、初始序号、窗口大小、ACK号、校验、头部长度、控制位</strong>等信息</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193526768.png" alt="image-20220908193526768"></p><p>连接：通信双方交换控制信息，在套接字中记录这些信息并准备数据收发的一连串操作；<br>控制信息：头部中记录的信息和套接字中记录的信息<br>A发送SYN为1的TCP包、创建数据的初始序号、需要的窗口大小——》B返回SYN为1的TCP包、初始序号、窗口大小、返回收到包的ACK号——》B返回收到的ACK号</p><p>TCP模块创建连接控制信息的头部——》找到套接字——》修改状态为正在连接</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>应用程序调用write将数据交给给协议栈，协议栈执行发送操作；</p><ul><li>积累多少数据发送出去判断标准:<strong>1,MTU 2,时间</strong><br>MTU（maximum transmission unit）最大传输单元：每个<strong>网络包</strong>所能容纳的最大长度；一般是1500字节<br>MSS（maximum segment size）最大分段大小：MTU减去头部的长度；也就是实际缓冲区能放的数据量<br>时间主要是看频率，协议栈内部有一个计时器；</li></ul><ol><li>以上两个要素时矛盾的，需要综合考虑，可以指定直接发送</li><li>数据块较大的需要按照MSS拆分</li></ol><ul><li><p>序号和ACK号使用方法——<strong>确认对方是否收到网络包</strong>：<br>连接时将SYN设置为1，并告知初始序号；<br>计算数据长度后发送ACK号，并设置比特为1，表示ACK号有效<br>在返回ACK号确认之前，包都保存在缓冲区，可以重写发送</p></li><li><p>客户端和服务器端双向传输过程</p></li><li><p>网络的错误检测和补偿机制非常复杂；</p></li><li><ol><li>按照ACK返回时间动态调整等待时间；</li><li>滑动窗口管理ACK：接收方通过TCP头部的窗口字段将缓冲区余量告知发送方；发送方在等待ACK返回时继续发送下一个包，但需要在缓冲区余量内。<br>最大数据量称为<strong>窗口大小</strong>：一般就是接收方缓冲区的大小</li><li>ACK和窗口合并，多个ACK时只需要发最后一个以告知接收数据的最后位置——都是为了减少包</li></ol></li><li><p><strong>协议栈接受数据的基本操作</strong>：检查收到的数据库和TCP头部，没有数据确实则返回ACK，将数据放在缓存区，数据拼接为原始数据并交给应用程序（复制到程序的内存空间），最后向发送方发送窗口更新</p></li></ul><h3 id="服务器断开并删除套接字"><a href="#服务器断开并删除套接字" class="headerlink" title="服务器断开并删除套接字"></a>服务器断开并删除套接字</h3><p>例子：服务器端调用Socket库中close程序，协议栈生成包含断开的TCP头部（控制为<strong>FIN设为1</strong>），委托IP模块向客户端发送数据，同时服务端套接字记入断开信息；客户端收到收到TCP头部，协议栈将套接字进入断开状态，并返回给服务器端<strong>ACK号</strong>；协议栈就可以等应用程序取数据了。应用程序read数据，这是协议栈告知应用程序数据收到完成。客户端应用close关闭生成<strong>FIN为1</strong>发送为服务端，服务端<strong>返回ACK</strong>，通信结束。</p><ul><li>删除套接字：需要等待时间以方便重新发送FIN</li></ul><p>总结TCP整体流程：</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908104715535.png" alt="总结TCP整体流程"></p><h3 id="IP和以太网的包收发操作"><a href="#IP和以太网的包收发操作" class="headerlink" title="IP和以太网的包收发操作"></a>IP和以太网的包收发操作</h3><p>mac头部——集线器——子网中的以太网协议（可以更换成其他网络如无线局域网）<br><strong>凡是局域网使用的头部豆角MAC头</strong></p><p>IP头部——IP协议——路由器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193611154.png" alt="image-20220908193611154"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908193629305.png" alt="image-20220908193629305"></p><h4 id="包收发操作"><a href="#包收发操作" class="headerlink" title="包收发操作"></a>包收发操作</h4><ol><li>IP模块（包传输过程的入口）：TCP模块委托IP模块发送包，即加上IP头，MAC头，包就封装好了；</li><li>封装好的包交给硬件网卡，将数字信息转换为光电信息，通过集线器、路由器等传递到接收方；</li><li>接收方拿到后做出相应，返回的包被转换为数字信息，加上TCP头部</li></ol><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220908145444278.png" alt="image-20220908145444278"></p><p>Gateway网关：在TCP&#x2F;IP中指的是路由器；<br>通过路由表来匹配该把包发给哪个网卡的IP地址；</p><h4 id="以太网内MAC地址查询："><a href="#以太网内MAC地址查询：" class="headerlink" title="以太网内MAC地址查询："></a>以太网内MAC地址查询：</h4><p>ARP（address resolution protocol）地址解析协议：一种地址广播的方法，能返回子网内相应IP地址的MAC地址；</p><p>MAC地址长度为48比特，IP地址长度32比特，也就是6部分，一字节一部分，用-或者：分开，十进制和十六进制表示；<br>media access control</p><p>目前常用的是交换式集线器：信号会更具MAC地址流到指定的设备</p><ul><li><p>以太网特性：</p><ol><li>将包发送到MAC头的接收方MAC地址所代表的的目的地；</li><li>用发送方的MAC地址识别发送方；</li><li>用以太类型识别包类型</li></ol><p>说明：无线局域网也有1和2的特点，所以用来替代以太网</p></li></ul><h4 id="网卡将IP包转化成光电信号（没看）"><a href="#网卡将IP包转化成光电信号（没看）" class="headerlink" title="网卡将IP包转化成光电信号（没看）"></a>网卡将IP包转化成光电信号（没看）</h4><p>网卡中的ROM保存唯一的MAC地址，生产时就写入的，网卡驱动初始化后生效；</p><p>返回接收包：对应MAC地址的包放入缓存区——》产生中断信号，中断控制器，CPU暂时挂起切换到中断程序——》调用网卡驱动执行操作<br>——》从缓冲区中取出包，通过MAC头部中以太类型判断包类型（协议类型）</p><p>接收——》检查IP头部——》如果不一致，返回错误ICMP（查表）</p><h3 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h3><p>TCP复杂是为了实现高效和可靠：缺失部分包的时候只需要发送出错的部分，避免了重发已经送达的包；<strong>（数组在多个包的情况）</strong></p><p>UDP没有连接和断开阶段，只要加上UDP头部，交给IP发送就行了；接收按照IP头部和接收方的地址，UDP头部端口号<strong>（在一个包大小范围内解决）</strong></p><ol><li>UDP只负责单纯发送，不会监控，所以协议栈也不知道有没有错误；</li><li>最大数据长度为IP包减去UDP头部</li><li>音频和视频会使用UDP，确实部分包会失真，但是用TCP要额外的几倍带宽</li></ol><h2 id="网线到网络设备——集线器、交换机、路由器"><a href="#网线到网络设备——集线器、交换机、路由器" class="headerlink" title="网线到网络设备——集线器、交换机、路由器"></a>网线到网络设备——集线器、交换机、路由器</h2><h3 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h3><p>每个包都是独立传输的；</p><p>传输过程：网卡中PHY（MAU）模块将包转化为电信号——》通过RJ-45进入双绞线——》信号流入网线——》集线器的接口；<br>（传输过程中信号会衰减，波形会失真；用<strong>双绞线</strong>来抑制衰减，阻隔噪声措施等）</p><p>——》集线器将信号发送给所有连接在他上面的线路（<strong>原封不动广播</strong>）</p><h3 id="交换机的包转发"><a href="#交换机的包转发" class="headerlink" title="交换机的包转发"></a>交换机的包转发</h3><p>PHY模块接收网线中信号转化为通用格式——》MAC模块将信号转化为数字信号——》包尾部检查FCS——》没异常所有包放到缓冲区——》查询MAC地址表(MAC地址和端口的对应表)——》将信号发送到相应的端口</p><ul><li>交换机的MAC模块不具有MAC地址</li><li>MAC地址表会自动维护，异常时重启交换机重置地址表就行</li><li>全双工模式是交换机特有，可以同时发送和接收操作</li><li>全&#x2F;半双工切换的问题，自动协商功能</li><li>交换机可以同时执行多个转发操作，转发能力强</li></ul><h3 id="路由器的包转发"><a href="#路由器的包转发" class="headerlink" title="路由器的包转发"></a>路由器的包转发</h3><p>路由器是基于IP设计，交换机是基于以太网设计</p><h4 id="路由器转发包过程："><a href="#路由器转发包过程：" class="headerlink" title="路由器转发包过程："></a>路由器转发包过程：</h4><p>通过委托端口接受包（取决于端口通信技术）——转发模块根据接受包的IP头部中记录接收方IP地址，在路由表中查询——》委托端口模块转发包</p><ul><li>端口模块以实际的接收方&#x2F;发送方的身份来收发网络包</li><li>路由器的以太网端口<strong>有MAC地址</strong>，路由器的IP端口<strong>有IP地址</strong></li><li>路由器的子网掩盖码值表示在匹配网络包目标地址时需要对比的比特数，有可能路由聚合合并为一个子网</li></ul><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220909144520902.png" alt="image-20220909144520902"></p><h5 id="路由器接受包"><a href="#路由器接受包" class="headerlink" title="路由器接受包"></a>路由器接受包</h5><ol><li>转化为数字信息，检查MAC地址是否匹配；</li><li>接受操作后包的MAC头部被丢弃（<strong>MAC头部的作用就是将包传递到路由器</strong>）</li></ol><h5 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h5><ol><li>按照IP头部转发，子网掩码配合IP地址，确定候选转发目标</li><li>最长匹配原则</li></ol><h5 id="找不到匹配路由时选择默认路由"><a href="#找不到匹配路由时选择默认路由" class="headerlink" title="找不到匹配路由时选择默认路由"></a>找不到匹配路由时选择默认路由</h5><ol><li>子网掩码<strong>0.0.0.0</strong>，不需要匹配，默认路由，这样配置的网关地址被称为<strong>默认网关</strong></li><li>在找不到其他匹配路由，选择默认路由</li></ol><h5 id="路由器相关工作"><a href="#路由器相关工作" class="headerlink" title="路由器相关工作"></a>路由器相关工作</h5><ul><li><p>TTL：在IP头部，表示保底有效期，经过一个路由器减1,为0就是超过有效期。<br>一般设置为64&#x2F;128，防止信息错误或者路由混乱</p></li><li><p>分片功能拆分大网络包:<br>原因：不同类型线路传输的最大包长度不同；<br>操作：用IP协议中定义的分片功能，对整个包拆分<br>前提：检查MTU，检查IP头部标志字段是否能拆</p></li></ul><blockquote><p>不同于TCP拆分，TCP是在数据拆好后放到包中，也就是一个数据块刚好是包的大小</p></blockquote><h5 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h5><p>判断下一个转发目标：<br>    如果网关列表内容为IP地址，该地址为下一个转发目标；<br>    网关列表为空，则IP头部中的接收方IP地址为下一个转发目标；<br>路由器也会用ARP查询下一个转发目标的MAC地址；         </p><h4 id="路由器和交换机"><a href="#路由器和交换机" class="headerlink" title="路由器和交换机"></a>路由器和交换机</h4><p>所说的加上MAC头，实际是上将IP包装进以太网包的数据部分，委托以太网传输数据，i.e. 路由器把包的传输工作委托给交换机；</p><p><strong>IP（路由器）负责将包发送给通信对象整个过程；</strong></p><p><strong>以太网（交换机）将包传输到下一个路由器；</strong></p><h3 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h3><p>为了解决地址不足分为<strong>私有地址(golbally unique address)，公有地址(public address)</strong></p><p>私有地址是公有地址还没有分配的范围</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220909172640673.png" alt="image-20220909172640673"></p><p>但是公司内部的私有地址不能和互联网直接进行通信，需要通过地址转换机制</p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>地址转换设备（路由器）</p><p>改写端口号，提高公有地址的利用率</p><h2 id="接入网和网络运营商"><a href="#接入网和网络运营商" class="headerlink" title="接入网和网络运营商"></a>接入网和网络运营商</h2><h3 id="ADSL接入网的结构和工作方式"><a href="#ADSL接入网的结构和工作方式" class="headerlink" title="ADSL接入网的结构和工作方式"></a>ADSL接入网的结构和工作方式</h3><p>互联网上万台路由器，按照接收方IP地址判断，将包转发出去；<br><strong>距离的不同和路由的维护方式</strong>不同，就是互联网与家庭、公司网络之间最初主要的两个不同点；</p><p>接入网：连接互联网与家庭、公司网络的通信线路（ADSL、FTTH、CATV、电话线、ISDN等）；<br>ADSL（asymmetric digital subscriber line）不对称数字用户线</p><p>ADSL modem 调制解调器：将包拆分成信元，并且转化为电信号发送给分离器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911135603820.png" alt="image-20220911135603820"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911140104023.png" alt="image-20220911140104023"></p><p>BAS（broadband access server）宽带接入服务器 ，一种<strong>路由器</strong>（不同与普通，具有身份认证，向客户端下发IP地址等配置信息的功能）：1.用户认证的窗口，2.隧道方式传输网络包</p><p>PPP （point to point protocol）点到点协议。电话线、ISDN等通信路线所用的一种协议</p><p>ATM （asynchronous transfer mode）异步传输 ，电话线为载体的通信方式，以“信元”为单位进行。</p><p>FTTH （Fibre (Fiber) To The Home）基于光线的接入网技术：用光纤代替ADSL将用户端接入路由器和运营商的BAS连接起来的接入方式</p><h4 id="分离器的作用"><a href="#分离器的作用" class="headerlink" title="分离器的作用"></a>分离器的作用</h4><p>ADSL modem将信元转化为电信号后，通过分离器，但没作用；（电话和ADSL信号同时流入线路）<br>信号从电话线传入时，分离电话和ADSL信号，防止ADSL成为电话的噪音：<br>        对于电话：分离器过滤掉高频的ADSL；<br>        对ADSL：ADSL modem内部就有信号过滤功能；<br>分离器也可以房子电话对ADSL传输方式的干扰</p><p>分离器——》电话线——》总配线架——》电话局——》DSLAM（转回数字信号 信元）——》BAS（将ATM信元转化为原始的包）</p><h3 id="光纤接入网"><a href="#光纤接入网" class="headerlink" title="光纤接入网"></a>光纤接入网</h3><p>光线的工作原理。。</p><h4 id="FTTH技术"><a href="#FTTH技术" class="headerlink" title="FTTH技术"></a>FTTH技术</h4><ol><li>直连：一种是光纤直接从用户端连接到最近的电话局：以太信号——》光信号——》DSLAM——》BAS转化为电信号，将包转发到互联网内部——》到达互联网后，服务器响应——》响应包的光信号沿着光纤返回</li></ol><p>​光线中波分复用，区别上行和下行信号</p><ol start="2"><li>分路：分光器设备，让光纤分录，同时连接多个用户：OLT和ONU避免碰撞；</li></ol><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911154100876.png" alt="image-20220911154100876"></p><h3 id="接入网中使用的PPP和隧道"><a href="#接入网中使用的PPP和隧道" class="headerlink" title="接入网中使用的PPP和隧道"></a>接入网中使用的PPP和隧道</h3><p>PPPoE（Point to Point Protocol  over Ethernet）以太网的点对点协议：将PPP消息装入以太网包进行传输的方式；</p><p>包原封不动的搬运到另一端，原理上就可以看成建立隧道；</p><p>互联网接入路由器通过PPPoE的发现机制查询BAS的MAC地址（相当于拨号上网中拨号）</p><ul><li>地址转换：是否BAS向计算机下发了TCP&#x2F;IP配置，没下发需要在路由器中转化为公有地址</li></ul><h3 id="网络运营商的内部"><a href="#网络运营商的内部" class="headerlink" title="网络运营商的内部"></a>网络运营商的内部</h3><p>POP(Point of Presense)接入点：ADSL、FTTH等接入网的连接点，互联网的入口在这里</p><p>NOC（Network Operation Center）网络运行中心，（扩大版、高性能的POP）</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911155250806.png" alt="image-20220911155250806"></p><p>按照不同类型的接入网分别使用不同类型的路由器</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911160108080.png" alt="image-20220911160108080"></p><h3 id="跨越运营商的网络包"><a href="#跨越运营商的网络包" class="headerlink" title="跨越运营商的网络包"></a>跨越运营商的网络包</h3><p>BGP（border gateway protocol） 边界网关协议：路由信息交换的过程；</p><p>运营商之间所有路由器平等交换，多路判断优先级，收费；</p><p>IX(internet eXchange)互联网交换中心：将运营商汇聚在一起，设置中信设备，减少线路数量；具有高速以太网端口的二层交换机</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911162156742.png" alt="image-20220911162156742"></p><h2 id="服务器端的局域网"><a href="#服务器端的局域网" class="headerlink" title="服务器端的局域网"></a>服务器端的局域网</h2><p>在服务器前部署一个防火墙：只允许发往特定服务器中的特定应用程序的包通过，屏蔽其他的包；常用的是包过滤方式</p><h4 id="包过滤方式（主流防火墙方式）"><a href="#包过滤方式（主流防火墙方式）" class="headerlink" title="包过滤方式（主流防火墙方式）"></a>包过滤方式（主流防火墙方式）</h4><ul><li>设置允许通过的<strong>接收方IP和发送方IP</strong>（注意应答机制，要回复ACK）</li><li>设置端口号限定应用程序，<strong>接收方端口号、发送方端口号</strong></li><li><strong>控制位</strong>判断连接方向（TCP头部的控制位；但是对UDP没有控制位可以设置只能公司内网访问DNS服务器，牺牲便利性）</li><li>对具体数据不能识别风险：一种是持续关注安全漏洞信息并更新软件的版本；一种是在防火墙之外部署用来检查包内容并阻止有害包的设备或软件。</li></ul><p>内网访问公开区域</p><p>外部互联网访问公司内网，默认不能访问，内网到外网的话需要地址转化</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911171030839.png" alt="image-20220911171030839"></p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220911171046135.png" alt="image-20220911171046135"></p><h4 id="通过将请求平均分配给多台服务器来平衡负载"><a href="#通过将请求平均分配给多台服务器来平衡负载" class="headerlink" title="通过将请求平均分配给多台服务器来平衡负载"></a>通过将请求平均分配给多台服务器来平衡负载</h4><p>服务器的访问量上升，需要增加带宽和提高服务器性能；<br>提高服务器性能可以使用多台服务器来分担负载的方法——分布式架构；<br>采用多台Web服务器，减少每台服务器的访问量；<br>用DNS按顺序循环分配多台不同的IP地址——轮询；</p><p>问题：1. 一台宕机了咋办——访问返回失败，尝试下一个IP<br>            2. 有些操作跨多个页面，访问服务器变化则操作无法继续</p><h5 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h5><p>用其IP地址代替Web服务器的实际地址注册到DNS服务器上；</p><p>操作跨多个页面时，请求发送到同一个Web服务器——》判断请求之间的相关性，在HTTP头部加入Cookie<br>其他情况需要定期采集Web服务器的CPU、内存使用率</p><h5 id="缓存服务器"><a href="#缓存服务器" class="headerlink" title="缓存服务器"></a>缓存服务器</h5><p>服务器按照功能划分不同服务器，缓存服务器是一台通过代理机制对数据进行缓存的服务器；<br>代理在Web服务器和客户端之间，Web服务器返回的数据保存在此版中（<strong>缓存</strong>）</p><p>缓存服务器注册到DNS服务器中</p><p>Via: 表示缓存服务器中专的</p><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p>缓存服务器在客户端一侧部署；用作转发过程判断是否允许访问、用作防火墙的实现；</p><ul><li><p>设置时，需要在浏览器的设置窗口的代理服务器中填写正向代理的IP地址</p></li><li><p>有代理时，客户端发送给缓存服务器的请求头不需要直接填写http:&#x2F;&#x2F;这样的完整网址</p></li></ul><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p>服务器端的缓存服务器，将请求消息中URI的吗，目录名与Web服务器进行关联，能转发不带完整网址的请求</p><h5 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h5><p>用包的IP头部中接收方的Ip地址判断访问服务器；</p><p>在消息经过时拦截</p><h3 id="内容分发服务"><a href="#内容分发服务" class="headerlink" title="内容分发服务"></a>内容分发服务</h3><p>缓存服务器放在客户端——降低Web服务器的负载——无法减少互联网的网络流量</p><p>缓存服务器放在Web服务器端——Web服务器无法控制——减少网络流量</p><p>缓存服务器放在互联网的边缘（集合优点，但是互联网都可以访问，部署数量需求多）——服务器运营者能控制——降低网络流量</p><p>内容分发服务：CDN(content delivery network) 或者叫CDS(system)<br>内容分发服务运营商：CDSP(provider)</p><p>提前查询路由器到各个缓存服务器的之间的距离，判断最近的</p><h2 id="请求到达服务器，响应返回浏览器"><a href="#请求到达服务器，响应返回浏览器" class="headerlink" title="请求到达服务器，响应返回浏览器"></a>请求到达服务器，响应返回浏览器</h2><h3 id="服务器的基本信息"><a href="#服务器的基本信息" class="headerlink" title="服务器的基本信息"></a>服务器的基本信息</h3><p>服务器和客户端的协议栈、网卡、Socket库（调用其中的程序组件不一致）等功能一致，TCP&#x2F;IP的功能统一，客户端计算机也可以用作服务器；</p><h5 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h5><p>客户端通信模块一般是与客户端一对一的关系；<br>服务器操作系统具有多任务、多线程功能，同时运行多个程序；<br>：任务作为单个程序，线程是程序的一个部分</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220912222625199.png" alt="image-20220912222625199"></p><p>服务器在调用Socket库上的区别在连接阶段：<br>客户端：用管道连接服务器端的套接字<br>服务器端：1.将套接字设置为等待连接的状态 2. 接受连接</p><p>套接字的确定：客户端IP地址、客户端端口号、服务器IP地址、服务器端口号；</p><p>使用描述符来指代套接字的原因：等待连接的套接字中没有客户端IP地址和端口号、使用描述符比较简单</p><h3 id="服务器接收操作"><a href="#服务器接收操作" class="headerlink" title="服务器接收操作"></a>服务器接收操作</h3><h5 id="服务器接收操作的全过程回顾"><a href="#服务器接收操作的全过程回顾" class="headerlink" title="服务器接收操作的全过程回顾"></a>服务器接收操作的全过程回顾</h5><blockquote><p>网卡（硬件）接收信号，转化为数字信号——》按照包尾部的帧校验符FCS来校验错误——》MAC头部检查接收方的MAC地址——》保存在网卡的缓冲区中</p></blockquote><ul><li>网卡的MAC模块将网络包从信号还原为数字信息，校验FCS并且存入缓冲区</li></ul><blockquote><p>——》CPU处理中断，网卡驱动运行，读取缓冲区的包——》根据MAC头部的以太类型判断协议种类——》调用负责处理该协议的程序（也就是TCP&#x2F;IP协议栈）</p></blockquote><ul><li>网卡驱动按照MAC头部判断协议类型，并且发送个相应的协议栈</li></ul><blockquote><p>——》达到协议栈后，IP模块检查IP头部中接收方IP地址，判断转发——》检查IP头部知道是否分片，如果分片了，现存在内存里，等组装充足后还原为原始包——》检查IP头部的协议号，06则为TCP模块，11为UDP模块</p></blockquote><ul><li>协议栈的IP模块检查IP头部，判断是不是发给自己的，网络包有没有呗切片，对应转发协议栈是TCP还是UDP</li></ul><blockquote><p> ——》TCP模块按照包的内容区别，如果是SYN为1发起连接的包——》检查包的接收方端口号有没有等待连接的套接字——》无则返回ICMP消息，有则创建套接字副本，信息写入套接字生成ACK号，生产TCP头部，委托IP模块发送给客户端——》客户端返回ACK号确认，连接完成——》服务器端及进入调用accept的暂停状态，当将新套接字的描述符转交服务器程序后，服务器恢复运行</p></blockquote><ul><li>TCP模块：根据收到包的发送方&#x2F;接收方的IP地址&#x2F;端口号找到对应的套接字；将数据拼接放在缓冲区；向客户端返回ACK号</li></ul><blockquote><p>——》服务器或者客户端发起，调用Socket库中close，TCP模块生成控制位FIN为1,发送——》客户端或服务器返回一个ACK号，生成FIN为1的TCP头部发送——》服务器或客户端返回ACK号完成</p></blockquote><ul><li>HTTP1.1中，客户端先发起断开；断开操作后，套接字过一段时间被删除</li></ul><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220913140803131.png" alt="image-20220913140803131"></p><h3 id="Web服务程序解释请求消息并做出相应"><a href="#Web服务程序解释请求消息并做出相应" class="headerlink" title="Web服务程序解释请求消息并做出相应"></a>Web服务程序解释请求消息并做出相应</h3><p>最简单的是按照请求方法+URI的HTML文件名获取</p><p>判断访问权限依据：客户端IP地址；客户端域名；用户名和密码</p><h3 id="浏览器接受响应消息并显示内容"><a href="#浏览器接受响应消息并显示内容" class="headerlink" title="浏览器接受响应消息并显示内容"></a>浏览器接受响应消息并显示内容</h3><p>按照Content-Type判断数据类型</p><p><img src="/imgs/$%7Bfiilename%7D/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20220913142737133.png" alt="image-20220913142737133"></p><p>charset&#x3D;urf-8表示文本编码方式</p><p>Content-Encoding表示压缩格式的具体转换方式</p><p>实际显示是浏览器负责对操作系统发出指令显示的</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>网络是怎样连接的 - 户根勤</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ - 复习STL和泛型</title>
      <link href="/2023/11/06/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/11/06/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一讲：STL和泛型概述"><a href="#第一讲：STL和泛型概述" class="headerlink" title="第一讲：STL和泛型概述"></a>第一讲：STL和泛型概述</h1><h2 id="认识headers、版本、重要资源"><a href="#认识headers、版本、重要资源" class="headerlink" title="认识headers、版本、重要资源"></a>认识headers、版本、重要资源</h2><h4 id="1STL"><a href="#1STL" class="headerlink" title="1STL"></a>1STL</h4><p>1.C++标准库具有6大部件，使用的方法，认识、使用、扩充；</p><p>2.C++SL包括C++STL六大部件和其他零碎的</p><p>3.新式的headers内的组件封装在namespace std</p><h2 id="STL体系架构"><a href="#STL体系架构" class="headerlink" title="STL体系架构"></a>STL体系架构</h2><h4 id="六个部件"><a href="#六个部件" class="headerlink" title="六个部件"></a>六个部件</h4><ol><li>容器containers、分配器allocators、算法algorithms、迭代器iterators、适配器adapters、仿函数Functors</li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221007201443143.png" alt="image-20221007201443143"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大于等于40的数</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>,allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia,ia+<span class="number">6</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),<span class="number">40</span>)));</span><br></pre></td></tr></table></figure><p>not1(bind2nd(less<int>(),40))为一个predicate，谓词</p><ol start="2"><li>复杂度Big-oh 其中n为一个比较大的规模</li></ol><h4 id="“前闭后开”区间用于标准库容器；"><a href="#“前闭后开”区间用于标准库容器；" class="headerlink" title="“前闭后开”区间用于标准库容器；"></a>“前闭后开”区间用于标准库容器；</h4><p>3.1 迭代器定义一<code>contianer&lt;T&gt;::iterator ite =c.begin()</code><br>3.2 <code>for(decl:coll)&#123;statement&#125;</code><br>3.3 <code>for(auto&amp; elem:vec)&#123;elem*=3&#125;;</code></p><h2 id="容器之分类与各种测试"><a href="#容器之分类与各种测试" class="headerlink" title="容器之分类与各种测试"></a>容器之分类与各种测试</h2><h4 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h4><p>sequence contaniners：array、vector 、deque、list、forward_list</p><p>associative contanniers：set&#x2F;multiset、map&#x2F;multimap（STL没有规定怎么实现，一般编译器采用红黑树实现）</p><p>unordered contaniners不定序：unordered_(hash table实现，其用separate chaining创建)</p><ul><li>呼叫时间调用clock()</li><li>全局函数前面加上::，比如<code>::find</code></li><li>容器自身算法有的时候，用容器自身的</li></ul><h4 id="容器扩充"><a href="#容器扩充" class="headerlink" title="容器扩充"></a>容器扩充</h4><p>vector的扩展是两倍扩展，新空间并拷贝原值</p><p>forward_list,一个个扩充</p><p>deque，左右边界满，扩充</p><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>一个类，不建议单独使用，应该用容器本身或者new和delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">allocator&lt;<span class="type">int</span>&gt; alloc1;</span><br><span class="line">p=alloc1.<span class="built_in">allocator</span>(<span class="number">1</span>);</span><br><span class="line">alloc1.<span class="built_in">deallocate</span>(p,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="源代码之分布（VC，GCC）"><a href="#源代码之分布（VC，GCC）" class="headerlink" title="源代码之分布（VC，GCC）"></a>源代码之分布（VC，GCC）</h2><p>2.91源代码的说明</p><h3 id="泛型GP和OOP"><a href="#泛型GP和OOP" class="headerlink" title="泛型GP和OOP"></a>泛型GP和OOP</h3><p>OOP（objective-Oriented programming）企图将date和methods合在一起；</p><p>GP(generic programming)将date和methods分开来</p><ul><li>list不能用sort()，因为不能随机访问，也就不能用二分查找</li></ul><blockquote><p>所有algorithms，其内最终设计元素本身的操作，无非就是比大小；所以类型本身类需要重载比大小操作符</p></blockquote><h3 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h3><ol><li>函数模板 <code>template &lt;typename T&gt;</code></li><li>类模板 <code>template &lt;class T&gt;</code></li><li>成员模板</li></ol><h4 id="类模板中泛化、特化、偏特化"><a href="#类模板中泛化、特化、偏特化" class="headerlink" title="类模板中泛化、特化、偏特化"></a>类模板中泛化、特化、偏特化</h4><h5 id="泛化：操作符重载和模板的复习"><a href="#泛化：操作符重载和模板的复习" class="headerlink" title="泛化：操作符重载和模板的复习"></a>泛化：操作符重载和模板的复习</h5><h5 id="Specialization-特化（全特化）"><a href="#Specialization-特化（全特化）" class="headerlink" title="Specialization 特化（全特化）"></a>Specialization 特化（全特化）</h5><p>在泛化的模板基础上，指定类型</p><p>也就是 <code>class allocator&lt;void&gt;</code> 指定了 _Tp为void类型</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008165726014.png" alt="image-20221008165726014"></p><h5 id="Partial-Specialization-偏特化"><a href="#Partial-Specialization-偏特化" class="headerlink" title="Partial Specialization 偏特化"></a>Partial Specialization 偏特化</h5><p>分为</p><ol><li>数量上（多参数中某些特化）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">People</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类的偏特化 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line">    <span class="comment">// 这句指定了偏特化T2类型到T1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&lt;T1, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(T1 a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>范围上(随意类型到指针 特化为 指针类型 或者const类型)</li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008165747920.png" alt="image-20221008165747920"></p><h1 id="第二讲：STL容器解析"><a href="#第二讲：STL容器解析" class="headerlink" title="第二讲：STL容器解析"></a>第二讲：STL容器解析</h1><h2 id="分配器allocator"><a href="#分配器allocator" class="headerlink" title="分配器allocator"></a>分配器allocator</h2><p>学习目的：理解效率，不要单独用</p><p>operator new()实际上使用malloc（）</p><h5 id="malloc-的理解"><a href="#malloc-的理解" class="headerlink" title="malloc()的理解"></a>malloc()的理解</h5><p>底层都是malloc()和free()使用分配内存;</p><p>malloc()分配时有额外的开销；</p><h5 id="allocators-的两个成员函数"><a href="#allocators-的两个成员函数" class="headerlink" title="allocators()的两个成员函数"></a>allocators()的两个成员函数</h5><p>VC6+中的allocate和deallocate，只是::operator new和::operator delete完成的；</p><p>GC和BC都也是malloc，额外开销有点大；</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器之间的关系"><a href="#容器之间的关系" class="headerlink" title="容器之间的关系"></a>容器之间的关系</h3><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008173455125.png" alt="image-20221008173455125"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008173745929.png" alt="image-20221008173745929"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>实际上里面只有一个指针（G2.9）,G4.9里存了两个指针</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008202939418.png" alt="image-20221008202939418"></p><p>void* 无类型指针：void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void指针赋值。</p><h4 id="简要包括"><a href="#简要包括" class="headerlink" title="简要包括"></a>简要包括</h4><ol><li>一堆typedef</li><li>每个节点的设计</li><li>一些操作符重载</li></ol><h4 id="操作符重载的-符"><a href="#操作符重载的-符" class="headerlink" title="操作符重载的++符"></a>操作符重载的++符</h4><p>前++重载函数无入参；后++一个入参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;node=(link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;<span class="comment">//前++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;self tmp=*<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;<span class="comment">//后++（用后++去调用前++）</span></span><br></pre></td></tr></table></figure><p>C++不允许后++两次；</p><h4 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载*"></a>操作符重载*</h4><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008203508483.png" alt="image-20221008203508483"></p><h4 id="G4-9对G2-9的改进"><a href="#G4-9对G2-9的改进" class="headerlink" title="G4.9对G2.9的改进"></a>G4.9对G2.9的改进</h4><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008203703884.png" alt="image-20221008203703884"></p><h4 id="Iterator需要遵循的原则"><a href="#Iterator需要遵循的原则" class="headerlink" title="Iterator需要遵循的原则"></a>Iterator需要遵循的原则</h4><h6 id="iterator的五种associated-type需要定义出来，以便回答算法调用时的提问；"><a href="#iterator的五种associated-type需要定义出来，以便回答算法调用时的提问；" class="headerlink" title="iterator的五种associated type需要定义出来，以便回答算法调用时的提问；"></a>iterator的五种associated type需要定义出来，以便回答算法调用时的提问；</h6><p>value_type 元素类型</p><p>difference_type距离类型</p><p>iterator_category 迭代器类型：</p><blockquote><p>1、input_iterator：istream独有的迭代器。<br>2、output_iterator：ostream独有的迭代器。<br>3、forward_iterator：继承自input_iterator，单向走的迭代器，只能走一个，不能跳。如forward_list、单向list的hashtable<br>4、bidirectional_iterator：继承自forward_iterator，双向走的迭代器，只能走一个，不能跳。如list、rb-tree、双向list的hashtable<br>5、random_access_iterator：继承自bidirectional_iterator，可以跳的迭代器。如array、vector、deque。</p></blockquote><p>reference</p><p>pointer</p><p>后两种从来没用到</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008205733573.png" alt="image-20221008205733573"></p><h4 id="萃取traits特性"><a href="#萃取traits特性" class="headerlink" title="萃取traits特性"></a>萃取traits特性</h4><p>如果iterator不是一个类，而是指针，不能用typedef咋办？？？？</p><p>方法是增加中间层——萃取机iterator_traits</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008210535103.png" alt="image-20221008210535103"></p><p>第一种是问I，第二种用偏特化区别指针和常量指针</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><strong>实际上是三个指针，大小为12</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008211832130.png" alt="image-20221008211832130"></p><h4 id="容量扩充函数的实现"><a href="#容量扩充函数的实现" class="headerlink" title="容量扩充函数的实现"></a>容量扩充函数的实现</h4><p>当容量不够了，找新空间并两倍成长（有的时候是1.5 看版本），拷贝前部，拷贝后部</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008213508832.png" alt="image-20221008213508832"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221008213538716.png" alt="image-20221008213538716"></p><h4 id="traits特性"><a href="#traits特性" class="headerlink" title="traits特性"></a>traits特性</h4><p>G2.9也是依靠萃取机作为中介，区分指针和迭代器类；G4.9也是，只是typedef很多次，评价为乱七八糟</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>没有构造、析构函数</p><p>array&lt;int ,10&gt; myArray;</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011133911387.png" alt="image-20221011133911387"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011134049430.png" alt="image-20221011134049430"></p><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011134328233.png" alt="image-20221011134328233"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ol><li><p>分段连续；</p></li><li><p>扩充时分配新的缓冲区，并且指针指向；</p></li><li><p>iterator有四个元素，node指向控制中心；当cur到达last后，需要通过node指向下一个buffer；</p></li><li><p>控制中心是vector，当缓冲区数量不够的时候，两倍增长；</p></li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011135259752.png" alt="image-20221011135259752"></p><h4 id="简要包括-1"><a href="#简要包括-1" class="headerlink" title="简要包括"></a>简要包括</h4><p>start和finish(iterator)，一个map(T**) ,一个map_type(size_type);其中iterator有四个元素，大小是16；</p><p>总大小是16+16+4+4&#x3D;40；</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011140426560.png" alt="image-20221011140426560"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011141436990.png" alt="image-20221011141436990"></p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>判断指定位置靠近头还是尾&#x3D;》推动原来的元素往前或往后&#x3D;》在指定位置插入新元素</p><h4 id="deque如何模拟连续空间"><a href="#deque如何模拟连续空间" class="headerlink" title="deque如何模拟连续空间"></a>deque如何模拟连续空间</h4><p>全部都是iterator的功劳</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011141645219.png" alt="image-20221011141645219"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142440111.png" alt="image-20221011142440111"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142457558.png" alt="image-20221011142457558"></p><ol><li><p>++调用set_node；–先判断cur</p></li><li><p>后++调用前++</p></li><li><p>+调用+&#x3D;；+&#x3D;的时候，判断有没有超出当前缓冲区，并调整缓冲区位置</p></li><li><p>-调用-&#x3D;；-&#x3D;调用+&#x3D;{return *this +&#x3D; -n;}</p></li></ol><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011142758686.png" alt="image-20221011142758686"></p><h4 id="G4-9对G2-9的改进-1"><a href="#G4-9对G2-9的改进-1" class="headerlink" title="G4.9对G2.9的改进"></a>G4.9对G2.9的改进</h4><ol><li>deque类继承；</li><li>入参去掉了buffer_size，只有两个了</li></ol><h3 id="queue和stack"><a href="#queue和stack" class="headerlink" title="queue和stack"></a>queue和stack</h3><p>这两个是容器适配器；</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011150245087.png" alt="image-20221011150245087"></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011150254672.png" alt="image-20221011150254672"></p><h5 id="一些特性："><a href="#一些特性：" class="headerlink" title="一些特性："></a>一些特性：</h5><ol><li>不允许遍历，不提供iterator；</li><li>包含deque，并且封锁一些接口；这两者实际上list也可以作为底层容器，但是慢；stack也可以用vector作为底层容器，queue不能，因为没有pop()操作；都不能用set和map作为底层；</li></ol><h3 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h3><h4 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h4><p>红黑树是平衡二叉搜索树中常被使用的一种；排序规则有利search和insert，并保持高度平衡；</p><p>红黑树提供遍历和iterators；按照正常规则遍历，就能得到排序状态；</p><p>不应使用iterators改变元素值，但是编程里面有没有禁止此。如此设计，是因为rb_tree即将为set和map服务，map允许元素的date被改变，只有元素的key才是不可改变的；</p><p>红黑树提供两种insertion操作：inset_unique()和insert_equal()</p><h4 id="容器re-tree"><a href="#容器re-tree" class="headerlink" title="容器re_tree"></a>容器re_tree</h4><p>value分为key和date两部分</p><p>模板参数5个</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011154503636.png" alt="image-20221011154503636"></p><p>使用举例</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011155147816.png" alt="image-20221011155147816"></p><h4 id="G4-9对G2-9的修改"><a href="#G4-9对G2-9的修改" class="headerlink" title="G4.9对G2.9的修改"></a>G4.9对G2.9的修改</h4><p>改为容器_Rb_tree</p><p>新版是24个字节</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011155838022.png" alt="image-20221011155838022"></p><h3 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h3><p>内含红黑树，set也是一个container adapter容器适配器</p><p>set的key就是value；</p><p>set的迭代器是const_iterator，不能修改</p><p>inset_unique()和insert_equal()的区别</p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011215003032.png" alt="image-20221011215003032"></p><h3 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h3><p>以rb_tree为底层结构，自动排序</p><p>无法用iterators改变元素的key，但是可以改变date；底层实现的iterator就是红黑树的，不做任何约束，但是在模板参数设置时<code>pair&lt;const Key,T&gt; value_type</code>  </p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011221046294.png" alt="image-20221011221046294"></p><p>multimap不能用[]插入</p><blockquote><p>lower_bound二分查找，在有序数列中查找与value相同第一元素的迭代器，如果没有则返回第一个&gt;&#x3D;value的元素的迭代器，再没有就返回end()；也就是说不破坏排序得以安插value的第一个适当的位置;</p></blockquote><p> <strong>既然[]判断元素不存在的时候，也是调用insert，直接调用insert比较快</strong></p><p><img src="/imgs/$%7Bfiilename%7D/STL%E5%92%8C%E6%B3%9B%E5%9E%8B/image-20221011221344136.png" alt="image-20221011221344136"></p><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>散列表比红黑树简单</p><p>如果发送碰撞，用链表串Separate Chaining在一起;但是链表太长（元素个数比桶个数多），要把它打散，就是把桶扩大一倍，并取最近的素数（实际上备选的list中元素已经预选好）作为新的桶个数，所有元素重新计算一遍；</p><p>![image-20221011223731538](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221011223731538.png)</p><p>模板参数6个：Value, Key, HasFcn, ExtractKey, EqualKey, Alloc</p><p>Data大小19(20)：hash(1), equals(1), get_key(1), buckets(12),num_elements(4)</p><p>![image-20221013160407487](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013160407487.png)</p><p>HashFunction的设置</p><p>![image-20221013163528922](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013163528922.png)</p><h3 id="unordered容器"><a href="#unordered容器" class="headerlink" title="unordered容器"></a>unordered容器</h3><p>![image-20221013164353617](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013164353617.png)</p><h1 id="第三讲：STL算法"><a href="#第三讲：STL算法" class="headerlink" title="第三讲：STL算法"></a>第三讲：STL算法</h1><p>算法是模板函数，其他都是模板类；</p><p>算法看不到容器，所有信息都由迭代器告知</p><p>两种形式，包含Cmp和不包含：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Cmp&gt;</span></span><br><span class="line"><span class="function"><span class="title">Algorithm</span><span class="params">(Iterator itr1,Iterator it2,Cmp comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Random Access和不能；双向和单向</p><h3 id="迭代器的分类继承图"><a href="#迭代器的分类继承图" class="headerlink" title="迭代器的分类继承图"></a>迭代器的分类继承图</h3><p>这样的好处是，用萃取提取迭代器的类型是，可以用不同入参的类型重载提取函数</p><p>![image-20221013170117951](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170117951.png)</p><p>![image-20221013170857286](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170857286.png)</p><p>在头文件typeinfo中函数typeid()，能得到编译后的类型名称</p><p>![image-20221013170950813](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013170950813.png)</p><h3 id="istream-iterator和ostrean-iteraror"><a href="#istream-iterator和ostrean-iteraror" class="headerlink" title="istream_iterator和ostrean_iteraror"></a>istream_iterator和ostrean_iteraror</h3><p>这两种的iterator_category</p><p>![image-20221013171729243](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013171729243.png)</p><p>![image-20221013171734578](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013171734578.png)</p><h3 id="逆向迭代器reverse-iterator"><a href="#逆向迭代器reverse-iterator" class="headerlink" title="逆向迭代器reverse_iterator"></a>逆向迭代器reverse_iterator</h3><p>调用迭代器适配器</p><p>![image-20221014140726217](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014140726217.png)</p><h3 id="iterator对算法的影响"><a href="#iterator对算法的影响" class="headerlink" title="iterator对算法的影响"></a>iterator对算法的影响</h3><h4 id="distance算法"><a href="#distance算法" class="headerlink" title="distance算法"></a>distance算法</h4><p>：返回值，输入参数</p><ol><li>其中randomaccess类型只需要相减，但是input类型只能一步步操作，差异非常大</li><li>distance()调用子函数_distance()的不同重载，这是常见的处理方法</li></ol><p>![image-20221013190247992](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013190247992.png)</p><h4 id="advance-算法"><a href="#advance-算法" class="headerlink" title="advance()算法"></a>advance()算法</h4><p>与distance不同，这里用iterator_category()函数返回迭代器的类型</p><p>![image-20221013191224717](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013191224717.png)</p><h4 id="copy-算法"><a href="#copy-算法" class="headerlink" title="copy()算法"></a>copy()算法</h4><p>![image-20221013194550327](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013194550327.png)</p><h4 id="destroy-算法"><a href="#destroy-算法" class="headerlink" title="destroy()算法"></a>destroy()算法</h4><p>![image-20221013192424286](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013192424286.png)</p><h4 id="unique-copy-算法"><a href="#unique-copy-算法" class="headerlink" title="unique_copy()算法"></a>unique_copy()算法</h4><p>![image-20221013192928038](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013192928038.png)</p><h4 id="小结对算法的影响"><a href="#小结对算法的影响" class="headerlink" title="小结对算法的影响"></a>小结对算法的影响</h4><p>继承可以翻译为is a</p><p>算法源码对迭代器类型的暗示是通过形参的名字告诉你，但是必须接受所有类型的迭代器；</p><p>![image-20221013194419258](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221013194419258.png)</p><h2 id="算法例子剖析"><a href="#算法例子剖析" class="headerlink" title="算法例子剖析"></a>算法例子剖析</h2><p>按照算法的标准样式，区别STL的算法和普通函数</p><h3 id="算法例子11个"><a href="#算法例子11个" class="headerlink" title="算法例子11个"></a>算法例子11个</h3><h4 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate()算法"></a>accumulate()算法</h4><p>第三个参数可以是自定义函数或者仿函数的对象</p><p>![image-20221014135321464](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135321464.png)</p><h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each()算法"></a>for_each()算法</h4><p>![image-20221014135418453](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135418453.png)</p><h4 id="replace-算法"><a href="#replace-算法" class="headerlink" title="replace()算法"></a>replace()算法</h4><p>![image-20221014135440211](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135440211.png)</p><h4 id="count-算法"><a href="#count-算法" class="headerlink" title="count()算法"></a>count()算法</h4><p>迭代器类型非random_access的不能用</p><p>关联容器用自带的快多了</p><p>![image-20221014135546161](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135546161.png)</p><h4 id="find-算法"><a href="#find-算法" class="headerlink" title="find()算法"></a>find()算法</h4><p>迭代器类型非random_access的不能用</p><p>关联容器用自带的快多了</p><p>![image-20221014135744390](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014135744390.png)</p><h4 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort()算法"></a>sort()算法</h4><p>关联容器自带排序的</p><p>![image-20221014140156822](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014140156822.png)</p><h4 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search()算法"></a>binary_search()算法</h4><p>调用lower_bound()二分搜寻</p><p>归纳后：</p><p>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>![image-20221014141107968](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014141107968.png)</p><h2 id="仿函数functors"><a href="#仿函数functors" class="headerlink" title="仿函数functors"></a>仿函数functors</h2><p>函数对象，类中重载小括号，STL定义很多仿函数</p><p>![image-20221014143544712](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014143544712.png)</p><h4 id="仿函数可适配的条件"><a href="#仿函数可适配的条件" class="headerlink" title="仿函数可适配的条件"></a>仿函数可适配的条件</h4><p>：需要继承一元和二元仿函数的基类，也就是unary_function或者binary_function其中一个。继承之后，才可回答被仿函数适配器的提问，实参的类型是什么。</p><p>![image-20221014143605807](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014143605807.png)</p><h2 id="适配器Adapters"><a href="#适配器Adapters" class="headerlink" title="适配器Adapters"></a>适配器Adapters</h2><p>改造器，要改造原有的部件的功能，用内含而不是继承的方式包含原有的部件</p><p>存在多种适配器：Contanier Adapters, Functor Adapters, Iterator Adapters</p><p>![image-20221014153946103](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014153946103.png)</p><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>stack,queue内含的deque并且改造函数接口</p><p>![image-20221014153956095](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014153956095.png)</p><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><p>修饰function形成function的样子</p><h4 id="bind2nd-函数和binder2nd函数对象"><a href="#bind2nd-函数和binder2nd函数对象" class="headerlink" title="bind2nd()函数和binder2nd函数对象"></a>bind2nd()函数和binder2nd函数对象</h4><ol><li><p>less<int>()和40被记在binder2nd类的Data中，等之后类内operatpr()调用后再拿出来用；</p></li><li><p>bind2nd()函数返回临时对象binder2nd;</p></li><li><p>适配器操作后，需要询问算法的入参（1或2个参数的类型）和结果（返回值的类型）</p></li><li><p>![image-20221014154005666](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014154005666.png)</p></li></ol><h4 id="新型适配器-，bind来取代原有的"><a href="#新型适配器-，bind来取代原有的" class="headerlink" title="新型适配器 ，bind来取代原有的"></a>新型适配器 ，bind来取代原有的</h4><p>![image-20221014154134036](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014154134036.png)</p><h4 id="not1"><a href="#not1" class="headerlink" title="not1()"></a>not1()</h4><p>一元谓词；</p><p>记录入参，返回<code>!pred</code>，C17已经弃用</p><h4 id="bind-和占位符"><a href="#bind-和占位符" class="headerlink" title="bind()和占位符"></a>bind()和占位符</h4><p>新版STL中取代之前的函数对象和函数</p><ol><li>对于函数，绑定对象，设置占位符以备之后调用函数时作为入参；占位符<code>_1</code>和<code>_2</code>的就是参数的顺序</li><li>还可以改变模板参数，绑定返回类型比如<code>bind&lt;int&gt; (my_divide,10,2)</code>;</li><li>还可以把成员函数，绑定给要做用的对象，比如<code>auto f1=bind(&amp;MyPair::multiply,_1);f1(ten_two);</code></li></ol><p>![image-20221014155526664](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014155526664.png)</p><p><strong>std::bind可以绑定</strong>：</p><ol><li>functions;</li><li>function objects;&#x2F;&#x2F;这种是注释讲了，也就是把方程改为仿函数</li><li>member functions,_1必须是个object地址;&#x2F;&#x2F;比如说<code>auto f1 = bind(&amp;MyPair::multiply,ten_two);</code></li><li>date member，_1必须是某个object地址；&#x2F;&#x2F;比如说<code>auto f1 = bind(&amp;MyPair::b,_1);</code>,调用<code>f1(ten_two)</code>只会输出成员b的数，这个很特别</li></ol><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><h4 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h4><p>![image-20221014162046483](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014162046483.png)</p><h4 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h4><p>不同于赋值assign，重载操作符，使得&#x3D;变为insert操作</p><p>![image-20221014163840295](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221014163840295.png)</p><h3 id="X适配器"><a href="#X适配器" class="headerlink" title="X适配器"></a>X适配器</h3><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p>输出迭代器的适配器，直接用于输出;</p><p>实现方式也是用重载算法的操作符operator&#x3D;为&lt;&lt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(std::cout,<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>(),out_it);</span><br></pre></td></tr></table></figure><p>![image-20221015113148564](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015113148564.png)</p><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>输出迭代器的适配器</p><p>实现是重载算法的operator&#x3D;为&gt;&gt;</p><p>没有参数的作为标兵，有参数的绑定输如cin，读当前it指向的值，++往下读；</p><p>![image-20221015114603355](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015114603355.png)</p><p>下面这个连算法的first和last迭代器都改为了iit和eos，但是算法流程框架没变，第三个参数insert(c,c.begin())重载了&#x3D;为insert操作；</p><ul><li>当创建了istream_iterator后，这个类自动实现++也就是立刻read，往下进行。</li></ul><p>![image-20221015114949021](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015114949021.png)</p><h1 id="第四讲-STL其余体系结构"><a href="#第四讲-STL其余体系结构" class="headerlink" title="第四讲 STL其余体系结构"></a>第四讲 STL其余体系结构</h1><h3 id="一个万用的hash-fuction"><a href="#一个万用的hash-fuction" class="headerlink" title="一个万用的hash fuction"></a>一个万用的hash fuction</h3><ol><li>其中…是省略一些参数的写法, <strong>variadic templates</strong>可变化的模板，可以放任意的参数</li><li>每一个分出来seed，计算出，最后当做hashcode，一直到全部拆解完成加上hashcode</li><li>hash_combine()中seed的计算用的是黄金分割</li></ol><p>![image-20221015150133530](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150133530.png)</p><p>用例尝试，作为unordered_set的hashfunction(第二参数)</p><p>![image-20221015150909323](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150909323.png)</p><p>![image-20221015150932418](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015150932418.png)</p><h3 id="tuple，用例"><a href="#tuple，用例" class="headerlink" title="tuple，用例"></a>tuple，用例</h3><p>一些数据的组合，相对于pair</p><p>![image-20221015153445595](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015153445595.png)</p><ol><li>创建用括号初始化，也可以用make_tuple创建</li><li>取出成员用get&lt;1&gt;(t1)</li><li>整个tuple可以用于比较，相同成分的tuple比较，不同成分tuple的比较</li><li>整个tuple可以互相赋值，整个tuple可以cout</li><li>可以初始刷为具体的值，然后用tie绑定变量到值</li><li>tuple_size<t1>::value可以得到tuple的成员数；tuple_element&lt;1,t1&gt;::type f1&#x3D;10可以获得指定元素的类型；</li></ol><h4 id="tuple实现"><a href="#tuple实现" class="headerlink" title="tuple实现"></a>tuple实现</h4><p>还是用到<strong>variadic templates</strong>；tuple类继承他自己，递归继承他的尾部，头部作为成员数据，用于声明变量；当为空就结束</p><p>![image-20221015155218423](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015155218423.png)</p><h3 id="type-traits原编程"><a href="#type-traits原编程" class="headerlink" title="type traits原编程"></a>type traits原编程</h3><p>C++ 提供元编程设施，诸如类型特性、编译时有理数算术，以及编译时整数序列。</p><p>利用特化偏特化，判断构造函数、拷贝构造、析构函数等重不重要</p><p>![image-20221015161257834](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161257834.png)</p><p>C++11中定义了很多的元编程，用于各种类型的查询</p><p>![image-20221015161808849](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161808849.png)</p><p>![image-20221015161851035](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015161851035.png)</p><h4 id="用traits分析string"><a href="#用traits分析string" class="headerlink" title="用traits分析string"></a>用traits分析string</h4><p>实际上使用string，是调用<code>basic_string&lt;char&gt;</code></p><p>![image-20221015162105748](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015162105748.png)</p><h4 id="traits实现"><a href="#traits实现" class="headerlink" title="traits实现"></a>traits实现</h4><p>基本都是泛化和偏特化实现的</p><p>remove_const和remove_volatile，用特化来拿掉</p><p>_is_void用特化返回void类型，实现</p><p>![image-20221015165340384](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165340384.png)</p><p>is_integral</p><p>![image-20221015165633636](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165633636.png)</p><p>调用编译过程的接口，找不到源代码，grep的工具可以查看</p><p>![image-20221015165652628](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015165652628.png)</p><p>![image-20221015170030086](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170030086.png)</p><h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout的类型为_IO_ostream_withassign，继承自ostream，其中重载了和对不同入参的&lt;&lt;操作、</p><p>![image-20221015170847219](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170847219.png)</p><p>![image-20221015170907392](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015170907392.png)</p><h3 id="moveable元素（移动构造）"><a href="#moveable元素（移动构造）" class="headerlink" title="moveable元素（移动构造）"></a>moveable元素（移动构造）</h3><h4 id="对于vector速度效能的影响"><a href="#对于vector速度效能的影响" class="headerlink" title="对于vector速度效能的影响"></a>对于vector速度效能的影响</h4><p>加入move功能的容器，速度上效率会高</p><p>其中MCtor是有move功能的构造函数。CCtor是没有move功能的构造函数。</p><p>其中std::move()是有move的拷贝构造。</p><h4 id="对list的影响"><a href="#对list的影响" class="headerlink" title="对list的影响"></a>对list的影响</h4><p>list是逐个创建，时间效率差距不大；deque其实也影响不大；</p><p>但是除了创建，其他操作可能也有影响</p><h4 id="一个moveable类"><a href="#一个moveable类" class="headerlink" title="一个moveable类"></a>一个moveable类</h4><p>是一种浅拷贝，并且在析构中判断是否要delete指针</p><p>![image-20221015172804821](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015172804821.png)</p><p>![image-20221015172812092](D:\OneDrive\OneDrive - whut.edu.cn\图床\image-20221015172812092.png)</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Modelica - Modelica语言学习</title>
      <link href="/2023/11/06/modelica%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/06/modelica%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h2><p>1.新建package-》新建modelica类</p><p>2.找组件modelica–&gt;mechanics–&gt;translational–&gt;components等；找信号源blocks–&gt;sources等</p><p>3.模件进行连接</p><p>4.元件设置参数</p><p>5.仿真-仿真设置</p><h2 id="二、模型类化"><a href="#二、模型类化" class="headerlink" title="二、模型类化"></a>二、模型类化</h2><p>打开类看单个构件的建模语言</p><p>新建类–&gt;扩展 （选库中类的)–&gt;在扩展类中写方程–&gt;调用到modelica类中使用</p><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote><p><strong>变量声明：</strong></p><ol><li>类型：Real，Integer, Boolean,String,enumeration</li><li>前缀：input, output, parameter;</li><li>可见性：public， protected;</li></ol><p><strong>注释：</strong><br> 1.单行；多行；<br> 2.引号注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real foo &quot; A special comment&quot;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real x[3,3]=&#123;1,2,3;4,5,6;4,5,6&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>标注：</strong>annotation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equation</span><br><span class="line">der(x) = 1-x ”Drives value of x toward 1.0”;</span><br><span class="line">annotation(experiment(StartTime=0,StopTime=8));//定义模型仿真开始和结束的时间</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>标注中包含的信息与模型的属性没有直接联系，只是提供进行模拟仿真的条件</p><ol><li><p>对变量、语句（方程）、继承：紧跟在一个声明的后面，并且在标示符 ; 的前面 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real length ”Rod length” annotation(...);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li><li><p>模型标注数据直接在模型自身定义的时候声明</p></li></ol><ul><li><p>标注中即可以包含对变量的赋值，也可以包含对一些内部变量的修改</p></li><li><p>标注就是为了方便模型开发者将任意数据添加到模型中而设计的，</p></li><li><p>可以同时多个标注，</p></li><li><p>只要标注的名称不同，我们就可以一次加入多个。</p><p>​：在加入零件号时，最好要将其放一个特别 的变量内。这个变量最好应该和你的公司或者应用情况相关，而且足够特别 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotation(XogenyIndustries(PartNumber=”FF78-E4B879”),</span><br><span class="line">experiment(StartTime=0,StopTime=8));</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>变量 XogenyIndustries 可以为某个特定组织或目的创建出一个“命名空间”</p></li><li><p>几种标准标注：Documentation；experiment；Evaluate；HideResult（P37）</p></li></ul><p><strong>逻辑运算符：</strong><br> and , or, not,&lt;,&gt;,&lt;&gt;,&lt;&#x3D;, &gt;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if &lt;condition&gt; then</span><br><span class="line">...</span><br><span class="line">elseif &lt;condition&gt; then</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>循环：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in1:10 loop</span><br><span class="line">  ...</span><br><span class="line">end for;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h2 id="四、函数语法"><a href="#四、函数语法" class="headerlink" title="四、函数语法"></a><strong>四、函数语法</strong></h2><blockquote><p><strong>分区标志符</strong></p><p>​    函数内容：alogrithm<br>​     局部变量：protected</p><p><strong>参数默认值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input Real tol=le-5 &quot;Input with default value&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>多个输出变量:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line">  function demo_fuction</span><br><span class="line">    input Real in1&quot;The first input demo function&quot;;</span><br><span class="line">    input Real in2&quot;The second argument&quot;;</span><br><span class="line">    output Real out1&quot;The first output for demo&quot;;</span><br><span class="line">    output Real out2&quot;The second output for demo&quot;;</span><br><span class="line">    </span><br><span class="line">    /*(out1,out2)=demo(in1,in2)*/</span><br><span class="line">  protected//局部变量</span><br><span class="line">    Real p1;</span><br><span class="line">  algorithm</span><br><span class="line">       p1:=in1-in2;</span><br><span class="line">     out1:=in1+in2;</span><br><span class="line">     </span><br><span class="line">     out2:=in1*in2;</span><br><span class="line">     </span><br><span class="line">     p1:=in1-in2;</span><br><span class="line">     </span><br><span class="line">  end demo_fuction;</span><br><span class="line">end demo;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>调用:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(out1,out2)=Fuctions.demo_fuction(in1=10,in2=20);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><p>函数测试：右键调用inputs，结果检验；</p><blockquote><p>例题：将致密矩阵M转化为存储格式的稀疏矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function  coo</span><br><span class="line">  input Real M[:,:] &quot;Input dense matrix&quot;;</span><br><span class="line">  input Real tol = le-5 &quot;M[i,j]&lt;tol is considered empty. Tolerance value&quot;;</span><br><span class="line">  </span><br><span class="line">  output Integer rows[:] &quot;Row indices&quot;;</span><br><span class="line">  output Integer cols[:] &quot;Colum indices&quot;;</span><br><span class="line">  output Real data[:] &quot;values&quot;;</span><br><span class="line">protected</span><br><span class="line">  Integer r_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Integer c_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Real d_temp[size(M, 1) * size(M, 2)];</span><br><span class="line">  Integer counter;</span><br><span class="line">algorithm</span><br><span class="line">  counter := 0;</span><br><span class="line">  for i in 1:size(M, 1) loop</span><br><span class="line">    for j in 1:size(M, 2) loop</span><br><span class="line">      if abs(M[i, j]) &gt; tol then</span><br><span class="line">        counter := counter + 1;</span><br><span class="line">        r_temp[counter] := i;</span><br><span class="line">        c_temp[counter] := j;</span><br><span class="line">        d_temp[counter] := M[i, j];</span><br><span class="line">      end if;</span><br><span class="line">    end for;</span><br><span class="line">  end for;</span><br><span class="line">  rows := r_temp[1:counter];</span><br><span class="line">  cols := c_temp[1:counter];</span><br><span class="line">  date := d_temp[1:counter];</span><br><span class="line">end coo;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h2 id="五、等式语法"><a href="#五、等式语法" class="headerlink" title="五、等式语法"></a>五、等式语法</h2><p>modelica各元素的组合关系</p><p>变量-表达式-等式组件-系统</p><blockquote><p>语法不同于其他语言，掌握核心</p><p>核心：通过<strong>等式</strong>建立起变量之间的关系，并使<strong>未知变量数量与等式变量一致</strong></p></blockquote><h3 id="model-x2F-block结构"><a href="#model-x2F-block结构" class="headerlink" title="model&#x2F;block结构"></a><strong>model&#x2F;block结构</strong></h3><blockquote><p>model ModeName”模型描述（非必要）”<br>  &#x2F;&#x2F;声明状态变量，参数，输入&#x2F;输出变量等<br> initial equation<br>     &#x2F;&#x2F;初始化等式<br> equation<br>     &#x2F;<em>构建已知未知量之间的关系的等式</em>&#x2F;<br> end ModeName;</p></blockquote><h3 id="等式语法-基本等式"><a href="#等式语法-基本等式" class="headerlink" title="等式语法-基本等式"></a>等式语法-基本等式</h3><p>构建已知与未知或未知与未知量之间的关系</p><blockquote><p>格式： &lt;表达式1&gt;&#x3D;&lt;表达式2&gt;</p></blockquote><p>&#x3D;不表示赋值，无因果关系</p><h3 id="条件等式"><a href="#条件等式" class="headerlink" title="条件等式"></a>条件等式</h3><p>表达形式1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x= if a&gt;b then sin(time) else cos(time);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>表达形式2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if a&gt;b then</span><br><span class="line">        x=sin(time);</span><br><span class="line">else</span><br><span class="line">        x=cos(time);</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1.方程的平衡形式：<br> 核心是要保持等式数量不变，等式有if一定有else；<br> 变量的数量必须等于方程的数量，而且，在模拟的过程中方程的数量必须是固定的</p><p> 2.不平衡形式：<br> ​​​​​​​if 和 else 两侧的方程数量是不同的<br> 仅当 ：模拟过程中条件表达式的值不能改变 ；方程的数量在模拟过程中不能改变；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">parameter Boolean steady_state;</span><br><span class="line">initial equation</span><br><span class="line">if steady_state then</span><br><span class="line">der(x) = 0;</span><br><span class="line">der(y) = 0;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果布尔参数 steady_state（稳定状态）为真，那么初始方程是有效的。但是如果参数为假， 它们就无效。这里的条件表达式具有参数级别的可变性是因为，表达式仅仅包含一个变量，而这个变量 是个参数。</p></blockquote><h3 id="初始值等式"><a href="#初始值等式" class="headerlink" title="初始值等式"></a><strong>初始值等式</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initial equation </span><br><span class="line">        x=3;</span><br><span class="line">        der(y)=0;</span><br><span class="line">        z=p0;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="注意：变量定义域；检验等式平衡性"><a href="#注意：变量定义域；检验等式平衡性" class="headerlink" title="注意：变量定义域；检验等式平衡性"></a>注意：变量定义域；检验等式平衡性</h3><h1 id="五、MSL"><a href="#五、MSL" class="headerlink" title="五、MSL"></a>五、MSL</h1><blockquote><p>Modelica.Blocks</p><ul><li>包含强因果关系的模型</li><li>一般包含一个或多个input和output连接器</li><li>一般用于信号生成及信号处理<br> 多用于辅助物理模型，而不是建构</li></ul><p>Modelica.Blocks.Sources<br> 信号源输出</p></blockquote><blockquote><p>差值模块<br> Modelica.Blocks.Tables.CombiTable1Ds一维单变量差值</p><ul><li>用作信号源</li><li>数据模型</li></ul></blockquote><hr><h1 id="一、基本方程"><a href="#一、基本方程" class="headerlink" title="一、基本方程"></a>一、基本方程</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter Real T_inf(unit=”K”)=298.15 ”Ambient temperature”;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 1.关键字parameter 表明变量的 值是先验已知的（即仿真开始之前）<br> 2.每个变量的声明部分都包含与变量相关联的物理单元文本 (unit&#x3D;”…”): ”1” 代表值没有物理 单位,。另一方面””（默认没有给定值）表明物理单位不确定。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">model NewtonCoolingWithTypes ”Cooling example with physical types”</span><br><span class="line">// Types</span><br><span class="line">type Temperature=Real(unit=”K”, min=0);</span><br><span class="line">type ConvectionCoefficient=Real(unit=”W/(m2.K)”, min=0);</span><br><span class="line">type Area=Real(unit=”m2”, min=0);</span><br><span class="line">type Mass=Real(unit=”kg”, min=0);</span><br><span class="line">type SpecificHeat=Real(unit=”J/(K.kg)”, min=0);</span><br><span class="line">// Parameters</span><br><span class="line">parameter Temperature T_inf=298.15 ”Ambient temperature”;</span><br><span class="line">parameter Temperature T0=363.15 ”Initial temperature”;</span><br><span class="line">parameter ConvectionCoefficient h=0.7 ”Convective cooling coefficient”;</span><br><span class="line">parameter Area A=1.0 ”Surface area”;</span><br><span class="line">parameter Mass m=0.1 ”Mass of thermal capacitance”;</span><br><span class="line">parameter SpecificHeat c_p=1.2 ”Specific heat”;</span><br><span class="line">// Variables</span><br><span class="line">Temperature T ”Temperature”;</span><br><span class="line">initial equation</span><br><span class="line">T = T0 ”Specify initial value for T”;</span><br><span class="line">equation</span><br><span class="line">m*c_p*der(T) = h*A*(T_inf-T) ”Newton’s law of cooling”;</span><br><span class="line">end NewtonCoolingWithTypes;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>一旦定义了一个物理类型比如 Temperature，我们可以使用它为多 个变量（例如 T、T_inf 和 T0）进行声明</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real x(start=5, fixed=true);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li>start 属性的主要目的是（正如在初始化 ( 31) 那节里广泛讨 论过的）为状态变量提供“备用”的初始状态。</li><li>start 属性的也可以用于变量，是迭代变量时的初始假想值。</li><li>最后，如果一个 parameter 没有明确指定的值，那么 start 属性的值可以作为 parameter 的默认值。</li></ol><p>在声明变量的 start 属性时直接指 定其初始条件；变量的 fixed 属性被 用来通知编译器 start 属性必须作为初始条件来使用</p><p>start 属性的其中一个作用是提供初始化猜想值：因为该变量必须通过系统的非线性方程组来 求解。这也就意味着，我们要对变量 x 和 y 的 start 属性值进行指定，以尽量“避开”系统的零解（或 者说至少接近我们期望的非零解）</p></blockquote><blockquote><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model QuiescentModelWithInheritance ”Steady state model with inheritance”</span><br><span class="line">extends ClassicModel;</span><br><span class="line">initial equation</span><br><span class="line">der(x) = 0;</span><br><span class="line">der(y) = 0;</span><br><span class="line">end QuiescentModelWithInheritance;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>从 ClassicModel 模型中复制（或“继承”） 其包含的所有内容，而无需重复定义。因此，除了新加入的初始化方程外，QuiescentModelWithInheritance 模型和 ClassicModel 模型其他部分完全一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model QuiescentModelWithModifications ”Steady state model with modifications”</span><br><span class="line">extends QuiescentModelWithInheritance(gamma=0.3, delta=0.01);</span><br><span class="line">end QuiescentModelWithModifications;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>允许对模型加入相应的“修改语句”</p><ul><li>按照惯例，extends 子句通常列在模型定义最上方，在任何变量之前</li></ul></blockquote><blockquote><h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><p>type NewTypeName &#x3D; BaseTypeName(&#x2F;* attributes to be modified *&#x2F;);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Temperature = Real(unit=”K”); // Could be a temperature difference</span><br><span class="line">type AbsoluteTemperature = Temperature(min=0); // Must be positive</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>BaseTypeName（基本类型名称）一般为内置类型（比如 Real（实数））。但是它也可以是另外一种派生 类型。这意味着多层次的限定也是支持的。</p></blockquote><blockquote><h2 id="Record-类型"><a href="#Record-类型" class="headerlink" title="Record 类型"></a>Record 类型</h2><p>record 类型可以有自己的变量，但是不允许包含方程。record 类型主要用于数据的分组</p><p>定义record；创建record：记录构造函数输入record类型内部定义匹配的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">record Vector ”A vector in 3D space”</span><br><span class="line">Real x;</span><br><span class="line">Real y;</span><br><span class="line">Real z;</span><br><span class="line">end Vector;</span><br><span class="line"></span><br><span class="line">parameter Vector v = Vector(x=1.0, y=2.0, z=0.0);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><h1 id="二、离散行为"><a href="#二、离散行为" class="headerlink" title="二、离散行为"></a>二、离散行为</h1><p>事件是任何在系统内触发了某种不连续性的东西：<br> “时间事件”：发生在某个特定时间的事件是最简单的一类事件；<br> “状态事件”：等到某信号越过特定阈值</p><p>time 是一个内置在所有 Modelica 模型内的变量</p><blockquote><p> T_inf &#x3D; 298.15 - (if time&lt;0.5 then 0 else 20*(time-0.5));<br> T_inf &#x3D; 298.15 - max(0, 20*(time-0.5));&#x2F;&#x2F;用max表示环境温度的变化</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">model NewtonCooling</span><br><span class="line">//Types</span><br><span class="line">type Temperature=Real(unit=&quot;K&quot;,min=0);</span><br><span class="line">type ConvectionCoefficient=Real(unit=&quot;W/(m2.k)&quot;,min=0);</span><br><span class="line">type Area=Real(unit=&quot;m2&quot;,min=0);</span><br><span class="line">type Mass=Real(unit=&quot;kg&quot;,min=0);</span><br><span class="line">type SpecificHeat=Real(unit=&quot;J/(K.kg)&quot;,min=0);</span><br><span class="line"></span><br><span class="line">//Parameters</span><br><span class="line">parameter Temperature T0=363.15&quot;Initial temperature&quot;;</span><br><span class="line">parameter ConvectionCoefficient h=0.7&quot;Convective cooling coefficient&quot;;</span><br><span class="line">parameter Area A=1.0&quot;Surface area&quot;;</span><br><span class="line">parameter Mass m=0.1&quot;Mass of thermal capacitance&quot;;</span><br><span class="line">parameter SpecificHeat c_p=1.2&quot;Specific heat&quot;;</span><br><span class="line"></span><br><span class="line">//Variables</span><br><span class="line">Temperature T_inf&quot;Ambient temperature&quot;;</span><br><span class="line">Temperature T &quot;Temperature&quot;;</span><br><span class="line"></span><br><span class="line">initial equation</span><br><span class="line">  T=T0&quot;Specify initial value for T&quot;;</span><br><span class="line">equation</span><br><span class="line">  if time&lt;=0.5 then</span><br><span class="line">    T_inf=298.15&quot;Constant temperature when time &lt;=0.5&quot;;</span><br><span class="line">  else</span><br><span class="line">    T_inf=298.15-20*(time-0.5)&quot;Otherwise,increasing&quot;;</span><br><span class="line">  end if;</span><br><span class="line">  m*c_p*der(T)=h*A*(T_inf-T)&quot;Newton&#x27;s law of cooling&quot;;  </span><br><span class="line"></span><br><span class="line">end NewtonCooling;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>问题：0x000002错误</p><p>另：可以用初始方程，方程从平衡态开始</p><blockquote><p>if表达式代替if语句</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Modelica </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OS - 计算机操作系统复习思维导图</title>
      <link href="/2023/11/06/ComputerSysMind/"/>
      <url>/2023/11/06/ComputerSysMind/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统-基础-思维导图"><a href="#操作系统-基础-思维导图" class="headerlink" title="操作系统-基础-思维导图"></a>操作系统-基础-思维导图</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys1.png"></p><h2 id="计组复习"><a href="#计组复习" class="headerlink" title="计组复习"></a>计组复习</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys2.png"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys3.png"></p><h2 id="进程线程管理"><a href="#进程线程管理" class="headerlink" title="进程线程管理"></a>进程线程管理</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys4.png"></p><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys5.png"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys6.png"></p><h2 id="文件管理-Linux"><a href="#文件管理-Linux" class="headerlink" title="文件管理-Linux"></a>文件管理-Linux</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys7.png"></p><h2 id="IO设备管理"><a href="#IO设备管理" class="headerlink" title="IO设备管理"></a>IO设备管理</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys8.png"></p><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterSysMind/CompSys9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 思维导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网 - 计算机网络复习思维导图</title>
      <link href="/2023/11/06/ComputerNetMind/"/>
      <url>/2023/11/06/ComputerNetMind/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="计算机网络-中间三层协议-思维导图"><a href="#计算机网络-中间三层协议-思维导图" class="headerlink" title="计算机网络-中间三层协议-思维导图"></a>计算机网络-中间三层协议-思维导图</h1><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_0.png"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_1.png"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_2.png"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_3.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/imgs/$%7Bfiilename%7D/CompterNetMind/CompNet_4.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>计算机网络第七版- 谢希仁</li><li><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&vd_source=e249eb5e70a068ab71d1537db21d292b">https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e249eb5e70a068ab71d1537db21d292b</a></li><li><a href="https://xiaolincoding.com/network/5_learn/learn_network.html">https://xiaolincoding.com/network/5_learn/learn_network.html</a></li><li>网络是怎样连接的 - 户根勤</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 思维导图 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
