<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络是怎样连接的</title>
      <link href="/project/2023/06/29/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/"/>
      <url>/project/2023/06/29/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h1><h2 id="1-探索浏览器内容"><a href="#1-探索浏览器内容" class="headerlink" title="1.探索浏览器内容"></a>1.探索浏览器内容</h2><h3 id="1-1生成HTTP请求消息"><a href="#1-1生成HTTP请求消息" class="headerlink" title="1.1生成HTTP请求消息"></a>1.1生成HTTP请求消息</h3><p>URL(uniform resource locator)统一资源定位符<br>FTP (file transfer protocol)文件传送协议<br>HTTP(hypertext transfor protocol) 超文本传送协议<br>TCP（transmission control protocol）传输控制协议<br>UDP（user datagram protocol）用户数据报协议<br>IP（internet protocol）网络互联协议</p><p>浏览器是综合性的客户端软件，需要不同的URL来判断使用哪个功能<br>URL开头部分指明了访问方法(协议)；</p><h4 id="HTTP定义了客户端与服务器之间交互的消息内容和步骤："><a href="#HTTP定义了客户端与服务器之间交互的消息内容和步骤：" class="headerlink" title="HTTP定义了客户端与服务器之间交互的消息内容和步骤："></a>HTTP定义了客户端与服务器之间交互的<strong>消息内容</strong>和<strong>步骤</strong>：</h4><p>内容包括：<br>URI(identifier)：存放网页数据的文件名或者CGI程序的文件名<br>其中CGI(common gateway iterface)通用网关接口 ：web服务器调用其他程序的规则<br>方法：<br>GET POST HEAD OPTIONS PUT DELETE TRACE CONNECT</p><p>Web服务器对其中内容进行解析，完成工作后，结果存放在响应消息中，包括状态码、头字段、网页数据</p><h3 id="1-2向DNS服务器查询Web服务器的IP地址"><a href="#1-2向DNS服务器查询Web服务器的IP地址" class="headerlink" title="1.2向DNS服务器查询Web服务器的IP地址"></a>1.2向DNS服务器查询Web服务器的IP地址</h3><p>TCP&#x2F;IP结构 用集线器链接的计算机形成子网，通过路由器连接成一个大的网络；<br>数据以包的形式传送；</p><p>IP地址： 网络号和主机号；共32位，8比特为一组，十进制表示，圆点隔开；<br>子网掩盖码：写在IP地址右侧，表示IP地址的结构，也可以用网络号的位数表示‘</p><p>DNS(dommain name system)域名服务器系统：用于为各种信息关联相应的名称；<br>DNS解析器用于域名解析，包含在 操作系统的Socket库（操作系统中用于调用网络功能的程序组件几何）中；</p><h3 id="1-3DNS服务器大接力"><a href="#1-3DNS服务器大接力" class="headerlink" title="1.3DNS服务器大接力"></a>1.3DNS服务器大接力</h3><p>控制流程转移；web浏览器——》Socket向DNS查询IP地址——》操作系统内部协议栈；</p><p>DNS接受客户端的查询信息：域名  、Class 、记录类型（A表示IP地址，MX表示邮件服务器）；</p><h4 id="域名层次结构："><a href="#域名层次结构：" class="headerlink" title="域名层次结构："></a>域名层次结构：</h4><ol><li>内部网络服务器数量有限的情况下，可以都保存在一台DNS服务器中；</li><li>多台DNS服务器接力,分层次从后往前缩小，最下层的www为服务器名<br>com的上一层为根域，写法可以省略，根域的IP地址只有13个且不变，一般已经配置在DNS服务器程序中了</li></ol><h4 id="客户端查询过程："><a href="#客户端查询过程：" class="headerlink" title="客户端查询过程："></a>客户端查询过程：</h4><p>最近的DNS服务器——》没有则从根目录自顶向下查找；<br>如果有域名缓存，可以从缓存位置向下查找；</p><p>缓存：使用过的数据存放在离使用该数据较近的高速存储装置中，以提高后续访问速度</p><h4 id="收发数据的操作："><a href="#收发数据的操作：" class="headerlink" title="收发数据的操作："></a>收发数据的操作：</h4><ul><li>1.创建套接字（调用socket）、2.接管道连接到服务器端的套接字上、3.收发数据、4.断开管道并删除套接字；</li></ul><ol><li>创建套接字完成后系统返回 <strong>描述符</strong>，应用程序通过描述符来识别套接字；</li><li>connect连接用到：描述符（应用程序用来识别套接字的机制）、服务器IP地址、端口号（这两个是服务器和客户端实现互相识别对方套接字的机制）</li><li>write和read：接收缓存区</li><li>close：客户端和服务器一端先断开，然后断开操作传到另一端</li></ol><h2 id="2-用电信号传输TCP-x2F-IP数据——协议栈和网卡"><a href="#2-用电信号传输TCP-x2F-IP数据——协议栈和网卡" class="headerlink" title="2.用电信号传输TCP&#x2F;IP数据——协议栈和网卡"></a>2.用电信号传输TCP&#x2F;IP数据——协议栈和网卡</h2><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220908192019506.png" alt="image-20220908192019506"></p><h3 id="2-1创建套接字"><a href="#2-1创建套接字" class="headerlink" title="2.1创建套接字"></a>2.1创建套接字</h3><p>应用程序——Socket库和解析器——<em>操作系统中的TCP、UDP、IP</em>——网卡驱动程序——硬件网卡</p><p>浏览器、邮件等一般应用程序收发数据时用TCP，DNS查询等收发较短的控制数据时用UDP；<br>网络包：网络中数据的小包（几十到几千字节）；<br>IP协议将网络包发送给通信对象</p><p>套接字作用：记录了用于控制通信操作的各种控制信息，协议栈根据这些信息判断下一步的行动；<br>processID：操作系统为了标识应用程序分配的编号；</p><p>应用程序调用socket创建套接字，协议栈首先分配内存空间，然后写入初始状态，返回描述符给应用程序</p><h3 id="2-2连接服务器"><a href="#2-2连接服务器" class="headerlink" title="2.2连接服务器"></a>2.2连接服务器</h3><p>TCP头部大概有<strong>双方的端口号、初始序号、窗口大小、ACK号、校验、头部长度、控制位</strong>等信息</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220908193526768.png" alt="image-20220908193526768"></p><p>连接：通信双方交换控制信息，在套接字中记录这些信息并准备数据收发的一连串操作；<br>控制信息：头部中记录的信息和套接字中记录的信息<br>A发送SYN为1的TCP包、创建数据的初始序号、需要的窗口大小——》B返回SYN为1的TCP包、初始序号、窗口大小、返回收到包的ACK号——》B返回收到的ACK号</p><p>TCP模块创建连接控制信息的头部——》找到套接字——》修改状态为正在连接</p><h3 id="2-3收发数据"><a href="#2-3收发数据" class="headerlink" title="2.3收发数据"></a>2.3收发数据</h3><p>应用程序调用write将数据交给给协议栈，协议栈执行发送操作；</p><ul><li>积累多少数据发送出去判断标准:<strong>1,MTU 2,时间</strong><br>MTU（maximum transmission unit）最大传输单元：每个<strong>网络包</strong>所能容纳的最大长度；一般是1500字节<br>MSS（maximum segment size）最大分段大小：MTU减去头部的长度；也就是实际缓冲区能放的数据量<br>时间主要是看频率，协议栈内部有一个计时器；</li></ul><ol><li>以上两个要素时矛盾的，需要综合考虑，可以指定直接发送</li><li>数据块较大的需要按照MSS拆分</li></ol><ul><li><p>序号和ACK号使用方法——<strong>确认对方是否收到网络包</strong>：<br>连接时将SYN设置为1，并告知初始序号；<br>计算数据长度后发送ACK号，并设置比特为1，表示ACK号有效<br>在返回ACK号确认之前，包都保存在缓冲区，可以重写发送</p></li><li><p>客户端和服务器端双向传输过程</p></li><li><p>网络的错误检测和补偿机制非常复杂；</p></li><li><ol><li>按照ACK返回时间动态调整等待时间；</li><li>滑动窗口管理ACK：接收方通过TCP头部的窗口字段将缓冲区余量告知发送方；发送方在等待ACK返回时继续发送下一个包，但需要在缓冲区余量内。<br>最大数据量称为<strong>窗口大小</strong>：一般就是接收方缓冲区的大小</li><li>ACK和窗口合并，多个ACK时只需要发最后一个以告知接收数据的最后位置——都是为了减少包</li></ol></li><li><p><strong>协议栈接受数据的基本操作</strong>：检查收到的数据库和TCP头部，没有数据确实则返回ACK，将数据放在缓存区，数据拼接为原始数据并交给应用程序（复制到程序的内存空间），最后向发送方发送窗口更新</p></li></ul><h3 id="2-4-服务器断开并删除套接字"><a href="#2-4-服务器断开并删除套接字" class="headerlink" title="2.4 服务器断开并删除套接字"></a>2.4 服务器断开并删除套接字</h3><p>例子：服务器端调用Socket库中close程序，协议栈生成包含断开的TCP头部（控制为<strong>FIN设为1</strong>），委托IP模块向客户端发送数据，同时服务端套接字记入断开信息；客户端收到收到TCP头部，协议栈将套接字进入断开状态，并返回给服务器端<strong>ACK号</strong>；协议栈就可以等应用程序取数据了。应用程序read数据，这是协议栈告知应用程序数据收到完成。客户端应用close关闭生成<strong>FIN为1</strong>发送为服务端，服务端<strong>返回ACK</strong>，通信结束。</p><ul><li>删除套接字：需要等待时间以方便重新发送FIN</li></ul><p>总结TCP整体流程：</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220908104715535.png" alt="总结TCP整体流程"></p><h3 id="2-5-IP和以太网的包收发操作"><a href="#2-5-IP和以太网的包收发操作" class="headerlink" title="2.5 IP和以太网的包收发操作"></a>2.5 IP和以太网的包收发操作</h3><p>mac头部——集线器——子网中的以太网协议（可以更换成其他网络如无线局域网）<br><strong>凡是局域网使用的头部豆角MAC头</strong></p><p>IP头部——IP协议——路由器</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220908193611154.png" alt="image-20220908193611154"></p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220908193629305.png" alt="image-20220908193629305"></p><h4 id="包收发操作"><a href="#包收发操作" class="headerlink" title="包收发操作"></a>包收发操作</h4><ol><li>IP模块（包传输过程的入口）：TCP模块委托IP模块发送包，即加上IP头，MAC头，包就封装好了；</li><li>封装好的包交给硬件网卡，将数字信息转换为光电信息，通过集线器、路由器等传递到接收方；</li><li>接收方拿到后做出相应，返回的包被转换为数字信息，加上TCP头部</li></ol><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220908145444278.png" alt="image-20220908145444278"></p><p>Gateway网关：在TCP&#x2F;IP中指的是路由器；<br>通过路由表来匹配该把包发给哪个网卡的IP地址；</p><h4 id="以太网内MAC地址查询："><a href="#以太网内MAC地址查询：" class="headerlink" title="以太网内MAC地址查询："></a>以太网内MAC地址查询：</h4><p>ARP（address resolution protocol）地址解析协议：一种地址广播的方法，能返回子网内相应IP地址的MAC地址；</p><p>MAC地址长度为48比特，IP地址长度32比特，也就是6部分，一字节一部分，用-或者：分开，十进制和十六进制表示；<br>media access control</p><p>目前常用的是交换式集线器：信号会更具MAC地址流到指定的设备</p><ul><li><p>以太网特性：</p><ol><li>将包发送到MAC头的接收方MAC地址所代表的的目的地；</li><li>用发送方的MAC地址识别发送方；</li><li>用以太类型识别包类型</li></ol><p>说明：无线局域网也有1和2的特点，所以用来替代以太网</p></li></ul><h4 id="网卡将IP包转化成光电信号（没看）"><a href="#网卡将IP包转化成光电信号（没看）" class="headerlink" title="网卡将IP包转化成光电信号（没看）"></a>网卡将IP包转化成光电信号（没看）</h4><p>网卡中的ROM保存唯一的MAC地址，生产时就写入的，网卡驱动初始化后生效；</p><p>返回接收包：对应MAC地址的包放入缓存区——》产生中断信号，中断控制器，CPU暂时挂起切换到中断程序——》调用网卡驱动执行操作<br>——》从缓冲区中取出包，通过MAC头部中以太类型判断包类型（协议类型）</p><p>接收——》检查IP头部——》如果不一致，返回错误ICMP（查表）</p><h3 id="2-6UDP协议的收发操作"><a href="#2-6UDP协议的收发操作" class="headerlink" title="2.6UDP协议的收发操作"></a>2.6UDP协议的收发操作</h3><p>TCP复杂是为了实现高效和可靠：缺失部分包的时候只需要发送出错的部分，避免了重发已经送达的包；<strong>（数组在多个包的情况）</strong></p><p>UDP没有连接和断开阶段，只要加上UDP头部，交给IP发送就行了；接收按照IP头部和接收方的地址，UDP头部端口号<strong>（在一个包大小范围内解决）</strong></p><ol><li>UDP只负责单纯发送，不会监控，所以协议栈也不知道有没有错误；</li><li>最大数据长度为IP包减去UDP头部</li><li>音频和视频会使用UDP，确实部分包会失真，但是用TCP要额外的几倍带宽</li></ol><h2 id="3-网线到网络设备——集线器、交换机、路由器"><a href="#3-网线到网络设备——集线器、交换机、路由器" class="headerlink" title="3. 网线到网络设备——集线器、交换机、路由器"></a>3. 网线到网络设备——集线器、交换机、路由器</h2><h3 id="3-1信号在网线和集线器中传输"><a href="#3-1信号在网线和集线器中传输" class="headerlink" title="3.1信号在网线和集线器中传输"></a>3.1信号在网线和集线器中传输</h3><p>每个包都是独立传输的；</p><p>传输过程：网卡中PHY（MAU）模块将包转化为电信号——》通过RJ-45进入双绞线——》信号流入网线——》集线器的接口；<br>（传输过程中信号会衰减，波形会失真；用<strong>双绞线</strong>来抑制衰减，阻隔噪声措施等）</p><p>——》集线器将信号发送给所有连接在他上面的线路（<strong>原封不动广播</strong>）</p><h3 id="3-2交换机的包转发"><a href="#3-2交换机的包转发" class="headerlink" title="3.2交换机的包转发"></a>3.2交换机的包转发</h3><p>PHY模块接收网线中信号转化为通用格式——》MAC模块将信号转化为数字信号——》包尾部检查FCS——》没异常所有包放到缓冲区——》查询MAC地址表(MAC地址和端口的对应表)——》将信号发送到相应的端口</p><ul><li>交换机的MAC模块不具有MAC地址</li><li>MAC地址表会自动维护，异常时重启交换机重置地址表就行</li><li>全双工模式是交换机特有，可以同时发送和接收操作</li><li>全&#x2F;半双工切换的问题，自动协商功能</li><li>交换机可以同时执行多个转发操作，转发能力强</li></ul><h3 id="3-3路由器的包转发"><a href="#3-3路由器的包转发" class="headerlink" title="3.3路由器的包转发"></a>3.3路由器的包转发</h3><p>路由器是基于IP设计，交换机是基于以太网设计</p><h4 id="路由器转发包过程："><a href="#路由器转发包过程：" class="headerlink" title="路由器转发包过程："></a>路由器转发包过程：</h4><p>通过委托端口接受包（取决于端口通信技术）——转发模块根据接受包的IP头部中记录接收方IP地址，在路由表中查询——》委托端口模块转发包</p><ul><li>端口模块以实际的接收方&#x2F;发送方的身份来收发网络包</li><li>路由器的以太网端口<strong>有MAC地址</strong>，路由器的IP端口<strong>有IP地址</strong></li><li>路由器的子网掩盖码值表示在匹配网络包目标地址时需要对比的比特数，有可能路由聚合合并为一个子网</li></ul><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220909144520902.png" alt="image-20220909144520902"></p><h5 id="a-路由器接受包"><a href="#a-路由器接受包" class="headerlink" title="a. 路由器接受包"></a>a. 路由器接受包</h5><ol><li>转化为数字信息，检查MAC地址是否匹配；</li><li>接受操作后包的MAC头部被丢弃（<strong>MAC头部的作用就是将包传递到路由器</strong>）</li></ol><h5 id="b-查询路由表确定输出端口"><a href="#b-查询路由表确定输出端口" class="headerlink" title="b.查询路由表确定输出端口"></a>b.查询路由表确定输出端口</h5><ol><li>按照IP头部转发，子网掩码配合IP地址，确定候选转发目标</li><li>最长匹配原则</li></ol><h5 id="c-找不到匹配路由时选择默认路由"><a href="#c-找不到匹配路由时选择默认路由" class="headerlink" title="c.找不到匹配路由时选择默认路由"></a>c.找不到匹配路由时选择默认路由</h5><ol><li>子网掩码<strong>0.0.0.0</strong>，不需要匹配，默认路由，这样配置的网关地址被称为<strong>默认网关</strong></li><li>在找不到其他匹配路由，选择默认路由</li></ol><h5 id="d-路由器相关工作"><a href="#d-路由器相关工作" class="headerlink" title="d.路由器相关工作"></a>d.路由器相关工作</h5><ul><li><p>TTL：在IP头部，表示保底有效期，经过一个路由器减1,为0就是超过有效期。<br>一般设置为64&#x2F;128，防止信息错误或者路由混乱</p></li><li><p>分片功能拆分大网络包:<br>原因：不同类型线路传输的最大包长度不同；<br>操作：用IP协议中定义的分片功能，对整个包拆分<br>前提：检查MTU，检查IP头部标志字段是否能拆</p></li></ul><blockquote><p>不同于TCP拆分，TCP是在数据拆好后放到包中，也就是一个数据块刚好是包的大小</p></blockquote><h5 id="f-路由器的发送操作"><a href="#f-路由器的发送操作" class="headerlink" title="f.路由器的发送操作"></a>f.路由器的发送操作</h5><p>判断下一个转发目标：<br>    如果网关列表内容为IP地址，该地址为下一个转发目标；<br>    网关列表为空，则IP头部中的接收方IP地址为下一个转发目标；<br>路由器也会用ARP查询下一个转发目标的MAC地址；         </p><h4 id="路由器和交换机"><a href="#路由器和交换机" class="headerlink" title="路由器和交换机"></a>路由器和交换机</h4><p>所说的加上MAC头，实际是上将IP包装进以太网包的数据部分，委托以太网传输数据，i.e. 路由器把包的传输工作委托给交换机；</p><p><strong>IP（路由器）负责将包发送给通信对象整个过程；</strong></p><p><strong>以太网（交换机）将包传输到下一个路由器；</strong></p><h3 id="3-4-路由器的附加功能"><a href="#3-4-路由器的附加功能" class="headerlink" title="3.4 路由器的附加功能"></a>3.4 路由器的附加功能</h3><p>为了解决地址不足分为<strong>私有地址(golbally unique address)，公有地址(public address)</strong></p><p>私有地址是公有地址还没有分配的范围</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220909172640673.png" alt="image-20220909172640673"></p><p>但是公司内部的私有地址不能和互联网直接进行通信，需要通过地址转换机制</p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>地址转换设备（路由器）</p><p>改写端口号，提高公有地址的利用率</p><h2 id="4-接入网和网络运营商"><a href="#4-接入网和网络运营商" class="headerlink" title="4.接入网和网络运营商"></a>4.接入网和网络运营商</h2><h3 id="4-1-ADSL接入网的结构和工作方式"><a href="#4-1-ADSL接入网的结构和工作方式" class="headerlink" title="4.1 ADSL接入网的结构和工作方式"></a>4.1 ADSL接入网的结构和工作方式</h3><p>互联网上万台路由器，按照接收方IP地址判断，将包转发出去；<br><strong>距离的不同和路由的维护方式</strong>不同，就是互联网与家庭、公司网络之间最初主要的两个不同点；</p><p>接入网：连接互联网与家庭、公司网络的通信线路（ADSL、FTTH、CATV、电话线、ISDN等）；<br>ADSL（asymmetric digital subscriber line）不对称数字用户线</p><p>ADSL modem 调制解调器：将包拆分成信元，并且转化为电信号发送给分离器</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911135603820.png" alt="image-20220911135603820"></p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911140104023.png" alt="image-20220911140104023"></p><p>BAS（broadband access server）宽带接入服务器 ，一种<strong>路由器</strong>（不同与普通，具有身份认证，向客户端下发IP地址等配置信息的功能）：1.用户认证的窗口，2.隧道方式传输网络包</p><p>PPP （point to point protocol）点到点协议。电话线、ISDN等通信路线所用的一种协议</p><p>ATM （asynchronous transfer mode）异步传输 ，电话线为载体的通信方式，以“信元”为单位进行。</p><p>FTTH （Fibre (Fiber) To The Home）基于光线的接入网技术：用光纤代替ADSL将用户端接入路由器和运营商的BAS连接起来的接入方式</p><h4 id="分离器的作用"><a href="#分离器的作用" class="headerlink" title="分离器的作用"></a>分离器的作用</h4><p>ADSL modem将信元转化为电信号后，通过分离器，但没作用；（电话和ADSL信号同时流入线路）<br>信号从电话线传入时，分离电话和ADSL信号，防止ADSL成为电话的噪音：<br>        对于电话：分离器过滤掉高频的ADSL；<br>        对ADSL：ADSL modem内部就有信号过滤功能；<br>分离器也可以房子电话对ADSL传输方式的干扰</p><p>分离器——》电话线——》总配线架——》电话局——》DSLAM（转回数字信号 信元）——》BAS（将ATM信元转化为原始的包）</p><h3 id="4-2光纤接入网"><a href="#4-2光纤接入网" class="headerlink" title="4.2光纤接入网"></a>4.2光纤接入网</h3><p>光线的工作原理。。</p><h4 id="FTTH技术"><a href="#FTTH技术" class="headerlink" title="FTTH技术"></a>FTTH技术</h4><ol><li>直连：一种是光纤直接从用户端连接到最近的电话局：以太信号——》光信号——》DSLAM——》BAS转化为电信号，将包转发到互联网内部——》到达互联网后，服务器响应——》响应包的光信号沿着光纤返回</li></ol><p>​光线中波分复用，区别上行和下行信号</p><ol start="2"><li>分路：分光器设备，让光纤分录，同时连接多个用户：OLT和ONU避免碰撞；</li></ol><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911154100876.png" alt="image-20220911154100876"></p><h3 id="4-3接入网中使用的PPP和隧道"><a href="#4-3接入网中使用的PPP和隧道" class="headerlink" title="4.3接入网中使用的PPP和隧道"></a>4.3接入网中使用的PPP和隧道</h3><p>PPPoE（Point to Point Protocol  over Ethernet）以太网的点对点协议：将PPP消息装入以太网包进行传输的方式；</p><p>包原封不动的搬运到另一端，原理上就可以看成建立隧道；</p><p>互联网接入路由器通过PPPoE的发现机制查询BAS的MAC地址（相当于拨号上网中拨号）</p><ul><li>地址转换：是否BAS向计算机下发了TCP&#x2F;IP配置，没下发需要在路由器中转化为公有地址</li></ul><h3 id="4-4网络运营商的内部"><a href="#4-4网络运营商的内部" class="headerlink" title="4.4网络运营商的内部"></a>4.4网络运营商的内部</h3><p>POP(Point of Presense)接入点：ADSL、FTTH等接入网的连接点，互联网的入口在这里</p><p>NOC（Network Operation Center）网络运行中心，（扩大版、高性能的POP）</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911155250806.png" alt="image-20220911155250806"></p><p>按照不同类型的接入网分别使用不同类型的路由器</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911160108080.png" alt="image-20220911160108080"></p><h3 id="4-5跨越运营商的网络包"><a href="#4-5跨越运营商的网络包" class="headerlink" title="4.5跨越运营商的网络包"></a>4.5跨越运营商的网络包</h3><p>BGP（border gateway protocol） 边界网关协议：路由信息交换的过程；</p><p>运营商之间所有路由器平等交换，多路判断优先级，收费；</p><p>IX(internet eXchange)互联网交换中心：将运营商汇聚在一起，设置中信设备，减少线路数量；具有高速以太网端口的二层交换机</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911162156742.png" alt="image-20220911162156742"></p><h2 id="5-服务器端的局域网"><a href="#5-服务器端的局域网" class="headerlink" title="5.服务器端的局域网"></a>5.服务器端的局域网</h2><p>在服务器前部署一个防火墙：只允许发往特定服务器中的特定应用程序的包通过，屏蔽其他的包；常用的是包过滤方式</p><h4 id="5-1-包过滤方式（主流防火墙方式）"><a href="#5-1-包过滤方式（主流防火墙方式）" class="headerlink" title="5.1 包过滤方式（主流防火墙方式）"></a>5.1 包过滤方式（主流防火墙方式）</h4><ul><li>设置允许通过的<strong>接收方IP和发送方IP</strong>（注意应答机制，要回复ACK）</li><li>设置端口号限定应用程序，<strong>接收方端口号、发送方端口号</strong></li><li><strong>控制位</strong>判断连接方向（TCP头部的控制位；但是对UDP没有控制位可以设置只能公司内网访问DNS服务器，牺牲便利性）</li><li>对具体数据不能识别风险：一种是持续关注安全漏洞信息并更新软件的版本；一种是在防火墙之外部署用来检查包内容并阻止有害包的设备或软件。</li></ul><p>内网访问公开区域</p><p>外部互联网访问公司内网，默认不能访问，内网到外网的话需要地址转化</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911171030839.png" alt="image-20220911171030839"></p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220911171046135.png" alt="image-20220911171046135"></p><h4 id="5-2-通过将请求平均分配给多台服务器来平衡负载"><a href="#5-2-通过将请求平均分配给多台服务器来平衡负载" class="headerlink" title="5.2 通过将请求平均分配给多台服务器来平衡负载"></a>5.2 通过将请求平均分配给多台服务器来平衡负载</h4><p>服务器的访问量上升，需要增加带宽和提高服务器性能；<br>提高服务器性能可以使用多台服务器来分担负载的方法——分布式架构；<br>采用多台Web服务器，减少每台服务器的访问量；<br>用DNS按顺序循环分配多台不同的IP地址——轮询；</p><p>问题：1. 一台宕机了咋办——访问返回失败，尝试下一个IP<br>            2. 有些操作跨多个页面，访问服务器变化则操作无法继续</p><h5 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h5><p>用其IP地址代替Web服务器的实际地址注册到DNS服务器上；</p><p>操作跨多个页面时，请求发送到同一个Web服务器——》判断请求之间的相关性，在HTTP头部加入Cookie<br>其他情况需要定期采集Web服务器的CPU、内存使用率</p><h5 id="缓存服务器"><a href="#缓存服务器" class="headerlink" title="缓存服务器"></a>缓存服务器</h5><p>服务器按照功能划分不同服务器，缓存服务器是一台通过代理机制对数据进行缓存的服务器；<br>代理在Web服务器和客户端之间，Web服务器返回的数据保存在此版中（<strong>缓存</strong>）</p><p>缓存服务器注册到DNS服务器中</p><p>Via: 表示缓存服务器中专的</p><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p>缓存服务器在客户端一侧部署；用作转发过程判断是否允许访问、用作防火墙的实现；</p><ul><li><p>设置时，需要在浏览器的设置窗口的代理服务器中填写正向代理的IP地址</p></li><li><p>有代理时，客户端发送给缓存服务器的请求头不需要直接填写http:&#x2F;&#x2F;这样的完整网址</p></li></ul><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p>服务器端的缓存服务器，将请求消息中URI的吗，目录名与Web服务器进行关联，能转发不带完整网址的请求</p><h5 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h5><p>用包的IP头部中接收方的Ip地址判断访问服务器；</p><p>在消息经过时拦截</p><h3 id="5-3-内容分发服务"><a href="#5-3-内容分发服务" class="headerlink" title="5.3 内容分发服务"></a>5.3 内容分发服务</h3><p>缓存服务器放在客户端——降低Web服务器的负载——无法减少互联网的网络流量</p><p>缓存服务器放在Web服务器端——Web服务器无法控制——减少网络流量</p><p>缓存服务器放在互联网的边缘（集合优点，但是互联网都可以访问，部署数量需求多）——服务器运营者能控制——降低网络流量</p><p>内容分发服务：CDN(content delivery network) 或者叫CDS(system)<br>内容分发服务运营商：CDSP(provider)</p><p>提前查询路由器到各个缓存服务器的之间的距离，判断最近的</p><h2 id="6-请求到达服务器，响应返回浏览器"><a href="#6-请求到达服务器，响应返回浏览器" class="headerlink" title="6.请求到达服务器，响应返回浏览器"></a>6.请求到达服务器，响应返回浏览器</h2><h3 id="6-1服务器的基本信息"><a href="#6-1服务器的基本信息" class="headerlink" title="6.1服务器的基本信息"></a>6.1服务器的基本信息</h3><p>服务器和客户端的协议栈、网卡、Socket库（调用其中的程序组件不一致）等功能一致，TCP&#x2F;IP的功能统一，客户端计算机也可以用作服务器；</p><h5 id="服务器程序"><a href="#服务器程序" class="headerlink" title="服务器程序"></a>服务器程序</h5><p>客户端通信模块一般是与客户端一对一的关系；<br>服务器操作系统具有多任务、多线程功能，同时运行多个程序；<br>：任务作为单个程序，线程是程序的一个部分</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220912222625199.png" alt="image-20220912222625199"></p><p>服务器在调用Socket库上的区别在连接阶段：<br>客户端：用管道连接服务器端的套接字<br>服务器端：1.将套接字设置为等待连接的状态 2. 接受连接</p><p>套接字的确定：客户端IP地址、客户端端口号、服务器IP地址、服务器端口号；</p><p>使用描述符来指代套接字的原因：等待连接的套接字中没有客户端IP地址和端口号、使用描述符比较简单</p><h3 id="6-2-服务器接收操作"><a href="#6-2-服务器接收操作" class="headerlink" title="6.2 服务器接收操作"></a>6.2 服务器接收操作</h3><h5 id="服务器接收操作的全过程回顾"><a href="#服务器接收操作的全过程回顾" class="headerlink" title="服务器接收操作的全过程回顾"></a>服务器接收操作的全过程回顾</h5><blockquote><p>网卡（硬件）接收信号，转化为数字信号——》按照包尾部的帧校验符FCS来校验错误——》MAC头部检查接收方的MAC地址——》保存在网卡的缓冲区中</p></blockquote><ul><li>网卡的MAC模块将网络包从信号还原为数字信息，校验FCS并且存入缓冲区</li></ul><blockquote><p>——》CPU处理中断，网卡驱动运行，读取缓冲区的包——》根据MAC头部的以太类型判断协议种类——》调用负责处理该协议的程序（也就是TCP&#x2F;IP协议栈）</p></blockquote><ul><li>网卡驱动按照MAC头部判断协议类型，并且发送个相应的协议栈</li></ul><blockquote><p>——》达到协议栈后，IP模块检查IP头部中接收方IP地址，判断转发——》检查IP头部知道是否分片，如果分片了，现存在内存里，等组装充足后还原为原始包——》检查IP头部的协议号，06则为TCP模块，11为UDP模块</p></blockquote><ul><li>协议栈的IP模块检查IP头部，判断是不是发给自己的，网络包有没有呗切片，对应转发协议栈是TCP还是UDP</li></ul><blockquote><p> ——》TCP模块按照包的内容区别，如果是SYN为1发起连接的包——》检查包的接收方端口号有没有等待连接的套接字——》无则返回ICMP消息，有则创建套接字副本，信息写入套接字生成ACK号，生产TCP头部，委托IP模块发送给客户端——》客户端返回ACK号确认，连接完成——》服务器端及进入调用accept的暂停状态，当将新套接字的描述符转交服务器程序后，服务器恢复运行</p></blockquote><ul><li>TCP模块：根据收到包的发送方&#x2F;接收方的IP地址&#x2F;端口号找到对应的套接字；将数据拼接放在缓冲区；向客户端返回ACK号</li></ul><blockquote><p>——》服务器或者客户端发起，调用Socket库中close，TCP模块生成控制位FIN为1,发送——》客户端或服务器返回一个ACK号，生成FIN为1的TCP头部发送——》服务器或客户端返回ACK号完成</p></blockquote><ul><li>HTTP1.1中，客户端先发起断开；断开操作后，套接字过一段时间被删除</li></ul><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220913140803131.png" alt="image-20220913140803131"></p><h3 id="6-3-Web服务程序解释请求消息并做出相应"><a href="#6-3-Web服务程序解释请求消息并做出相应" class="headerlink" title="6.3 Web服务程序解释请求消息并做出相应"></a>6.3 Web服务程序解释请求消息并做出相应</h3><p>最简单的是按照请求方法+URI的HTML文件名获取</p><p>判断访问权限依据：客户端IP地址；客户端域名；用户名和密码</p><h3 id="6-4-浏览器接受响应消息并显示内容"><a href="#6-4-浏览器接受响应消息并显示内容" class="headerlink" title="6.4 浏览器接受响应消息并显示内容"></a>6.4 浏览器接受响应消息并显示内容</h3><p>按照Content-Type判断数据类型</p><p><img src="C:\Users\klChen\AppData\Roaming\Typora\typora-user-images\image-20220913142737133.png" alt="image-20220913142737133"></p><p>charset&#x3D;urf-8表示文本编码方式</p><p>Content-Encoding表示压缩格式的具体转换方式</p><p>实际显示是浏览器负责对操作系统发出指令显示的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed_System</title>
      <link href="/project/2023/06/27/MIT6.824%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/project/2023/06/27/MIT6.824%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT6-824课程笔记"><a href="#MIT6-824课程笔记" class="headerlink" title="MIT6.824课程笔记"></a>MIT6.824课程笔记</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>分布式：通过网络来协调，协同完成一致任务的一些计算机。</p><p>分布式系统<br>一组不共享内存和时钟处理器的集合。每个处理器都有自己的内存，之间通过各种通信网络加以实现。处理器大小和和功能不同，其中，某个站点表示特定的主机，服务器，拥有客户机所需的资源。</p><h3 id="建立分布式的原因"><a href="#建立分布式的原因" class="headerlink" title="建立分布式的原因"></a>建立分布式的原因</h3><ol><li>加快计算速度：将特定的计算分化成可以并发运行的子运算，分布式系统允许将这些子运算分不到不同的站点，就可以并发的进行。此外啊，还可以进行负载分配。（大量的计算机意味着）大量的并行运算，大量CPU、大量内存、以及大量磁盘在并行的运行</li><li>可靠性（提供容错）：如果系统具有足够的冗余（包括硬件和数据），即使某些站点出现故障，系统也会继续运行下去。1. 分布式系统必须保证能检测到站点故障，不再使用该站点的服务，并采取适当措施修复；2. 如果有其他站点可以接管，系统必须保证操作转移的正确；3. 故障的站点恢复后，系统保证有一个顺利结合到系统的机制；</li><li>一些问题天然在空间上是分布的。例如银行转账，我们假设银行A在纽约有一台服务器，银行B在伦敦有一台服务器，这就需要一种两者之间协调的方法。所以，有一些天然的原因导致系统是物理分布的。</li><li>安全，通过隔离提高安全性。比如一些代码不被信任但需要交互，可以将代码分散多出运行，系统分成多个计算机，这样可以限制出错域。</li></ol><h3 id="分布式难点："><a href="#分布式难点：" class="headerlink" title="分布式难点："></a>分布式难点：</h3><ol><li>并发编程</li><li>复杂交互，时间依赖（同步、异步）</li><li>局部错误很难调试</li><li>很难获得高性能</li></ol><h3 id="基础架构：-存储-通信-计算"><a href="#基础架构：-存储-通信-计算" class="headerlink" title="基础架构： 存储 通信 计算"></a>基础架构： 存储 通信 计算</h3><p>存储是最重要，构建一种多副本、容错的、高性能分布式存储实现；</p><p>存储和计算，目的是实现简单剪口，像非分布式存储和计算系统一样被第三方应用，但是实际上又是一个有极高的性能和容错的分布式系统。</p><p><strong>构建用到的工具：</strong></p><p>RPC（Remote Procedure Call）。RPC的目标就是掩盖我们正在不可靠网络上通信的事实。一种分布式系统中的通信方式，可以使得不同的计算机程序之间可以像本地程序一样进行相互调用，从而方便构建分布式系统。通过RPC技术，可以帮助实现以下功能 ：</p><ol><li>分布式服务调用：各个计算机之间可以调用对方提供的服务，从而实现分布式系统中的协同工作。</li><li>负载均衡：可以将请求分配到多个服务器上，从而实现负载均衡，提高系统的可靠性和可用性。</li><li>高并发处理：，可以实现多个请求的并发处理，提高系统的响应速度。</li><li>数据共享：可以将数据共享到多个计算机之间，从而实现数据共享和协同处理。</li></ol><p>多线程编程技术</p><p>考虑控制并发、锁</p><h3 id="拓展性Sacalability"><a href="#拓展性Sacalability" class="headerlink" title="拓展性Sacalability"></a>拓展性Sacalability</h3><p>如果我用一台计算机解决了一些问题，当我买了第二台计算机，我只需要一半的时间就可以解决这些问题，或者说每分钟可以解决两倍数量的问题。两台计算机构成的系统如果有两倍性能或者吞吐，就是我说的可扩展性。</p><p>通过增加机器的方式来实现扩展，但是现实中这很难实现，需要一些架构设计来将这个可扩展性无限推进下去。</p><p>比如说并发量上去了，那需要增加服务器数量，这导致数据库成为瓶颈，又需要搭建分布式存储：<br>        也就是web服务器和数据库的成为瓶颈时，都能突破，拓展下去。</p><h3 id="可用-容错性Avaliability"><a href="#可用-容错性Avaliability" class="headerlink" title="可用 | 容错性Avaliability"></a>可用 | 容错性Avaliability</h3><p>可用性（Availability）: 这样在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。</p><p>大型分布式系统中有一个大问题，那就是一些很罕见的问题会被放大,各个地方总是有一些小问题出现。所以大规模系统会将一些几乎不可能并且你不需要考虑的问题，变成一个持续不断的问题。</p><p>自我可恢复性（recoverability）: 如果出现了问题，服务会停止工作(通常需要做一些操作，例如将最新的数据存放在磁盘中),不再响应请求，之后有人来修复，并且在修复之后系统仍然可以正常运行，就像没有出现过问题一样</p><p><strong>可用和自我恢复用到的工具</strong></p><p>非易失存储：存放一些checkpoint或者系统状态的log在这些存储中，这样当备用电源恢复或者某人修好了电力供给，我们还是可以从硬盘中读出系统最新的状态，并从那个状态继续运行。但是非易失存储的读写的代价很高，避免频繁读写</p><p>复制：管理多副本实现容错系统</p><h3 id="一致性Consistency"><a href="#一致性Consistency" class="headerlink" title="一致性Consistency"></a>一致性Consistency</h3><p>定义操作行为的概念。因为分布式系统考虑性能和容错，通常会使用多个副本有不同版本的 key-value 。比如在put操作中，有两个服务器，需要发给两个副本以达到同步，但是发送过程中可能客户端故障了，只有一个收到了，数据不一致了。</p><p>弱一致是指，不保证get请求可以得到最近一次完成的put请求写入的值。尽管有很多细节的工作要处理，强一致可以保证get得到的是put写入的最新的数据。所以在一个弱一致系统中，某人通过put请求写入了一个数据，但是你通过get看到的可能仍然是一个旧数据，而这个旧数据可能是很久之前写入的。  但是强一致的开销可能非常大，常常构建弱一致系统，只从最近的数据副本更新和获取数据。</p><h3 id="提高性能-performance"><a href="#提高性能-performance" class="headerlink" title="提高性能 performance"></a>提高性能 performance</h3><ul><li>throughput 吞吐量：目标是吞吐量与部署的机器数成正比</li><li>latency 低延迟：其中一台机器执行慢就会导致整个请求响应慢，这称为<strong>尾部延迟(tail latency)</strong></li></ul><h3 id="MapReduce基本工作方式"><a href="#MapReduce基本工作方式" class="headerlink" title="MapReduce基本工作方式"></a>MapReduce基本工作方式</h3><p>MapReduce的思想是，应用程序设计人员和分布式运算的使用者，只需要写简单的Map函数和Reduce函数，而不需要知道任何有关分布式的事情，MapReduce框架会处理剩下的事情。</p><p> map-reduce经典举例即统计字母出现的次数，多个进程各自通过map函数统计获取到的数据片段的字母的出现次数；后续再通过reduce函数，汇总聚合map阶段下每个进程对各自负责的数据片段统计的字母出现次数。一旦执行了shuffle，多个reduce函数可以各自只聚合一种字母的出现总次数，彼此之间不干扰。</p><p>开销昂贵的部分即shuffle，map的结果经过shuffle按照一定的顺序整理&#x2F;排序，然后才分发给不同的reduce处理。这里shuffle的操作理论比map、reduce昂贵。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>输入一组kv，生成一组kv。</p><p>MAP函数获取一个输入，并且生成一组中间的KV，</p><p>MapReduce库把与同一中间键i相关联的所有中间值组合在一起，通过迭代器传递给Reduce函数。</p><p>Reduce函数接受中间键i和键对应的一组值，把值合在一起，形成一个看更小的值集。一般每次只生成0或1个输出值。</p><img src="D:\MyTxt\typoraPhoto\image-20230329113648794.png" alt="image-20230329113648794" style="zoom:80%;" /><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>输入文件，MapReduce库分割成M个片段，每个片段16-64MB，然后再一群机器上启动程序的副本</li><li>其中一个副本是Master，其余是workers，总共有M个map任务和R个reduce任务需要分配。由主进程挑选空闲的workers分配一项任务。</li><li>分配到map任务的worker读取内容（被拆分好的一部分），从输出数据中解析出KV，传递给Map函数，然后把生成的中间KV存在内存</li><li>定期写入本地磁盘，并分区R个区，然后传地址给master。</li><li>master通知reduce任务的workers这些位置，然后用RPC读取map的workers这些数据（直接从map传到reduce workers？）。当reduceWorker读完所有中间数据后，按照键排序，以便将所有相同键的项组合。（排序是必须的，如果中间数据量大到内存不够了，用外部排序）</li><li>reduceWorker遍历已排序的中间数据，按照键值和对应的一组中间值传递给Reduce函数。reduce函数的结果加到此分区的输出文件中</li><li>所有map和reduce任务完成后，master唤醒user程序。这时user程序中的MapReduce来return结果，一般所有分区输出文件同时输出传递给另一个MapReduce函数，不需要合并为一个文件。</li></ol><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>每个map和reduce任务，保留存储状态（空闲，进行，完成）和工作计算机的标识（非空闲）</p><p>master是map任务中间文件位置的接受管道，master存储R个中间文件的位置和大小，map任务完成后，master接受信息更新，并且递增地传给正在进行的reduceWorkers</p><h3 id="容错性："><a href="#容错性：" class="headerlink" title="容错性："></a>容错性：</h3><h4 id="workers-failure"><a href="#workers-failure" class="headerlink" title="workers failure"></a>workers failure</h4><p>master定期ping每个worker如果有worker没有响应 或者 工作线程故障 。就标记为失败，任务重置为初始空闲状态，可以放在其他works上调度。</p><ol><li><p>对于map任务故障，直接全部重新执行，因为输出存储在故障计算机上，无法访问。</p></li><li><p>对于reduce任务，只要接下来换机器执行，因为输出存储在全局文件系统中。</p></li></ol><p>A执行map任务的时候坏了转给了B，那么对应执行reduce的workers需要重新执行，从B读取数据</p><p>对于故障 需要有很大的弹性。</p><h4 id="master-failure"><a href="#master-failure" class="headerlink" title="master failure"></a>master failure</h4><p>写入master数据结构的检查点，master终止之后，可以从上一个检查点状态重新启动新的副本。</p><p>中止计算，客户端可以检查这种情况，重试</p><h4 id="存在故障的语言（没看懂）"><a href="#存在故障的语言（没看懂）" class="headerlink" title="存在故障的语言（没看懂）"></a>存在故障的语言（没看懂）</h4><p>map和reduce函数确定后，分布式产生的输出与无错误的顺序执行产生的输出相同。</p><p>主要是通过map和reduce输出的原子提交实现这一属性。reduce任务输出文件生成一个，map任务生成R个。map任务完成后，workers向master发送一条消息，包含R个文件名。reduce任务完成后，自动文件重命名为最终输出文件（如果多个worker执行相同的reduce任务，则相同的最终文件多个重命名调用）。</p><p>如果map和reduce运算是确定的，等同顺序执行，比较容易逻辑推理；但是如果存在非确定的运算，在存在非确定性运算符的情况下，特定归约任务R1的输出等同于由非确定性程序的顺序执行产生的R1的输出。然而，不同归约任务R2的输出可以对应于由非确定性程序的不同顺序执行产生的R2的输出。</p><p>举例子：M的一次输出可能被R1读取并正在执行，M的另一次输出可能被R2读取了</p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>如果失败将在输入数据的副本附近调度map任务，大多数是本地读取的，不会消耗带宽</p><h4 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h4><p>任务数量M和R远大于计算机数量（当然有个上限），调整动态负载平衡。 R受到用户限制，一般是机器数量的小倍数</p><p>主机必须做出O(M+R)调度决策并在内存中保持O(M∗R)状态？？？</p><h4 id="任务备份"><a href="#任务备份" class="headerlink" title="任务备份"></a>任务备份</h4><p>问题：有些机器运行落后，最后几个任务要一直等着。</p><p>解决方案： 当一个MapReduce系统快完成的时候，主线程调度正在进行的任务进行备份执行，只要主执行或者备份执行有完成的，那这个任务就被标记完成。这样加了少量计算负担，能提升时间较多</p><h3 id="优化拓展"><a href="#优化拓展" class="headerlink" title="优化拓展"></a>优化拓展</h3><h4 id="分区函数"><a href="#分区函数" class="headerlink" title="分区函数"></a>分区函数</h4><p>用户指定M和R，使用分区函数对数据进行分区。要求平衡的分区，有时候希望相同的输出文件结束。。。</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>保证给定分区中，中间KV按照K升序处理，方便输出文件被查找。</p><h4 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h4><p>中间键有时候有大量重复计算，原本都需要单独发给reduce任务计算，然后合并。</p><p>现在可以在map任务的计算器上指定一个合并函数，执行合并后写入一个中间文件，发给reduce任务。这样可以提高操作速度。</p><p>这种部分合并的combiner函数和reduce函数代码一致（除了输出的位置）。</p><h4 id="输入输出类型"><a href="#输入输出类型" class="headerlink" title="输入输出类型"></a>输入输出类型</h4><p>支持不同格式读取输入数据，读取器不一定需要提供从文件读取的数据</p><h4 id="跳过不良记录"><a href="#跳过不良记录" class="headerlink" title="跳过不良记录"></a>跳过不良记录</h4><p>用户代码的错误导致崩溃，修复错误 忽略(跳过)错误  检测记录确定性崩溃，发送信号给主程序，下次重新执行就能跳过记号</p><p>本地调试</p><p>状态信息：状态页面查看所有任务的进度</p><p>计数器工具：对各种事件记录，在任务函数中调用incre，定期传给master以更新</p><h2 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h2><p>方法是带着接受者参数的函数，接受者需要是包内定义的类型。带指针参数的函数必须接受一个指针，但是以指针为接收者的方法被调用时，接收者既能为值也能为指针。反过来也是对的，接受值参数的函数必须接受值，但是接收者既能为值也能为指针。</p><p>chan ：默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步</p><p>go 函数名(参数列表)</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口：定义为接口后，把其他类型的实例赋值给他，然后可以对应的不同方法，来实现多态</p><p>接口是一种抽象的类型，有点像泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口不关你是什么类型，只要你实现了这个方法</span></span><br><span class="line"><span class="comment">// 定义一个类型，一个抽象的类型，只要实现了say()就可以称为sayer类型</span></span><br><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span>()&#123;</span><br><span class="line">    say(参数) 返回值列表</span><br><span class="line">    say2()</span><br><span class="line">    say3()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义类型，实现了say方法</span></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> say()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;嗷嗷嗷&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口类型的入口，interface作为入参类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">da</span><span class="params">(arg sayer)</span></span>&#123;</span><br><span class="line">    arg.say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c1 := cat&#123;&#125;</span><br><span class="line">    da(c1)</span><br><span class="line">    d1 := dog&#123;&#125;</span><br><span class="line">    da(d1)</span><br><span class="line">    p1 := person&#123;&#125;</span><br><span class="line">    da(p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run mrsequential.go wc.so pg*.tx // 之后的两项是传给mrsequential的命令行参数，分别是一个动态库和所有电子书</span><br><span class="line"></span><br><span class="line">文件wc.go以及mrapps目录下的其它几个文件，都定义了名为map, reduce的函数，这两个函数在mrsequential.go中加载并调用。给mrsequential绑定不同的*.so文件，也就会加载不同的map, reduce函数。如此实现某种程度上的动态绑定。</span><br><span class="line"></span><br><span class="line">我们的代码主要写在src/mr目录下的几个文件，这几个文件由src/main目录下两个文件mrcoordinator.go, mrworker.go调用。这两个文件的作用是启动进程、加载map, reduce动态库，并进入定义在src/mr目录下的主流程</span><br></pre></td></tr></table></figure><h3 id="1-RPC和chan实现数据交换"><a href="#1-RPC和chan实现数据交换" class="headerlink" title="1. RPC和chan实现数据交换"></a>1. RPC和chan实现数据交换</h3><h4 id="PRC"><a href="#PRC" class="headerlink" title="PRC"></a>PRC</h4><p>实现worker与cooridinator之间<strong>rpc交互</strong> call函数通过端口，调用rpcname（Coordinator.函数名），远程调用（Coordinator.函数名）这个函数，然后通过内存地址读取取回结果</p><p>目的 ： RPC 约等于PC</p><p>客户端有一个函数，服务器端有一个函数的实现 ； RPC保证远程调用，传递参数，然后返回结果</p><p>过程： 在 RPC 中，客户端和服务器端都有一个 stub。Stub 是指一份代理，它代表了本地对象与远程对象之间的一个代理，实现了客户端和服务器端的交互。当客户端调用 stub 上的方法时，stub 内部会将请求（包括函数的类型、参数等）封装成一条消息并发送给服务器端，（中间数据有序列化和反序列化）服务器端接收到请求并将执行结果返回给 stub，然后 stub 再将执行结果返回给客户端（中间数据有序列化和反序列化）。这个过程中，stub 将客户端和服务器端的交互细节封装了起来，让客户端和服务器端像本地调用一样进行 RPC 调用，从而降低了复杂度和使用难度，提高了开发效率。</p><p>在客户端和服务器端的 stub 中，通常包含了一些调用远程方法所需的信息，如方法名、方法参数等，这些信息可以通过特定的协议进行传输。在传输层面，RPC 中比较常见的协议有 TCP、HTTP 和 HTTPS 等。在使用这些协议进行远程方法调用时，stub 还可以负责序列化和反序列化请求和响应消息，这些消息通常使用类似 JSON、XML 或二进制编码形式进行表示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不需要参数和返回值，最好设置为空的结构体，不建议设置nil</span></span><br><span class="line">   <span class="keyword">var</span> reply <span class="type">int</span> <span class="comment">// 初始值为0</span></span><br><span class="line">   err := client.Call(<span class="string">&quot;Arith.Ping&quot;</span>, &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;, &amp;reply)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="用法例子"><a href="#用法例子" class="headerlink" title="用法例子"></a>用法例子</h5><p>下面是一个使用 Go 实现 RPC 调用的例子：</p><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">    A, B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span></span> Multiply(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    *reply = args.A * args.B</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arith := <span class="built_in">new</span>(Arith)</span><br><span class="line">    rpc.Register(arith)</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">    l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:5555&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个 <code>Arith</code> 类型，并为它实现了一个 <code>Multiply</code> 方法。<code>Multiply</code> 方法接收 <code>Args</code> 类型的参数，将其相乘后保存在 <code>reply</code> 指针指向的整型变量中。</p><p>程序启动后，会监听在 5555 端口，并等待客户端的 RPC 调用请求。</p><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">    A, B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:5555&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">    args := &amp;Args&#123;<span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">    start := time.Now()</span><br><span class="line">    err = client.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, args, &amp;reply) <span class="comment">// call stub生成消息 远程调用 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Arith: %d*%d=%d,time: %v\n&quot;</span>, args.A, args.B, reply, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个Args结构体类型, 使用rpc.DialHTTP来与RPC服务端建立连接, 然后向服务端发送一个 Multiply 方法的 RPC 调用，入参是 args，返回值是 reply。最后，将服务端返回的结果打印出来。</p><p>当程序运行时，客户端会向服务端发送一个 args.A&#x3D;7,args.B&#x3D;8 的请求，服务端在收到请求后会执行 Multiply 方法，将返回值 56 填充到 reply 变量中并返回给客户端。最后客户端打印出这个结果。</p><p>当服务端执行 Multiply 方法时，还用了一条 <code>time.Sleep(1 * time.Second)</code> 语句来模拟一个耗时操作。这样，我们就可以看到整个 RPC 调用过程的耗时了。</p><h4 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h4><p>channel 是golang特有的类型化消息的队列，可以通过它们发送类型化的数据在协程之间通信，可以避开所有内存共享导致的坑；通道的通信方式保证了同步性。数据通过通道：同一时间只有一个协程可以访问数据：所以不会出现数据竞争，设计如此。数据的归属（可以读写数据的能力）被传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Type <span class="comment">// 定义类型为 Type 的 chan</span></span><br><span class="line">ch &lt;- data <span class="comment">// 发送数据 data 到 chan ch</span></span><br><span class="line">data := &lt;- ch <span class="comment">// 从 chan ch 中接收数据，并将其赋值给变量 data   接收操作会一直阻塞，直到有数据可以被接收。如果不希望接收操作被阻塞，可以使用带缓冲的 chan</span></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity) <span class="comment">// 带有缓冲区的 chan 容量为 capacity  capacity 表示 chan 的缓冲区大小，可以在创建 chan 的时候指定。带缓冲的 chan 可以在没有读取者时发送数据，也可以在没有写入者时接收数据，但是如果缓冲区已满或为空时，发送和接收操作仍然会被阻塞</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，chan 还可以使用 select 语句实现多路复用，同时处理多个 chan 的读写操作，类似于 Linux 中的 select() 系统调用。在 select 语句中，可以通过 case 语句处理 chan 的读写操作，default 语句用于处理没有可读和可写的 chan 的情况。当有多个 case 同时满足条件时，程序会随机选择一个 case 进行处理。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> data := &lt;- ch1:</span><br><span class="line">    <span class="comment">// 处理从 ch1 中接收到的数据</span></span><br><span class="line">  <span class="keyword">case</span> ch2 &lt;- data:</span><br><span class="line">    <span class="comment">// 处理将数据 data 发送到 ch2 中</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有任何 chan 可读也没有可写的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用法例子-1"><a href="#用法例子-1" class="headerlink" title="用法例子"></a>用法例子</h5><p>下面是一个简单的 Go 程序，使用 chan 实现了两个协程之间的通信。在这个程序中，有一个 jobs chan 用于发送工作任务，一个 results chan 用于接收工作结果。有3个协程(worker)同时从 jobs chan 中接收任务，完成任务后将结果发送到 results chan 中。在 main 函数中，我们先向 jobs chan 发送了5个任务，然后通过接收 results chan 中的结果来等待工作的完成。这样，就实现了两个协程之间简单的通信和同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// &lt;-chan是receive-only channel而 chan&lt;-是 send-only channel</span></span><br><span class="line">    <span class="comment">// 在 Go 中，如果将一个 chan 赋值给另一个 chan 变量时，就会复制一个新的 chan,而且读写的属性一致</span></span><br><span class="line">    <span class="comment">// 在 Go 中，一个 chan 可以同时被多个协程读或写，但会有竞争写入或者竞争读取的问题，需要通过锁或者其他同步原语来解决。为了保证并发安全，建议在使用 chan 时，尽量将读写 chan 的操作限制在一个协程中，每个 chan 只由一个协程读或写。</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d started job %d\n&quot;</span>, id, j)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d finished job %d\n&quot;</span>, id, j)</span><br><span class="line">        results &lt;- j * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动三个协程进行工作</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 5 个任务到 jobs chan 中</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        jobs &lt;- i <span class="comment">// 主协程写一个，协程池就会拿一个，chan并发安全 保证只有一个协程拿到运行，是线程安全的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收工作结果</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="number">1</span>; r &lt;= <span class="number">5</span>; r++ &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我的做法是涉及的worker和cooridinator交互都用RPC交互，（其实部分用chan也可以吧）；</li><li>task相关信息队列的用chan就可以，用来分发task，天然安全，不会race</li></ol><h3 id="2-map和reduce处理"><a href="#2-map和reduce处理" class="headerlink" title="2. map和reduce处理"></a>2. map和reduce处理</h3><p>map 处理，用ihash处理下key分成Nreduce份用json编码后写出到”mr-x-y”文件。注意mr论文这步是有排序的，因为真正生产活动数据量是非常巨大的，map端提前排序好后，reduce的排序压力会减小很多。这里排不排序无所谓</p><p>map 处理结果 返回kv，存储在中间文件中，中间文件命名 mr-X-Y X是map任务号，y是reduce任务号；之后reduce再都读取中间文件；</p><p>因为真正分布式worker都不在一个机器上，涉及<strong>网络传输</strong>，所以用<strong>json编码解码走个过场</strong></p><h4 id="设计结果："><a href="#设计结果：" class="headerlink" title="设计结果："></a>设计结果：</h4><p>map阶段应该将中间键划分为<strong>nReduce</strong>的存储桶，这里只用了一倍reduce数量也就是**%NumReduce**；每个映射器都应创建NumReduce个中间文件，存在main目录下以供Reduce任务使用。</p><p>Worker实现应该将第X个Reduce任务的输出放入文件MR-OUT-X中。Done()方法，在MapReduceJob完全完成时返回TRUE；此时，mrcoherator.go将退出。当作业完全完成时，工作进程应该退出。</p><h4 id="Json编码"><a href="#Json编码" class="headerlink" title="Json编码"></a>Json编码</h4><p>纯字符串形式的数据，轻量级的数据交换格式，可以跨平台、跨语言使用。</p><p><a href="http://c.biancheng.net/json/what-is-json.html">JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它是基于 JavaScript 的一个子集，采用完全独立于编程语言的格式来表示数据，可以跨语言、跨平台使用。简洁清晰的层次结构使得 JSON 逐渐替代了 XML，成为了最理想的数据交换格式，广泛应用于 Web 开发领域</a><a href="http://c.biancheng.net/json/what-is-json.html">1</a><a href="http://www.json.org/json-zh.html">2</a>。</p><p>JOSN编码和解码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enc := json.NewEncoder(tmp_file) <span class="comment">// 创建JSON编辑器，用于写入tmp_file</span></span><br><span class="line">err = enc.Encode(bucket[i])     <span class="comment">// 将buckt[i]的值编码为JSON格式，写入文件</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv []KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123; <span class="comment">//解码</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">intermediate = <span class="built_in">append</span>(intermediate, kv...) <span class="comment">// ...表示把切片打散成元素后加入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-加锁"><a href="#3-加锁" class="headerlink" title="3 加锁"></a>3 加锁</h3><p>由于我用了channel所以在任务分配队列实现了天然并发安全，但是在别的地方还是遇到了问题，比如Done函数通过mrcoordinator主线程去时不时读取coordinator的状态来判断是否结束死循环。还有在一个worker调coordinator拉取数据的时候，另一个worker调coordinator的checkJobDone()函数进行检查。因此在响应可能发生冲突的地方加锁</p><h3 id="4-等待"><a href="#4-等待" class="headerlink" title="4. 等待"></a>4. 等待</h3><ol><li>GetTask调用失败，原因未处理work等待；<br>worker有时候需要等待,比如当map任务都分发出去了,有的worker完成后又来申请任务，此时还有map未完成,reduce不能开始，这个worker需要等待下</li></ol><p>解决：每次worker工作后都time.Sleep(time.Second)</p><h3 id="5-crash-test"><a href="#5-crash-test" class="headerlink" title="5.crash test"></a>5.crash test</h3><ol><li>crash test失败，原因未处理可能损坏的worker<br>   mrapps&#x2F;crash.go 随机干掉map reduce,看crash.go的代码是有一定几率让worker直接退出或者长时间延迟,可以用来测试恢复功能。这个逻辑是整合在map reduce函数里面的，注意worker被干掉时候任务已经拿到手了</li></ol><p>解决：添加TimeTick函数，放到Done()函数中，检查map task 和 reduce task的时间，如果超过10秒，重新加载该Task</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.MapTask &lt;- Task&#123;FileName: c.files[i], MapId: i&#125; <span class="comment">//TODO 这里硬加Task没有去掉原来的Task 可能会导致跑很多次</span></span><br><span class="line"><span class="comment">/* task生命周期分析： </span></span><br><span class="line"><span class="comment">maptask在MakeCoordinator创建，定时间； 在做完在TaskFin设置true ； 在TimeTick检查是否超时，如果超时 重新添加这个任务</span></span><br><span class="line"><span class="comment">这里其实判断超时没有区分是创建时间超时还是做任务超时，所以在做任务的时候设置时间</span></span><br></pre></td></tr></table></figure><p>要记住go 的range第一个参数是index </p><p> strconv.Itoa 转化格式 字符串</p><p>os.Open 默认以只读方式打开，返回一个error； os.OpenFile可以设置打开文件的模式</p><h2 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h2><h3 id="高容错的实现难点："><a href="#高容错的实现难点：" class="headerlink" title="高容错的实现难点："></a>高容错的实现难点：</h3><ol><li>高性能的要求 -&gt; 跨机器对数据分片</li><li>大量计算机   -&gt;  会有很多崩溃</li><li>容错解决奔溃情况 -&gt; 副本 </li><li>副本 -&gt; 需要实施更新，保持副本一致</li><li>一致性高 -&gt; 性能开销</li></ol><h3 id="一致性实现的难点-："><a href="#一致性实现的难点-：" class="headerlink" title="一致性实现的难点 ："></a>一致性实现的难点 ：</h3><ol><li>并发性 ，保证线程安全，可以通过之后的分布式锁等机制解决</li><li>故障和失败案例 ：为了容错会用复制，但是不成熟的复制会导致读者在不做修改的情况下读到两次不同数据。</li></ol><h3 id="GFS简介"><a href="#GFS简介" class="headerlink" title="GFS简介"></a>GFS简介</h3><p> GFS旨在保持高性能，且有复制、容错机制，但很难保持一致性，现在谷歌已经不用了； 在论文中可以看到mapper从GFS系统(上千个磁盘)能够以超过10000MB&#x2F;s的速度读取数据。论文发表时，当时单个磁盘的读取速度大概是30MB&#x2F;s，一般在几十MB&#x2F;s左右。</p><p>GFS的几个主要特征：</p><ul><li>Big：large data set，巨大的数据集</li><li>Fast：automatic sharding，自动分片到多个磁盘</li><li>Gloal：all apps see same files，所有应用程序从GFS读取数据时看到相同的文件（一致性）</li><li>Fault tolerance：automic，尽可能自动地采取一些容错恢复操作</li></ul><h3 id="GFS的Master的工作"><a href="#GFS的Master的工作" class="headerlink" title="GFS的Master的工作"></a>GFS的Master的工作</h3><ul><li><p>维护文件名到块句柄数组的映射(file name &#x3D;&gt; chunk handles)  <strong>filename -&gt; chunk handles -&gt; chunk server \  version</strong></p><p>这些信息大多数存放在内存中，所以Master可以快速响应客户端Client</p></li><li><p>维护每个块句柄(chunk handle)的版本(version)</p></li><li><p>维护块存储服务器列表(list of chunk servers)</p><ul><li>主服务器(primary)<ul><li>Master还需维护每一个主服务器(primary)的<strong>租赁时间(lease time)</strong></li></ul></li><li>次要服务器(secondaries)</li></ul><p>典型配置即将chunk存储到3台服务器上</p></li><li><p>log+check point：通过日志和检查点机制维护文件系统。所有变更操作会先在log中记录，后续才响应Client。这样即使Master崩溃&#x2F;故障，重启时也能通过log恢复状态。master会定期创建自己状态的检查点，落到持久性存储上，重启&#x2F;恢复状态时只需重放log中最后一个check point检查点之后的所有操作，所以恢复也很快。</p></li></ul><p> 这里需要思考的是，哪些数据需要放到稳定的存储中(比如磁盘)？</p><ul><li><p>比如file name &#x3D;&gt; chunk hanles的映射，平时已经在内存中存储了，还有必要存在稳定的存储中吗？</p><p>需要，否则崩溃后恢复时，内存数据丢失，master无法索引某个具体的文件，相当于丢失了文件。</p></li><li><p>chunk handle 到 存放chunk的服务器列表，这一层映射关系，master需要稳定存储吗？</p><p>不需要，master重启时会要求其他存储chunk数据的服务器说明自己维护的chunk handles数据。这里master只需要内存中维护即可。同样的，主服务器(primary)、次要服务器(secondaries)、主服务器(primary)的租赁时间(lease time)也都只需要在内存中即可。</p></li><li><p>chunk handle的version版本号信息呢，master需要稳定存储吗？</p><p>需要。否则master崩溃重启时，master无法区分哪些chunk server存储的chunk最新的。比如可能有服务器存储的chunk version是14，由于网络问题，该服务器还没有拿到最新version 15的数据，master必须能够区分哪些server有最新version的chunk。</p></li></ul><h3 id="GFS数据读取流程"><a href="#GFS数据读取流程" class="headerlink" title="GFS数据读取流程"></a>GFS数据读取流程</h3><p><img src="D:\MyTxt\typoraPhoto\image-20230411161308484.png" alt="image-20230411161308484"></p><p>GFS通过Master管理文件系统的元数据等信息，其他Client只能往GFS写入或读取数据。</p><p>应用并发的通过GFS Client读取数据时，单个读取的大致流程如下：</p><ol><li>Client向Master发起读数据请求</li><li>Master查询需要读取的数据对应的目录等信息，汇总文件块访问句柄、这些文件块所在的服务器节点信息给Client（大文件通常被拆分成多个块Chunk存放到不同服务器上，单个Chunk很大， 这里是64MB）</li><li>Client得知需要读取的Chunk的信息后，直接和拥有这些Chunk的服务器网络通信传输Chunks</li></ol><h3 id="GFS文件读取"><a href="#GFS文件读取" class="headerlink" title="GFS文件读取"></a>GFS文件读取</h3><ol><li>Client向Master发请求，要求读取X文件的Y偏移量的数据</li><li>Master回复Client，X文件Y偏移量相关的块句柄、块服务器列表、版本号(chunk handle, list of chunk servers, version)</li><li>Client 缓存cache块服务器列表(list of chunk servers)<br>？ 只有一个Master，所以需要尽量减少Client和Server之间的通信次数，缓冲减少交互</li><li>Client从最近的服务器请求chunk数据(reads from closest servers)<br>？ 因为这样在宛如拓扑结构的网络中可以最大限度地减少网络流量(mininize network traffic)，提高整体系统的吞吐量</li><li>被Client访问的chunk server检查version，version正确则返回数据<br>？ 为了尽量避免客户端读到过时数据的情况。</li></ol><h3 id="GFS文件写入"><a href="#GFS文件写入" class="headerlink" title="GFS文件写入"></a>GFS文件写入</h3><p> 主要是关注文件写入的append操作，在mapreduce 中，reduce处理后计算结果需要append到file中</p><img src="D:\MyTxt\typoraPhoto\image-20230411165609018.png" alt="image-20230411165609018" style="zoom: 67%;" /><ol><li><p>Client向Master发出请求，查询应该往哪里写入filename对应的文件。</p></li><li><p>Master查询filename到chunk handle映射关系的表，找到需要修改的chunk handle后，再查询chunk handle到<strong>chunk server数组映射关系的表</strong>，以list of chunk servers(主副本primary、secondaries、version信息)<strong>也就是得到所有该文件的chunkserver并且附加上版本号</strong>作为Client请求的响应结果</p><p>接下去有两种情况，已有primary和没有primary(假设这是系统刚启动后不久，还没有primary)</p><ul><li><p>有primary，（<strong>primary：主文件副本，也就是正常情况下对外读写的文件；secondaries： 其他副本</strong>）</p><p>继续后续流程</p></li><li><p>无primary</p><ul><li><p>master在chunk servers中选出一个作为primary，其余的chunk server作为secondaries</p><p>(暂时不考虑选出的细节和步骤)</p><ul><li>master会增加version（每次有<strong>新的primary</strong>时，都需要考虑时进入了一个new epoch，所以需要<strong>维护新的version</strong>），然后向primary和secondaries发送新的version，并且会发给primary有效期限的租约lease。这里primary和secondaries需要将version存储到磁盘，否则重启后内存数据丢失，无法让master信服自己拥有最新version的数据(同理Master也是将version存储在磁盘中)。</li></ul></li></ul></li></ul></li><li><p>Client发送数据到想写入的chunk servers(primary和secondaries)，有趣的是，<strong>这里Client只需访问最近的secondary，而这个被访问的secondary会将数据也转发到列表中的下一个chunk server</strong>，<strong>此时数据还不会真正被chunk severs存储</strong>。（即上图中间黑色粗箭头，secondary收到数据后，马上将数据推送到其他本次需要写的chunk server）<br>？ 这么做提高了Client的吞吐量，避免Client本身需要消耗大量网络接口资源往primary和多个secondaries都发送数据。</p></li><li><p>数据传递完毕后，Client向primary发送一个message，表明本次为append操作。</p><p>primary此时需要做几件事：</p><ol><li>primary此时会检查version，如果version不匹配，那么Client的操作会被拒绝</li><li>primary检查<strong>lease是否还有效</strong>，如果自己的lease无效了，则不再接受任何mutation operations（因为租约无效时，外部可能已经存在一个新的primary了）</li><li>如果version、lease都有效，那么primary会选择一个offset用于写入</li><li>primary将前面接收到的数据写入稳定存储中</li></ol></li><li><p>primary发送消息到secondaries，表示需要将之前接收的数据写入指定的offset（更新其他副本）</p></li><li><p>secondaries写入数据到primary指定的offset中，并回应primary已完成数据写入</p></li><li><p>primary回应Client，你想append追加的数据已完成写入</p></li></ol><h3 id="GFS一致性"><a href="#GFS一致性" class="headerlink" title="GFS一致性"></a>GFS一致性</h3><ol><li><p>appen一次之后，read返回什么结果</p><p>例如： M（maseter），P（primary），S（Secondary）</p><p>某时刻Mping不到P了，那咋办？ </p><p>假设选出新P，那可能旧P还在和CLient交互，两个P同时存在叫做脑裂，会出现严重问题，比如数据写入顺序混乱等问题，严重的脑裂问题可能会导致系统最后出现两个Master。</p><p>所以依照M知道的旧P的lease，在旧Please期限结束之前，不会选出新P，也就是M和P无法通信，但是P还可能和其他Client通信</p></li><li><p>强一致性的保证<br>保证 所有S都成功写入或者都不写入</p></li></ol><p>GFS是为了运行mapreduce而设计的</p><h2 id="VMWare-FT"><a href="#VMWare-FT" class="headerlink" title="VMWare-FT"></a>VMWare-FT</h2><h3 id="The-Design-of-a-Practical-System-for-Fault-Tolerant-Virtual-Machines"><a href="#The-Design-of-a-Practical-System-for-Fault-Tolerant-Virtual-Machines" class="headerlink" title="The Design of a Practical System for Fault-Tolerant Virtual Machines"></a>The Design of a Practical System for Fault-Tolerant Virtual Machines</h3><p>(容错虚拟机)[[<a href="https://blog.csdn.net/weixin_40910614/article/details/117995014]]">https://blog.csdn.net/weixin_40910614/article/details/117995014]]</a></p><p>只针对一个backup 单核 一个storage</p><h3 id="备份实现方法"><a href="#备份实现方法" class="headerlink" title="备份实现方法"></a>备份实现方法</h3><p>实现分布式容错常用方法是 <strong>主&#x2F;备份方法</strong>；一致性的保证需要保持同步，两种方法： </p><ol><li>状态转移，主服务器持续发送搜索状态变化给备份服务器，带宽需求大</li><li>备份状态机，备份状态机视为确定状态机（DSM）。主&#x2F;备份服务器相同的初始状态启动，然后相同的顺序接受并执行相同的输入请求，得到相同的输出，这样保持一致性，方法复杂，数据传输量小很多。</li><li>状态转移是记录checkpoint点，同步完后再返回给client；复制状态机是操作记录同步后，再响应client</li></ol><p>采用备份状态机会有一个问题，即对于真实物理机来讲，有些行为是不确定的（例如，中断，产生的随机数等），所以很难将行为看作是一个确定性（deterministic）的行为。<br>VMWare的解决方案是将所有操作虚拟化，并在VM和物理机之间加一个Hypervisor（虚拟机管理程序），然后就可以通过hypervisor让VM都能模拟成一个DSM运行，那么primary的所有操作都确定了，再通过Logging channel将这些操作传递到backup，然后backup进行replay，从而实现两者的高度一致。<br>具体是怎么将不确定的行为进行确定化操作的，它主要是进行了一个写日志的操作来保证的</p><h3 id="复制状态机具体复制的是什么操作"><a href="#复制状态机具体复制的是什么操作" class="headerlink" title="复制状态机具体复制的是什么操作"></a>复制状态机具体复制的是什么操作</h3><p>应用程序级别： 比如GFS的文件append或write，需要关注复制状态机如何处理的，一般需要修改应用程序本身</p><p>机器层面操作： 状态state是寄存器的状态、内存的状态，操作operation则是传统的计算机指令；这种情况复制状态机感知的是底层机器指令，用硬件很昂贵，这里用的是虚拟机实现的</p><img src="D:\MyTxt\typoraPhoto\image-20230413151512850.png" alt="image-20230413151512850" style="zoom: 50%;" /><h3 id="非确定信息导致差异"><a href="#非确定信息导致差异" class="headerlink" title="非确定信息导致差异"></a>非确定信息导致差异</h3><p>非确定性的指令，网络包接受&#x2F;时钟中断，多核（不讨论）</p><p>VM-FT对非确定性指令会先拦截，然后模拟执行，并且同步</p><h3 id="失败场景处理"><a href="#失败场景处理" class="headerlink" title="失败场景处理"></a>失败场景处理</h3><p>primary操作完成后，和client断了，这时候backup接手，那这次操作就失效了。</p><p>实际上不会发生这个错误，primary响应client之前，会通过logging channel发送消息给backup，backup相同操作后发ack，primary收到ack后，才响应client</p><p>raft也是一样</p><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><ol><li>避免脑裂，对外只有一个primary输入输出，通过logging channel传递给Backup达到同步</li><li>两个虚拟机部署，一个磁盘，一个网络</li><li>确定性存放：也就是做一个确定状态机，具体是<strong>Hypervisor</strong>操作虚拟化后，把所有primary的确定、不确定（比如随机生成一个数）事件都记录log entry流，传给backup，保证一致性</li><li>FT Protocol：每次primary把output<strong>写到日志给backup后才发送</strong>，目的是保证backup随时能接手且<strong>一致</strong><br>保证<strong>故障转移</strong>（当primary失败时，我们希望切换到backup提供服务）</li><li>FT Logging Buffers and Channel： primary和backup两端的日志缓存差距保持在一个范围，用到了生产者消费者模型</li><li>检测 故障响应：primary和backup两端的UDP心跳检测、logging channel检测</li><li>虚拟机恢复FT VMotion：对VM进行克隆</li></ol><h3 id="与GFS比较"><a href="#与GFS比较" class="headerlink" title="与GFS比较"></a>与GFS比较</h3><ol><li>VM-FT备份的是<strong>计算</strong>，GFS备份的是存储。</li><li>VM-FT提供了相对严谨的一致性，并且对客户端和服务器都是透明的。可以用它为任何已有的网络服务器提供容错。例如，可以将 FT 应用于一个已有的邮件服务器并为其提供容错性。</li><li>GFS 只针对一种简单的服务提供容错性，它的备份策略会比 FT 更为高效。例如，GFS 不需要让所有的操作都应用在所有的 Replica 上。</li><li>VM-FT<strong>不适合进行高吞吐量的服务</strong>，性能下降很多，毕竟它要对整个系统内的内存、磁盘、中断等都进行 replay，这是一个巨大的负担</li></ol><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><h3 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h3><p>复制状态机（Replicated State Machine，简称RSM）是一种分布式系统的设计模式。在该模式下，一个服务或应用程序的状态机被复制到多个节点上并进行并行处理，以提高可用性和性能。</p><p>具体地说，采用复制状态机的系统中，对于某个特定的客户端请求，它将被发送到所有复制的状态机或者其中的一组。然后，每个状态机独立地执行相同的操作序列，并生成相同的结果。最终，生成的结果将会被汇总并返回给客户端。</p><p>通过这种方式，复制状态机可以将单点故障风险降至最低并提高系统的可靠性。此外，由于并行执行相同的操作序列，该模式还能够提供更好的性能和可伸缩性。</p><p>复制状态机是一种常见的分布式系统设计模式，在诸如Google、Facebook和Amazon等互联网巨头公司的分布式系统中得到广泛应用。</p><h3 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h3><p>前面介绍过的复制系统，都存在单点故障问题(single point of failure)。</p><ul><li>mapreduce中的cordinator</li><li>GFS的master</li><li>VM-FT的test-and-set存储服务器storage</li></ul><p> 而上述的方案中，采用单机管理而不是采用多实例&#x2F;多机器的原因，是为了避免**脑裂(split-brain)**问题。</p><p> 不过大多数情况下，单点故障是可以接受的，因为单机故障率显著比多机出现一台故障的概率低，并且重启单机以恢复工作的成本也相对较低，只需要容忍一小段时间的重启恢复工作。</p><p><strong>为什么单机管理能避免脑裂问题</strong> ？</p><p>比如有两个strorage，要选出primary，那可能有网络分区的原因，storage两个分区产生两个primary，对外界的client来说有两种不同的</p><h3 id="大多数原则-majority-rule"><a href="#大多数原则-majority-rule" class="headerlink" title="大多数原则 majority rule"></a>大多数原则 majority rule</h3><p>如何解决脑裂： 如果投票得大于一半，多数的那个成为leader，也就是多数的分区会继续运行，如果没有多数 系统不能运行</p><h3 id="用Raft构造复制状态机RSM"><a href="#用Raft构造复制状态机RSM" class="headerlink" title="用Raft构造复制状态机RSM"></a>用Raft构造复制状态机RSM</h3><p>这里raft就像一个library应用包。假设我们通过raft协议构造了一个由3台机器组成的K&#x2F;V存储系统。</p><p>系统正常工作时，大致流程如下：</p><ul><li>Client向3台机器中作为leader的机器发查询请求</li><li>leader机器将接收到的请求记录到底层raft的顺序log中</li><li>当前leader的raft将顺序log中尾部新增的log记录通过网络同步到其他2台机器</li><li>其他两台K&#x2F;V机器的raft成功追加log记录到自己的顺序log中后，回应leader一个ACK，<br>（如果有一台网络问题比较慢，那也达到了majority）</li><li>leader的raft得知其他机器成功将log存储到各自的storage后，将log操作反映给自己的K&#x2F;V应用<br>（网慢的那台这时候才发ACK，）</li><li>K&#x2F;V应用实际进行K&#x2F;V查询，并且将结果响应给Client</li></ul><p>系统出现异常时，发生如下事件：</p><ul><li>Client向leader请求</li><li>leader向其他2台机器同步log并且获得ACK</li><li>leader准备响应时突然宕机，无法响应Client</li><li>其他2台机器重新选举出其中1台作为新的leader</li><li>Client请求超时或失败，重新发起请求，<strong>系统内部failover故障转移</strong>，所以这次Client请求到的是新leader</li><li>新leader同样记录log并且同步log到另一台机器获取到ACK</li><li>新leader响应Client</li></ul><h3 id="Raft的log"><a href="#Raft的log" class="headerlink" title="Raft的log"></a>Raft的log</h3><p>用途：持久化、顺序化 操作数据 ，方便重传，方面查看同步操作进行的情况</p><p>格式：</p><p>有很多的log entry（入口），比如log index 、 leader term这些唯一标识；每个log entry 有 command 和 leader term信息；</p><p>保证最后机器的所有log的一致性</p><h3 id="Raft的选举"><a href="#Raft的选举" class="headerlink" title="Raft的选举"></a>Raft的选举</h3><p>followers收不到leaders的心跳，election time超时，开始重新选举，新的leader term</p><p>这时候就算原leader接进来，也会发现是新的leader term， 不会唱脑裂</p><h4 id="防止选举死循环"><a href="#防止选举死循环" class="headerlink" title="防止选举死循环"></a>防止选举死循环</h4><p>如果两个followers的election time 几乎同时到齐，都成为candidate，那会一直竞争leader死循环;</p><p>一般采用election time为随机值，防止同时发起选举</p><h4 id="选举超时时间"><a href="#选举超时时间" class="headerlink" title="选举超时时间"></a>选举超时时间</h4><p>略大于心跳时间，太短会频繁选举，而且选举过程中是对外宕机，太长检测不到，本身也是宕机</p><p>加入些随机数，防止分裂选举死循环</p><p> Raft论文进行了大量实验，以得到250ms～300ms这个在它们系统中的合理值作为eleciton timeout。</p><h2 id="FT-Raft-2"><a href="#FT-Raft-2" class="headerlink" title="FT-Raft-2"></a>FT-Raft-2</h2><h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><p>处理别节点发来的RequestVote RPC时，需要检查限制，满足以下之一才能赞同票：</p><ol><li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号；或者</li><li>候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录的长度</li></ol><p>成为leader的限制：</p><ol><li>大多数原则</li><li>当选的机器一定是具有最新的term的机器</li></ol><h3 id="日志覆写同步（未优化版本）"><a href="#日志覆写同步（未优化版本）" class="headerlink" title="日志覆写同步（未优化版本）"></a>日志覆写同步（未优化版本）</h3><p>所有raft节点维护两个Index</p><ul><li><p>nextIndex数组：乐观的变量，所有raft节点都维护<code>nextIndex[followerId]</code>用于记录leader认为followerId的下一个需要填充log的index。<br>更新时间：每个leader当选之后都会乐观的认为所有的follower的nextIndex是自己的log最后的下一个，而在实际appendEntries或者installSnapshot的时候如果发现日志同步没有那么乐观就会根据情况减小next，把之前没有同步的log先同步上。</p></li><li><p>matchIndex数组：悲观变量，，所有raft节点都维护<code>matchIndex[followerId]</code>用于记录leader认为followerId的已经确认的log最后一个的index，表示在此之前的log都是和当前的leader确认一致的。<br>更新时间：每个leader当选之后都会悲观的认为自己已经确认过所有的follower的nextIndex是0，因为还没开始确认。</p></li></ul><p>未优化版本的问题：Raft集群中有出现log落后很多的server，leader需要进行很多次请求才能将其log与自己对齐</p><h3 id="日志擦除"><a href="#日志擦除" class="headerlink" title="日志擦除"></a>日志擦除</h3><p>新上任的leader发现其他follower有和自己不一样的log，就会把从那个log开始往后的logs都擦除，来保证leader的日志权威性一致性</p><h3 id="日志快速覆写同步（优化）"><a href="#日志快速覆写同步（优化）" class="headerlink" title="日志快速覆写同步（优化）"></a>日志快速覆写同步（优化）</h3><p>落后较多的log（比如新机器接入、宕机恢复很久）要同步到现在leader一致的话，按照之前的逐步回退很慢，浪费网络资源</p><p>优化后的log catch up quickly过程：</p><table><thead><tr><th></th><th>logIndex1</th><th>logIndex2</th><th>logIndex3</th><th>logIndex4</th><th>logIndex5</th></tr></thead><tbody><tr><td>S1</td><td>term4</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>S2</td><td>term4</td><td>6</td><td>6</td><td>6</td><td>6</td></tr></tbody></table><ol><li>S2的leader是term7当选，那nextIndex &#x3D; 6，发送hearbeat随带log是(空, 6, 5)，意思是(当前nextIndex指向的term，nextIndex-1的term, nextIndex-1的值)</li><li>S1收到心跳，对比自己的logIndex为term5，与之前不同的是，除了no顺带回复自己的log信息(5,2), 意思是(请求中logIndex位置的值，当前值最早出现的logIndex位置)</li><li>S2收到回应后，把nextIndex改为2，下次附带([6,6,6,6],4,1), 意思是nextIndex之后的数据是[6,6,6,6]</li><li>S1收到后，检查logIndex1是term4对齐了，更新一致性</li></ol><p>广播的时候，面对大量followers， 用每个go程单独处理followers</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>就是把一些全局的变量（比如currentTerm）写到（持久化存储）磁盘里，当然操作回复之前写入，类似于同步过程</p><p>持久化原因： 如果重启之后不知道任期号，很难确保任期只有一个leader</p><p>一个Raft节点崩溃重启（和新加入节点一样）后，必须重新加入</p><p>除了重新加入重新执行本地的log，更偏向于快速重启，上次持久化快照位置开始，这就要考虑持久化一些状态量：</p><ul><li>vote for：投票情况，因为需要保证每轮term每个server只能投票一次</li><li>log：崩溃前的log记录，<strong>因为我们需要保证(promise)已发生的(commit)不会被回退</strong>。否则崩溃重启后，可能发生一些奇怪的事情，比如client先前的请求又重新生效一次，导致某个K&#x2F;V被覆盖成旧值之类的。</li><li>current term：崩溃前的当前term值。因为选举(election)需要用到，用于投票和拉票流程，并且<strong>需要保证单调递增</strong>(monotonic increasing)</li><li>lastIncludedIndex: 奔溃前的快照保存的最后一个log的index，到这个log位置都是保存在快照中的，也就是状态机的持久化数据，如果崩溃后重启就不用交这个log之前的log了，因为上层可以直接读取整个快照。</li><li>lasIncludedIndex: 奔溃前的快照保存的最后一个log的term</li></ul><h3 id="服务恢复"><a href="#服务恢复" class="headerlink" title="服务恢复"></a>服务恢复</h3><p>类似的，服务重启恢复时有两种策略：</p><ol><li>日志重放(replay log)：理论上将log中的记录全部重放一遍，能得到和之前一致的工作状态。这一般来说是很昂贵的策略，特别是工作数年的服务，从头开始执行一遍log，耗时难以估量。所以一般人们不会考虑策略1。</li><li>**周期性快照(periodic snapshots)**：假设在i的位置创建了快照，那么可以裁剪log，只保留i往后的log。此时重启后可以通过snapshot快照先快速恢复到某个时刻的状态，然后后续可以再通过log catch up或其他手段，将log同步到最新状态。（一般来说周期性的快照不会落后最新版本太多，所以恢复工作要少得多）</li></ol><p> 这里可以扩展考虑一些场景，比如Raft集群中加入新的follower时，可以让leader将自己的snapshot传递给follower，帮助follower快速同步到近期的状态，尽管可能还是有些落后最新版本，但是根据后续log catch up等机制可以帮助follower随后快速跟进到最新版本log。</p><p> 使用快照时，需要注意几点：</p><ul><li>需要拒绝旧版本的快照：有可能收到的snapshot比当前服务状态还老</li><li>需要保持快照后的log数据：在加载快照时，如果有新log产生，需要保证加载快照后这些新产生的log能够能到保留</li></ul><h3 id="使用Raft"><a href="#使用Raft" class="headerlink" title="使用Raft"></a>使用Raft</h3><p> 重新回顾一下服务使用Raft的大致流程</p><ol><li>应用程序中集成Raft相关的library包</li><li>应用程序接收Client请求</li><li>应用程序调用Raft的start函数&#x2F;方法</li><li>下层Raft进行log同步等流程</li><li>Raft通过apply channel向上层应用反应执行完成</li><li>应用程序响应Client</li></ol><ul><li>并且前面提过，可能作为leader的Raft所在服务器宕机，所以Client必须维护server列表来切换请求的目标server为新的leader服务器。</li><li>同时，有时候请求会失败，或者Raft底层失败，导致重复请求，而我们需要有手段辨别重复的请求。通常可以在get、put请求上加上请求id或其他标识来区分每个请求。一般维护这些请求id的服务，被称为clerk。提供服务的应用程序通过clerk维护每个请求对应的id，以及一些集群信息。</li></ul><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><img src="D:\MyTxt\typoraPhoto\image-20230508170955517.png" alt="image-20230508170955517" style="zoom:33%;" /><p><img src="D:\MyTxt\typoraPhoto\image-20230508171059069.png" alt="image-20230508171059069"></p><p>Raft 复制状态机协议</p><p>实现FT ，难点是故障导致副本一致性受损，难点是调试</p><p>把client请求组织到log序列汇总，确保所有副本服务器看到相同的Log，来保证一致性；如果服务器故障之后回复，Raft会将日志更新；所以只要大多数服务器活着且能通信，Raft就继续，不然就宕机直到大多数机器能通信才开始从中断位置通信</p><p>Raft作为关联方法的Go对象类型，作为模块。一组RAFT实例通过RPC相互通信以维护复制的日志。您的RAFT界面将支持不确定的编号命令序列，也称为日志条目。这些条目用索引号进行编号。具有给定索引的日志条目最终将被提交。此时，您的RAFT应该将日志条目发送到更大的服务以供其执行。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>三个时间的比较： broadcastTime 100« electionTimeout 200-400« 平均故障时间</p><p>两个RPC ：  AppendEntriesRPCs是 leader进行日志复制和心跳时使用的 &lt;&lt; RequestVoteRPCs是候选在这选举过程中使用的</p><p>两个时间驱动用单独的goroutine驱动 </p><p>简单的实现方式是在raft中维护一个变量，包含leader的最后一次消息的时间，并用goroutine用sleep()驱动定期检查是否超时</p><p>定时的设置想了很久，把elctiontime作为下一个选举的时间点，定期检查是否超过这个时间点，如果超过了就要选举，heartbeattime设置为时间长度，用sleep相应长度然后发送heartbeat</p><p>先设置 100 和 150-300，一次心跳不到重选</p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ul><li><code>entry</code>：Raft 中，将每一个事件都称为一个 entry，每一个 entry 都有一个表明它在 log 中位置的 index（之所以从 1 开始是为了方便 <code>prevLogIndex</code> 从 0 开始）。只有 leader 可以创建 entry。entry 的内容为 <code>&lt;term, index, cmd&gt;</code>，其中 cmd 是可以应用到状态机的操作。在 raft 组大部分节点都接收这条 entry 后，entry 可以被称为是 committed 的。</li><li><code>logs</code>：由 entry 构成的数组，只有 leader 可以改变其他节点的 log。 entry 总是先被 leader 添加进本地的 log 数组中去，然后才发起共识请求，获得 quorum 同意后才会被 leader 提交给状态机。follower 只能从 leader 获取新日志和当前的 commitIndex，然后应用对应的 entry 到自己的状态机</li></ul><h3 id="election"><a href="#election" class="headerlink" title="election"></a>election</h3><p>candida并发请求选票，大于一半的时候成为leader，保证只成为一次 用sync.Once类型</p><p>这是Go编程语言中的代码，<code>sync.Once</code>是Go标准库中的一种并发原语，用于确保某个函数只会被执行一次。</p><p>在该代码中，<code>becomeLeader</code>是一个变量，使用<code>sync.Once</code>作为其类型，在程序运行过程中，我们可以通过调用<code>becomeLeader.Do(func)</code>的方式来确保<code>func</code>只会被执行一次。每当我们需要执行<code>func</code>时，我们可以多次调用<code>becomeLeader.Do(func)</code>函数，但实际上，该函数只会执行一次。</p><h3 id="RPC的处理"><a href="#RPC的处理" class="headerlink" title="RPC的处理"></a>RPC的处理</h3><p>每个RPC应该在自己的goroutine中发送并处理回复，因为：</p><ol><li>到不了的peer不会延迟收集选票的过程</li><li>electiontime和heartbeattime可以继续在任何时候计时</li></ol><p>election是并行的给集群中的其它机器发送 RequestVote RPCs</p><p>选取投票的写法： 一个函数开始投票，分出很多go程每个单独对接，每个函数对接发RPC和后处理</p><h3 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h3><p>安全性的限制：Raft使用选举过程来保证一个候选者必须包含有所有已提交的日志才能胜出；请求中包含了 leader的日志信息，如<br>果投票者的日志比候选者的日志更新，那么它就拒绝投票 :</p><ol><li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号；或者</li><li>候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录的长度</li></ol><p>成为leader的限制：</p><ol><li>大多数原则</li><li>当选的机器一定是具有最新的term的机器</li></ol><h3 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h3><p>每次当 leader发送 AppendEntries RPCs请求的时候，请求中会包含当前nextIndex后面的日志记录 和 他直接前继的任期和索引，</p><ol><li><p>如果存在一条日志索引和 prevLogIndex相等，但是任期和 prevLogItem不相同的日志，需要删除这条日志及所有后继日志。</p></li><li><p>如果 leader复制的日志本地没有，则直接追加存储。</p></li></ol><p>以上两条需要分别进行，如果直接用leader发来的日志记录覆盖follower的日志，那会产生bug，因为这个RPC可能是过时的RPC，所以需要严格保存这两条的分别执行。</p><h3 id="applyCh"><a href="#applyCh" class="headerlink" title="applyCh"></a>applyCh</h3><p>作为一个ApplyMsg的chan，日志提交之后 需要添加发送的条目</p><p>需要用单独的goroutine实现，因为可能阻塞，必须是一个不然难以确保按照日志顺序发送</p><p>go程用sync.Cond在不满足发送条件的时候等待, 需要提交的时候唤醒</p><h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3><p>nextIndex是leader认为的下次发给其他follower新log的首位置，在当选的时候会自认为所有follower的nextIndex都和自己一样，是自己日志的记录的最后一条的+1位置；</p><p>commitIndex是每个server被提交日志后最新log的索引。</p><p>lastApplied是每个server提交状态机的最新log的索引。</p><p><strong>Raft 保证下列两个性质</strong>：</p><ul><li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd；</li><li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同。</li></ul><p>通过”仅有 leader 可以生成 entry”来确保第一个性质， 第二个性质则通过一致性检查（consistency check）来保证，该检查包含几个步骤：</p><p>leader 在通过 AppendEntriesRPC 和 follower 通讯时，会带上上一块 entry 的信息， 而 follower 在收到后会对比自己的日志，如果发现这个 entry 的信息（index、term）和自己日志内的不符合，则会拒绝该请求。一旦 leader 发现有 follower 拒绝了请求，则会与该 follower 再进行一轮一致性检查， 找到双方最大的共识点，然后用 leader 的 entries 记录覆盖 follower 所有在最大共识点之后的数据。</p><p>寻找共识点时，leader 还是通过 AppendEntriesRPC 和 follower 进行一致性检查， 方法是发送再上一块的 entry， 如果 follower 依然拒绝，则 leader 再尝试发送更前面的一块，直到找到双方的共识点。 因为分歧发生的概率较低，而且一般很快能够得到纠正，所以这里的逐块确认一般不会造成性能问题。当然，在这里进行二分查找或者某些规则的查找可能也能够在理论上得到收益。</p><h4 id="边界条件考虑"><a href="#边界条件考虑" class="headerlink" title="边界条件考虑"></a>边界条件考虑</h4><p>初始存入 0 0 空作为第一个log，作为dummy节点。在添加快照功能之后需要把logs[0].index改成lastIncludedIndex。在这之前，保持dummy节点作为锚点不被改变</p><h4 id="快速同步"><a href="#快速同步" class="headerlink" title="快速同步"></a>快速同步</h4><p>实现的主要方法是在reply中添加一个Xindex，每次RPC结束后都通知leader更新nextIndex[serverID]。</p><p>如果落后的较多，则返回Xindex为最后一个log的index + 1通知leader发送下次从这个Xindex开始日志串</p><p>如果index匹配了，但是term不一致，则按照论文给出的优化方法，找到这个term对应的第一个日志并放到Xindex中存起来，这样 leader<br>接受到响应后，就可以直接跳过所有冲突的日志（其中可能包含了一致的日志）。这样就可以减少寻找一致点的过程。</p><p>按照这个方案2B的catch up测试还是比较慢，用27秒，老师给出的是17秒</p><h4 id="一个RPC重试的BUG"><a href="#一个RPC重试的BUG" class="headerlink" title="一个RPC重试的BUG"></a>一个RPC重试的BUG</h4><p>原来的实现：</p><p>​如果appendEntriesLeader发现follower的日志不同步，重新修改后递归appendEntriesLeader，也就是重发RPC直到同步完成。但是因为本身就是上锁的函数，递归调用自己，还要解锁再加锁，就算这样了递归调用不知道有错，错误不匹配后retry，但是第二次还出错不retry了。</p><p>修改后的实现：</p><p>​如果同步失败，则修改nextIndex，等着下一次心跳或者快照来同步</p><h3 id="测试结果说明"><a href="#测试结果说明" class="headerlink" title="测试结果说明"></a>测试结果说明</h3><table><thead><tr><th>时间</th><th>peer数量</th><th>RPC数量</th><th>PRC总字节数</th><th>RPC中日志目录条数</th></tr></thead><tbody><tr><td>3.1</td><td>3</td><td>60</td><td>15190</td><td>0</td></tr></tbody></table><h3 id="日志提交一致性"><a href="#日志提交一致性" class="headerlink" title="日志提交一致性"></a>日志提交一致性</h3><p>leader知道有log entry到达majority servers，他就会commit这个log。</p><p>有特殊情况是达到了majority servers但还没commit的leader crash，所以不通过判断majority servers来判断是不是该commit，因为就算达到了majority server之后的leader可能还会全部覆盖。Raft采用只有的currentTerm的leaders的logs被提交，因为选主过程中的<strong>Log Matching Property</strong>原则就已经保证了选出的leader在整个集群中日志的完整性。</p><h4 id="applier日志"><a href="#applier日志" class="headerlink" title="applier日志"></a>applier日志</h4><ol><li>如果上任leader在提交日志之前宕机，下一任 leader将尝试完成日志的复制。这时候，如果有rf.logs[%v].Term: %v !&#x3D; rf.currentTerm的情况，因为新的leader不能准确判断这个log是不是已经提交，就不能去提交这个log，也就是只提交当前term的日志；</li><li>如果在上个term残留的日志后面有新的日志满足提交的条件，因为<strong>Log Matching Property</strong>已经保证了在此之前的日志都是一致性的，那就会把新日志之前的所有log都保证提交，顺便也提交了之前的term残留的log。</li></ol><h3 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h3><ol><li>考虑修改server的状态变量的时候一定要上锁，</li><li>在可能需要wait的操作不要上锁：channel的读写，等待timer，sleep()，发送RPC ，重传RPC（已经删除）</li><li>先考虑大粒度的锁，不要提前优化，不过大粒度的锁也要考虑死锁问题</li></ol><p>Log Matching Property：</p><ol><li>如果两个日志的两条日志记录有相同的索引和任期，那么这两条日志记录中的命令必然也是相同的。</li><li>如果两个日志的两条日志记录有相同的索引和任期，那么这两个日志中的前继日志记录也是相同的</li></ol><h3 id="2B-bug记录"><a href="#2B-bug记录" class="headerlink" title="2B-bug记录"></a>2B-bug记录</h3><ol><li>append RPC 追加日志成功后重发还是发了日志片段，可能是nextIndex还没改过来就发下一次RPC了：目前推测发的是心跳，也就是所谓的过时RPC<ul><li>已经解决，心跳发空的日志 </li><li>4.26 改成心跳不能空日志， 把 start()的RPC发送取消，交给心跳</li></ul></li><li>旧leader拿到新的log后回来，新leader以为他的nextIndex比实际的小1，而且新leader没有收到新的log所以发的只是心跳。这时候心跳检查, 可以让旧的leaders下台成为follower，log的长度匹配一样，但是因为nextIndex比实际的小1,检查的是前一个，index和term是匹配的，之后准备要把和leader所有不一致的删除，缺失的补上，但是因为是心跳，发过来的entry是空的。<ul><li>目前解决方案，已经改为心跳和普通同步一致，也就是也包含日志并且把 start() 的提交去掉，等待心跳提交，来减少RPC的超发，因为心跳很密集，同步比较快</li></ul></li><li>student guide ：如果选举超时，没有收到现任领导的AppendEntries RPC，也没有向候选人授予投票权：转换为候选人。和我的处理不一样，可能会选举比较慢</li></ol><h3 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h3><ol><li>leaderCommit() 的提交log需要检查和当前的term是否一致，如果一致则提交，如果不一致不管。</li><li>当leader提交新的log，那么之前的log间接提交，因为 log Matching Property</li></ol><p>难改的测试： Figure8C leader commit判断通过之后，还没有applier就断了或者applier了之后断了，这样一千次</p><ol><li>因为persist只保存voteFor 、 log 、 currentTerm，所以commitIndex和 lastAppliyIndex在重启的时候还是0，那之前提交过的log现在还需要重头开始重新提交一遍</li><li>日志同步的第一次retry没有成功，没有进行下一次retry，很奇怪。应该是死锁，注意锁起来的函数递归调用可能会死锁<br>改为 日志同步RPC不 retry，修改nextIndex交给下一次心跳同步</li></ol><ul><li>vote for：投票情况，因为需要保证每轮term每个server只能投票一次</li><li>log：崩溃前的log记录，<strong>因为我们需要保证(promise)已发生的(commit)不会被回退</strong>。否则崩溃重启后，可能发生一些奇怪的事情，比如client先前的请求又重新生效一次，导致某个K&#x2F;V被覆盖成旧值之类的。（例如，leader的宕机重启，logs如果没有保存而丢失的话，重新请求一致性的log，相同的index可能会产生不同的logs，而旧的log如果已经apply了，那可能会破坏一致性）</li><li>current term：崩溃前的当前term值。因为选举(election)需要用到，用于投票和拉票流程，并且<strong>需要保证单调递增</strong>(monotonic increasing)</li><li>lastIncludedIndex: 奔溃前的快照保存的最后一个log的index，到这个log位置都是保存在快照中的，也就是状态机的持久化数据，如果崩溃后重启就不用交这个log之前的log了，因为上层可以直接读取整个快照。</li><li>lasIncludedIndex: 奔溃前的快照保存的最后一个log的term</li></ul><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>用于日志压缩，快照之后，存储当前的状态，那么这个点之前的日志就可以删除。</p><p><img src="D:\MyTxt\typoraPhoto\image-20230504201733607.png" alt="image-20230504201733607"></p><p>一般机器单独的进行快照，除非有一个很慢或者新加入的follower需要leader网络发送快照来使其快速追赶</p><p>InstallSnapshot RPC</p><p>leader发送快照RPC，followers来决定使用；</p><ol><li>如果快照包含新信息超过follower的logs, 那会完全选择快照覆盖和logs删减；</li><li>如果快照比follower的logs短，那prefix覆盖，之后的保留</li></ol><p><strong>快照和一致性的冲突的</strong>：虽然违背了只有leader修改logs的强领导原则，但是快照的时候一致性已经达成了，所以没有决定是冲突的，数据流还是leader流向follower</p><p>快照的时机：确定日志总量达到一个阈值进行快照</p><h3 id="InstallSnapshot-RPC"><a href="#InstallSnapshot-RPC" class="headerlink" title="InstallSnapshot RPC"></a>InstallSnapshot RPC</h3><ol><li><p>快照RPC发送的时机：</p><p>落后较多的follower在同步日志的catchup过程中，leader回退自己的Log，到起点无法回退，这很好leader发送快照给FollowerFollower，之后通过AppendEntries将后面的Log发给FollowerAppendEntries将后面的Log发给Follower</p></li><li><p>之前的log没有applier怎么办，直接把快照包装成ApplyMsg，传到applyCh由上层raft处理</p></li><li><p>日志发送的是到lastIncludedindex位置的前面的全部，没有按照论文所说的实现偏移量</p></li></ol><h3 id="压缩后修改index"><a href="#压缩后修改index" class="headerlink" title="压缩后修改index"></a>压缩后修改index</h3><p>因为压缩之后logs数组的下标就不是index了，需要大改。。。</p><ol><li><p>lastLog的index可能变成了以一个dummy节点，index &#x3D;0，需要改成nextIncludedIndex，因为在选举的时候需要判断</p></li><li><p>nextIndex 等等也需要改</p></li><li><p>添加一个接口，然后一个个测，改掉所有的下标</p><p>func (rf *Raft) GetRealLastLogIndex() int {</p><p>  return Max(rf.logs[len(rf.logs)-1].Index, rf.LastIncludedIndex)</p><p>}</p></li></ol><h3 id="2d-快照bug"><a href="#2d-快照bug" class="headerlink" title="2d-快照bug"></a>2d-快照bug</h3><ol><li><p>先写所有server的快照功能，需要大改下标，主要是加了rf.GetRealLastLogIndex()函数</p></li><li><p>快照之后，上一次append还没发出去的Entry会被部分覆盖，也就是说在go程去append 的时候args被其他线程修改了</p></li></ol><p>这个bug改了好久，并发的问题，因为之前args.Entry的创建直接用数组切片初始化Entries:    rf.logs[nextindex-rf.LastIncludedIndex:]，可能编译器折叠args.Entry为切片的表达式，也就是并发过程中切片本身变化可能会导致args.Entry的变化？？</p><p>之后改成了make空间，然后用copy(args.Entries, rf.logs[nextindex-rf.LastIncludedIndex:])赋值，bug解决</p><ol start="3"><li>crash后恢复的server需要把之前的log重新应用到状态机（这里重新应用logs应该采用提交快照应用），否则直接往后提交新追加的logs是无法提交的，因为lastApplied没有持久化是恢复的时候是0，用日志applier的方式会从log1开始交，但是lastIncludedindex之前的log已经被快照剪短了。</li></ol><p>改成make的时候lastApplied和commitIndex都初始化为lastIncludedindex，但是这时候也可能会出现直接提交新的log，而没有实现重新应用之前的log到状态机。这里测试能通过，不清楚什么原因？？？？可能是之前的状态也持久化了？</p><p>真正的原因是在2D之后已经<strong>持久化了快照</strong>，那服务器重启的时候<strong>上层状态机就可以直接读取硬盘中存储的快照</strong>（之前的logs的总和操作），对于重启的server只需要继续添加之后的log就可以了。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>因为持久化的操作在实际过程中是读写硬盘，比较花时间，实验原本给的persist.save()接口只能同时修改state和snapshot，之前在只修改state情况下采用的是保存一遍自己原本的snapshot。<br>现在添加persist.saveStateonly()接口，去掉了没有新快照的时候重复读取自己的快照的操作</li></ol><h3 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h3><ol><li>全部案例一般用时realt time460-470s, CPU时间 2.8s；加上-race 是八分4，CPU时间28s。</li><li>没有竞争的全套实验2测试(2A+2B+2C+2D)所需的合理时间是6分钟的实时时间和1分钟的CPU时间。当使用-race运行时，它大约是10分钟的实时时间和2分钟的CPU时间</li><li>主要是backup比知道是慢10s，2D不稳定</li></ol><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>文件夹有原来关联的仓库，git push不到自己的仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">//</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:forthdifferential/6.824.git</span><br><span class="line">git add .</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push</span><br><span class="line">fatal: 当前分支 master 没有对应的上游分支。</span><br><span class="line">为推送当前分支并建立与远程上游的跟踪，使用</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin master</span><br><span class="line"></span><br><span class="line">klchen@vmware:~/project/MIT6.824$ git push -u origin main</span><br><span class="line">error: 源引用规格 main 没有匹配</span><br><span class="line">error: 无法推送一些引用到 &#x27;git@github.com:forthdifferential/6.824.git&#x27;</span><br><span class="line">klchen@vmware:~/project/MIT6.824$ git branch</span><br><span class="line">* master</span><br><span class="line">klchen@vmware:~/project/MIT6.824$ git push --set-upstream origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这之后上传的文件夹有个箭头，打不开，主要是因为链接了其他的仓库，也就是子文件夹中存在<code>.git</code>文件，导致冲突</p><p>解决方法： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 找到存在的.git文件然后删除，rm .git -r</span><br><span class="line">2. git rm --cached [该文件夹名] git rm --cached 6.5840/</span><br><span class="line">3. 重新执行git add .</span><br><span class="line">4. 执行 git commit -m &quot;rm old_git&quot;</span><br><span class="line">5. 执行git push origin [branch name]  git push</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>raft集群一般是3 5 个，单数防止脑裂，一个服务器损坏的平均情况大概是几个月一次，所以3 5 个足够修复恢复了</li><li>服务器遇到的问题会有网络分区联系不上、机器故障挂了等</li></ol><p>有空看看Paxos，因为这是最经典的一致性算法</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>关于历史记录的定义，而不是关于系统的定义，也就是说这个系统对外界的请求表现出的是线性一致性。</p><p>计算机执行的序列，同时满足一下两个，就说明请求历史数据是线性的</p><ol><li><p>序列中的请求的顺序与实际时间匹配</p></li><li><p>每个读请求看到的都是序列中前一个写请求写入的值</p></li></ol><p>反之，如果序列的规则生成了一个带环的图，那么请求历史数据不是线性一致性的。</p><p><strong>重点是说</strong>：1. 对于系统执行写请求，只能有一个顺序，所有客户端读到的数据的顺序，必须与系统执行写请求的顺序一致。</p><ol start="2"><li>对于读请求不允许返回旧的数据，只能返回最新的数据。或者说，对于读请求，线性一致系统只能返回最近一次完成的写请求写入的值。</li></ol><p>这点在分布式系统中，不容易保证，因为副本很多，而在单个服务器的情况下天然保证。</p><ul><li>一个符合线性一致性但是看起来回复不一致的情况：</li></ul><p>客户端请求后一直没收到回复，重新发送请求，可能会受到上一次处理的结果，而不是最新的结果。<br>可能的原因是如果这是因为第一次系统执行完毕了并返回了，而响应故障或者回复报文网络丢包了，系统建立一个表存储为此客户端处理过的结果。</p><h3 id="Zookeeper介绍"><a href="#Zookeeper介绍" class="headerlink" title="Zookeeper介绍"></a>Zookeeper介绍</h3><p>Raft实际上就是一个库。你可以在一些更大的多副本系统中使用Raft库。但是Raft不是一个你可以直接交互的独立的服务，你必须要设计你自己的应用程序来与Raft库交互。</p><p>Zookeeper看成一个类似于Raft的多副本系统，运行在Zab（和Raft一样）之上。</p><p>为了提高系统的性能，需要把除了leader外的服务器用起来，但是线性一致性的要求表示只能通过leader交互，因为不能保证follower的日志是up-to-date。Zookeeper 的做法是不保证线性一致性，把读操作分摊给所有的peer处理，这说明请求一些落后的副本的时候可能会读取到一些旧的数据。</p><h3 id="Zookeeper的一致性保证"><a href="#Zookeeper的一致性保证" class="headerlink" title="Zookeeper的一致性保证"></a>Zookeeper的一致性保证</h3><ol><li>保证写请求是线性一致性的，也就是执行是按照一致性的顺序；但是读一致性不考虑，不需要经过leader，可能会返回旧数据</li><li>任何一个客户端的请求都会按照顺序执行（通常是看系统不一定会顺序执行的），FIFO，可能的实现是为所有请求打上编号，然后leader节点遵从这个顺序。</li></ol><p>FIFO的实现注意：</p><ol><li>如果客户端在一个S读取，这个S挂了，切换到下一个S的时候，那从下一个S读取的数据必须要在上一次读取数据的log的后面。 也就是说第二个读请求至少要看到第一个读请求的状态！</li></ol><p>​  如果在这个位置的log之前，那新的S会阻塞客户端的响应或者告诉他找其他的S试试。</p><ol start="2"><li>对于单个的客户端，因为FIFO的要求，所以读写的线性一致性实际上能保证。比如一个写一个读，写给leader 17，读给了follower读，要阻塞到写完17才能读到17 ，不然客户端收到的回复很奇怪。</li></ol><h3 id="Zookeeper的同步操作-（sync）"><a href="#Zookeeper的同步操作-（sync）" class="headerlink" title="Zookeeper的同步操作 （sync）"></a>Zookeeper的同步操作 （sync）</h3><p>弥补非严格线性一致的方法是设计了一个操作类型是sync，效果相当于写请求。</p><p>如果我需要读最新的数据，我需要发送一个sync请求，之后再发送读请求。这个读请求可以保证看到sync对应的状态，所以可以合理的认为是最新的。但是同时也要认识到，这是一个代价很高的操作，因为我们现在将一个廉价的读操作转换成了一个耗费Leader时间的sync操作</p><h3 id="Zookeeper应用场景"><a href="#Zookeeper应用场景" class="headerlink" title="Zookeeper应用场景"></a>Zookeeper应用场景</h3><p>如果你有一个大的数据中心，并且在数据中心内运行各种东西，比如说Web服务器，存储系统，MapReduce等等。你或许会想要再运行一个包含了5个或者7个副本的Zookeeper集群，因为它可以用在很多场景下。之后，你可以部署各种各样的服务，并且在设计中，让这些服务存储一些关键的状态到你的全局的Zookeeper集群中。</p><h3 id="Zookeeper中watch通知"><a href="#Zookeeper中watch通知" class="headerlink" title="Zookeeper中watch通知"></a>Zookeeper中watch通知</h3><p>大体上讲 ZooKeeper 实现的方式是通过客服端和服务端分别创建有观察者的信息列表。客户端调用 getData、exist 等接口时，首先将对应的 Watch 事件放到本地的 ZKWatchManager 中进行管理。服务端在接收到客户端的请求后根据请求类型判断是否含有 Watch 事件，并将对应事件放到 WatchManager 中进行管理。</p><p>在事件触发的时候服务端通过节点的路径信息查询相应的 Watch 事件通知给客户端，客户端在接收到通知后，首先查询本地的 ZKWatchManager 获得对应的 Watch 信息处理回调操作。这种设计不但实现了一个分布式环境下的观察者模式，而且通过将客户端和服务端各自处理 Watch 事件所需要的额外信息分别保存在两端，减少彼此通信的内容。大大提升了服务的处理性能。</p><p>需要注意的是客户端的 Watcher 机制是一次性的，触发后就会被删除。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Znode类型</p><ul><li>regular：常规节点，它的容错复制了所有的东西</li><li>ephemeral：临时节点，节点会自动消失。比如session消失或Znode有段时间没有传递heartbeat，则Zookeeper认为这个Znode到期，随后自动删除这个Znode节点</li><li>sequential：顺序节点，它的名字和它的version有关，是在特定的znode下创建的，这些子节点在名字中带有序列号，且节点们按照序列号排序（序号递增）。</li></ul><p>一些API用RPC调用暴露</p><h3 id="Ready-file-znode"><a href="#Ready-file-znode" class="headerlink" title="Ready file(znode)"></a>Ready file(znode)</h3><p>Master节点在Zookeeper中维护了一个配置，这个配置对应了一些file（也就是znode）。通过这个配置，描述了有关分布式系统的一些信息，例如所有worker的IP地址，或者当前谁是Master。所以，现在Master在更新这个配置，同时，或许有大量的客户端需要读取相应的配置，并且需要发现配置的每一次变化 。</p><p>尽管配置被分割成了多个file，还需要保证有原子效果的更新：</p><p>如果Ready file存在，那么允许读这个配置。如果Ready file不存在，那么说明配置正在更新过程中，我们不应该读取配置。所以，如果Master要更新配置，那么第一件事情是删除Ready file。之后它会更新各个保存了配置的Zookeeper file（也就是znode），这里或许有很多的file。当所有组成配置的file都更新完成之后，Master会再次创建Ready file。</p><h3 id="Zookeeper实现计数器"><a href="#Zookeeper实现计数器" class="headerlink" title="Zookeeper实现计数器"></a>Zookeeper实现计数器</h3><p>处理并发的客户端请求，不能用单纯的读写数据库的方式，而且Zookeeper本身可能返回旧值，这也要考虑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">X, V = GETDATA(&quot;F&quot;)</span><br><span class="line">IF SETDATA(&quot;f&quot;, X + 1, V): // leader节点执行 ，要求读到最新的数据且版本号还没被修改</span><br><span class="line">    BREAK</span><br></pre></td></tr></table></figure><p>方式是min-transaction，mini版的事务的实现，把读-更改-写作为一个原子操作</p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p>FT-kv存储，是复制状态机；</p><p>clien向k&#x2F;v service发送三个RPC：Put Append Get，其中是Clerk 与 Client交互，Clerk通过RPC与servers交互。</p><p>Get&#x2F;Put&#x2F;Append 方法需要是线性的，对外表现是一致的，我理解就是说并发情况下 对外表现的线性一致性：</p><p>后一次请求必须看到前一次的执行后端状态；并发请求选择相同的执行顺序，避免不是最新状态回复客户端；在故障之后保留所有确认的客户端更新的方式恢复状态</p><h3 id="3A-Key-x2F-value-service-without-snapshots"><a href="#3A-Key-x2F-value-service-without-snapshots" class="headerlink" title="3A-Key&#x2F;value service without snapshots"></a>3A-Key&#x2F;value service without snapshots</h3><p>每个kv service有一个raft peer，Clerks把Get&#x2F;Put&#x2F;Append  RPC发送给leader的kv service，进一步交给Raft，Raft日志保存这些操作，所有的kv service按顺序执行这些操作，应用到kv数据库，达到一致性</p><ol><li>Clerk找leader所在kv service和重试RPC的过程；</li><li>应用到状态机后leader通过响应RPC告知Clerk结果，如果操作失败（比如leader更换），报告错误，让他重试</li><li>kv service之间不能通信，只有raft peer之间RPC交互</li></ol><h3 id="构思："><a href="#构思：" class="headerlink" title="构思："></a>构思：</h3><p>主要过程： Clerk把操作包装Op发送 PRC给 所有server，如果server是leader就开始发给raft，raft同步完成后apply给server，server执行这个Op,返回给Clerk结果。</p><p>如果raft的applier超时，RPC回复超时，因为是旧leader，所以等到下一个term再发送RPC给新leader的server。</p><h3 id="重复RPC检测"><a href="#重复RPC检测" class="headerlink" title="重复RPC检测"></a>重复RPC检测</h3><p>如果收不到RPC回复（no reply）,一种可能是server挂了，可能换一个重新请求；但是另一种是执行了但是 reply丢包了，这时候重新发的话会破坏线性一致性。 </p><p>解决方案是重复RPC检测：</p><p>clerk每次发RPC都发一个ID，一个Request一个ID，重发相同；在server中维护一个表记录ID对应的结果，提前检测是否处理过；Raft的日志中也要存这个ID，以便新的leader的表是正确的</p><p>如果之前的请求还没执行，那会重新start一个，然后等第一个执行完后表就有了，applCh得到第二个的时候看表再决定不执行了。也就是有两个一样的log 没关系的</p><h3 id="请求表的设计"><a href="#请求表的设计" class="headerlink" title="请求表的设计"></a>请求表的设计</h3><p>每个客户端一个条目，存着最后一次执行的RPC：</p><p>每个client同时只有一个未完成的RPC，每个client对PRC进行编号；也就是说当客户端发送第10的条目，那之前的都可以不要，因为之前的RPC都不会重发了；</p><p>执行完成后才更新条目，index是clientID，值是保留值和编号，</p><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>每个client有一个clientID，是一个64位的随机值 </p><p>client发送PRC中有 clientID 和 rpcID ，重发的RPC序号相同</p><p>如果执行完被leaderID索引，内容仅包含序号和值</p><p>RPC处理程序首先检查表格，只有在序号&gt;表格条目时才Start()s</p><p>每个日志条目必须包括客户端ID、序号</p><p>当操作出现在applyCH上时，更新client’s table entry中的序号和值，唤醒正在等待的RPC处理程序(如果有)</p><h3 id="3A-bug"><a href="#3A-bug" class="headerlink" title="3A-bug"></a>3A-bug</h3><ol><li><p>一个clerk就是一个client调用的，所以clientId应该在clerk结构里，之前我是 每个请求随机生成了一个clientId，这是不太合理的</p></li><li><p>处理RPC超时不是 !ok表示的，应该要自己设置时间。本来使用的是条件变量等着表的更新，但是用select chanl可以用非阻塞处理处理不同的通道，而且可以直接传递变量，不需要重新查表了。 原代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">reply.Success, reply.Err = <span class="literal">false</span>, <span class="string">&quot;not leader&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> !kv.<span class="built_in">killed</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> equset_entry, ok := kv.requsetTab[args.ClientID]; ok &#123;</span><br><span class="line"><span class="keyword">if</span> args.RpcID &lt;= equset_entry.rpcID &#123;</span><br><span class="line"><span class="comment">// 已经执行RPC请求</span></span><br><span class="line">reply.Success, reply.Value = <span class="literal">true</span>, equset_entry.value</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">DPrintf</span>(<span class="string">&quot;SERVER &#123;server %v&#125;等待一致性通过,Optype: Get,ClientID: %v,RpcID: %v,Key %v&quot;</span>, kv.me, args.ClientID, args.RpcID, args.Key)</span><br><span class="line">kv.receiveVCond.<span class="built_in">Wait</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器控制RPC超时 ，chanl传入处理完的数据</p><p>疑问：定时器应该是一个函数一个还是放到server结构里，chanl也是一个函数一个，那开销好像比较大</p><p>用 map[int]chan int处理 对应不同的index，提交时到对应chan中，index的唯一性。</p><p>考虑添加chan和删除，delete(kv.chanMap, 1)   删除键为1的元素，自动销毁chan，考虑请求满足之后就会删除，同时存在chan也不多，先采用这种方案</p></li><li><p>设计是定时器在server中，那server如果挂了，也是没有reply，不返回了，这种情况怎么解决？</p></li></ol><p>这是服务器的问题，不是raft一致性没有达到，应该是RPC会返回false。</p><ol start="4"><li><p>看起来client认为的server编号和server自己编号不一致，把前者不打出log以免出错</p><p>问题还有是重复检测发生在检查leader之前了，那可能不是leader但因为同步执行到了，也能返回，然后client更新了错误的leader。</p><p>修改了原来的结构，改为先检查leader，然后重复检测，然后再start</p></li><li><p><strong>难改bug</strong>TestSpeed3A 要求每个心跳周期至少处理三次client的请求，但是我的raft中，start收到新条目不会马上同步，而是等下一次心跳来同步。这个TestSpeed3A 是同一个客户端发送一千次append，RPC接受函数阻塞在那直到apply后回复，而我每次都是一个心跳处理一次，就会导致一个心跳周期值处理一个请求。</p></li></ol><p>​具体表现是：rpc一致性通过，执行完成，返回通道的时候超时了，然后一直重复超时</p><p>先改为start( )之后就发起心跳，试试</p><p>server处理操作的PRC超时时间设置有点不清楚，改到800ms这样大可以减小TestSpeed3A 不通过的概率，但是跑多了还是会有个错误。只可能原因是高并发多请求的时候apply处理不过来了</p><p>5.2 这中间还有一个bug，就是raft一致性达成了而且apply了太快了，通道还没make。那就不传这个通道，等超时返回，并在下一次RPC的重复检验的时候直接取到值</p><ol start="6"><li>applCh拿到后发现表中已经有rpc，没有执行也没有返回，导致RPC得不到回复。</li></ol><p>正确的做法是不执行，但是要返回值。查看rpc通道还存不存在，如果存在，说明上一次没有回复rpc（可能是上次chanl还没创建好）；如果不存在，说明这个条目是重复的条目，不需要返回RPC了</p><ol start="7"><li>好看点的写法是函数中间需要加锁的部分单独移出去做新函数，不然很丑而且容易忘记解锁</li><li><strong>严重bug</strong> - leader的applyCh读取不到数据了，导致一直超时，一直操作不了数据库。</li></ol><p>原来是raft日志同步有问题，也就是在start后立即发起心跳引起的。</p><p>也就是修改后导致添加了额外的心跳，那在发送心跳的过程中snapshot了，会导致preLogIndex比follower的lastIncludeIndex还要小，这种情况我提前考虑，然后返回xindex为realLastlogIndex</p><ol start="9"><li><em><strong>改好久bug</strong></em>leader 提交raft后没有达成了一致性但是没有apply上来，反倒是其余follower都apply上来了。</li></ol><p>检查了一圈，问题应该是raft在同步完成后，leader检查可否更改commitIndex，如果通过更改commintIndex，那会用条件变量唤醒apply，但是实际上到这一步后没有成功唤醒apply。</p><p>原因是rf.applyVCond.Broadcast()唤醒不了在另一个go程上的applier，这种情况发送的不多，但是每次发送都是永远提交不上，原因也不知道。</p><p>我猜有一种可能是Broadcast()的时候，那个线程不在wait。所以把commitLeader()中唤醒的操作放到从之前的 每次增加commit唤醒 改到 函数最后再唤醒，这样减少applier压力。但是这样TestSpeed有时候过不了，还是改回原来，考虑其他优化</p><p>考虑没有进入wait状态就阻塞的原因，去找阻塞再哪一句，发现在写入chan的时候阻塞了。有可能是server一直在读导致的异常阻塞，把server改成select非阻塞读取。</p><p>另外chan写端阻塞可能是缓冲区的为0是非缓冲的（同步的），也就是只有读写双方都准备好了才可以进行，否则就一直阻塞。我把applyCh和map中的chan改为缓冲区是1，但是这只是缓兵之计，如果缓存超出，写端还是会阻塞</p><p>仔细想了下应该不是这个问题，可能是读端没读，还在跑之后的代码。</p><h3 id="3B-Key-x2F-value-service-with-snapshots"><a href="#3B-Key-x2F-value-service-with-snapshots" class="headerlink" title="3B-Key&#x2F;value service with snapshots"></a>3B-Key&#x2F;value service with snapshots</h3><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><p>测试程序将MaxraftState传递给您的StartKVServer()。</p><p>MaxraftState指示持久RAFT状态允许的最大大小(以字节为单位)(包括日志，但不包括快照)。**将MaxraftState与Persister.RaftStateSize()**进行比较。当您的键&#x2F;值服务器检测到RAFT状态大小接近此阈值时，它应该通过调用RAFT的Snapshot来保存快照。</p><p>如果MaxraftState为-1，则不必创建快照。</p><p>MaxraftState应用于RAFT作为第一个参数传递给Persister.Save()的GOB编码的字节。</p><p>server重启的时候，从persister读取快照并且恢复</p><ol><li>快照需要存储的信息和快照的时机考虑清楚，kvserver的重复检验必须跨越检查点，所以任何状态必须包含在快照中。可能快照需要请求表因为一恢复就要启动重复检验的功能，应该是需要保存kv数据库，也就是状态机的状态</li><li>快照中数据大写</li><li>raft可能被改错，记得常回看看</li></ol><h3 id="构思：-1"><a href="#构思：-1" class="headerlink" title="构思："></a>构思：</h3><h4 id="快照时机："><a href="#快照时机：" class="headerlink" title="快照时机："></a>快照时机：</h4><p>考虑server和raft交互的时候，考虑server状态机和raft日志改变的时候。</p><p>在raft通过applyCh提交给server的时候，检查是否快照。快照的时候设置这个index之前，所以在应用状态机之前检查快照</p><h4 id="快照操作："><a href="#快照操作：" class="headerlink" title="快照操作："></a>快照操作：</h4><ol><li>检查stateSize，如果超出就做快照。</li><li>server做快照，需要保存数据库和请求表snapshot，保存index（因为之后还要传给让raft，且applyCh可能接受快照的，那时候需要比较快照的latest性）。然后把snapshot和index传给raft做快照，也就是保存raftstate</li><li>恢复操作，server恢复状态机、请求表，raft恢复state</li><li>appCh可能会传条目，也可能传快照，分开处理。如果传的是快照，之前raftstate已经更新，判断快照合理性，应用快照。</li></ol><h3 id="3B-bug"><a href="#3B-bug" class="headerlink" title="3B-bug"></a>3B-bug</h3><ol><li>raft提交一个snapshot并被server应用之后，又提交了一个相同index的Op，但内容是nil</li></ol><p>原因的是server主动快照时在新applyCh传入条目的应用之前拍的，也就是传入快照函数的index是新条目的index-1而不是index </p><ol start="2"><li>落后较多raft接受到RPC快照同步的时候，没有成功。仔细看原因是applCh写入snapshot的时候阻塞了。</li><li>raft下标越界，可能原因是用chan的时候解锁，锁被抢走了，修改了lastIncludeIndex,当chan写完获取锁的时候，已经改变了raft的状态。</li></ol><p>对2 3bug的修改，主要是把安装快照的RPC中传给上层的chan放到最后处理，这时候PRC导致的状态更新已经完成了，chan放锁给其他的用来修改raft状态也没关系。</p><p>所以说chan不仅要记得解锁，还锁，而且要考虑在chan解锁期间发送的不确定性问题</p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>在本实验中，您将构建一个键&#x2F;值存储系统，该系统对一组副本组上的键进行“分片”或分区。分片是键&#x2F;值对的子集；例如，所有以“a”开头的键可能是一个分片，所有以“b”开头的键都是另一个分片，等等。分片的原因是性能。每个副本组仅处理几个分片的放置和获取，并且这些组并行操作；因此，总系统吞吐量（每单位时间的输入和获取）与组数成比例增加。</p><p>您的分片键&#x2F;值存储将有两个主要组件。首先，一组副本组。每个副本组负责分片的一个子集。副本由少数服务器组成，这些服务器使用 Raft 来复制组的分片。第二个组件是“分片控制器”。分片控制器决定哪个副本组应该为每个分片服务；此信息称为配置。配置随时间变化。</p><p>客户端咨询分片控制器以找到key的副本组，而副本组咨询控制器以找出要服务的分片。整个系统只有一个分片控制器，使用 Raft 作为容错服务实现。</p><p>分片存储系统必须能够在<strong>副本组之间转移分片</strong>。一个原因是一些组可能比其他组负载更多，因此需要移动分片来平衡负载。另一个原因是副本组可能会加入和离开系统：可能会添加新的副本组以增加容量，或者现有的副本组可能会因维修或退役而脱机。</p><p>本实验中的主要挑战将是<strong>处理重新配置——将分片分配给组的变化</strong>。在单个组内，所有组成员必须同意何时发生与客户端 Put&#x2F;Append&#x2F;Get 请求相关的重新配置。例如，Put 可能与重新配置同时到达，导致副本组不再对持有 Put 密钥的分片负责。组中的所有副本必须就 Put 是发生在重新配置之前还是之后达成一致。如果之前，Put 应该生效并且分片的新所有者将看到它的效果；如果之后，Put 将不会生效，客户端必须在新所有者处重新尝试。推荐的方法是让每个副本组使用 Raft 不仅记录 Puts、Appends 和 Gets 的顺序，还<strong>记录重新配置的顺序</strong>。您将需要确保在<strong>任何时候最多有一个副本组为每个分片的请求提供服务</strong></p><p>重新配置还需要副本组之间的交互。例如，在配置 10 中，组 G1 可能负责分片 S1。在配置 11 中，组 G2 可能负责分片 S1。在从 10 到 11 的重新配置期间，G1 和 G2 必须使用 RPC 将分片 S1 的内容（键&#x2F;值对）从 G1 移动到 G2。</p><blockquote><p>注意：只有RPC 可以用于客户端和服务器之间的交互。例如，您的服务器的不同实例不允许共享 Go 变量或文件。</p></blockquote><blockquote><p>注意：本实验使用“配置”来指代分片到副本组的分配。这与 Raft 集群成员变化不同。您不必实施 Raft 集群成员更改。</p></blockquote><p>本实验室的通用架构（一个配置服务和一组副本组）遵循与平面数据中心存储、BigTable、Spanner、FAWN、Apache HBase、Rosebud、Spinnaker 等相同的通用模式。不过，这些系统在许多细节上与本实验室不同，而且通常也更复杂、功能更强大。例如，实验室不会在每个 Raft 组中进化对等点集；它的数据和查询模型非常简单；分片的切换很慢，并且不允许并发客户端访问。</p><blockquote><p>注意：您的 Lab 4 分片服务器、Lab 4 分片控制器和 Lab 3 kvraft 必须全部使用相同的 Raft 实现。</p></blockquote><h3 id="4A-The-Shard-controller"><a href="#4A-The-Shard-controller" class="headerlink" title="4A-The Shard controller"></a>4A-The Shard controller</h3><p>shardctrler 管理一系列编号的配置。每个配置都描述了一组副本组和分片到 replica groups的分配方案。每当此分配需要更改时，分片控制器都会使用新分配方案创建新配置。 Key&#x2F;value clients and servers 在想要了解当前（或过去）配置时联系 shardctrler。</p><p>实现必须支持 shardctrler&#x2F;common.go 中描述的 RPC 接口，它由 Join 、 Leave 、 Move 和 Query RPC 组成。这些 RPC 旨在允许管理员（和测试）控制 shardctrler：添加新的副本组、删除副本组以及在副本组之间移动分片。</p><ol><li><p>管理员使用 Join RPC 添加新的副本组。它的参数是map，从唯一的非零副本组标识符 (GID) 映射服务器名称列表数组。shardctrler 应该通过<em>创建</em>一个<em>包含新副本组的新配置</em>来做出反应。新配置应尽可能将分片<strong>均匀</strong>地分配到整组组中，并应移动尽可能少的分片以实现该目标。如果 GID 不是当前配置的一部分，shardctrler 应该允许重新使用它（即 GID 应该被允许加入，然后离开，然后再次加入）。</p></li><li><p>Leave RPC 的参数是以前加入的组的 GID数组。shardctrler 应该创建一个不包括这些组的新配置，并分配这些组的切片到其余组。新配置应该在组之间尽可能均匀地划分分片，并且应该移动尽可能少的分片以实现该目标</p></li><li><p>Move RPC 的参数是分片编号和 GID。 shardctrler 应该创建一个新的配置，其中指定分片被分配给指定组。 Move 的目的是让我们测试您的软件。 Move 之后的 Join 或 Leave 可能会undo Move，因为 Join 和 Leave 会重新平衡。</p></li><li><p>Query RPC 的参数是一个配置号。 shardctrler 回复具有该编号的配置。如果数字是 -1 或大于最大的已知配置数字，shardctrler 应该回复最新的配置。 Query(-1) 的结果应该反映 shardctrler 在收到 Query(-1) RPC 之前完成处理的每个 Join 、 Leave 或 Move RPC。</p></li></ol><p><strong>第一个配置</strong>应该编号为零。它不应包含任何组，并且所有分片都应分配给 GID 零（无效的 GID）。下一个配置（为响应 Join RPC 而创建）应编号为 1, &amp;c。通常会有比组更多的分片（即，每个组将服务多个分片），以便可以以相当精细的粒度转移负载。</p><blockquote><p>您的任务是在 shardctrler&#x2F; 目录下的 client.go 和 server.go 中实现上面指定的接口。您的 shardctrler 必须是容错的，使用来自实验 2&#x2F;3 的 Raft 库。当您通过 shardctrler&#x2F; 中的所有测试时，您就完成了此任务。</p></blockquote><p>提示：从您的 kvraft 服务器的精简副本开始。</p><p>提示：您应该为<strong>分片控制器实现 RPC 的重复客户端请求检测</strong>。 shardctrler 测试不会对此进行测试，但 shardkv 测试稍后会在不可靠的网络上使用您的 shardctrler；如果您的 shardctrler 没有过滤掉重复的 RPC，您可能无法通过 shardkv 测试。</p><p>提示：执行分片重新平衡的状态机中的代码需要是确定性的。在 Go 中，map迭代顺序是不确定的。(索引需要按照一定顺序遍历，不用range map)</p><p>提示：Go maps are references. If you assign one variable of type map to another, both variables refer to the same map. 因此，如果你想基于之前的 Config 创建一个新的 Config，你需要创建一个新的map对象（使用 make() ）并单独复制键和值。</p><p>提示：Go race detector (go test -race) 可以帮助你找到错误。</p><h3 id="shardctrler"><a href="#shardctrler" class="headerlink" title="shardctrler"></a>shardctrler</h3><p>shardctrler的client负责对其的Group和配置发送读或改的RPC请求。</p><ol><li>和lab3B差不多，就是raft实现的分布式server实现RPC访问，包括重复检验功能，RPC超时返回</li></ol><p>初始分配，也就是confignum &#x3D;&#x3D;0 先考虑。</p><p>balance方法，输入一些副本组id（ []int），得到分配的情况（[NShards]int）</p><ol start="2"><li>新的map类型的Groups，先make，再按顺序存入原有gid对应的组，然后按顺序存入新的gid对用的组</li></ol><p>得到新的分配方案的方法，需要原来方案的移动少，以及新方案的分配快</p><ol start="3"><li>Leave RPC似乎只是测试用，所以先不做负载均衡重分配处理</li></ol><h3 id="servers-balance方案"><a href="#servers-balance方案" class="headerlink" title="servers balance方案"></a>servers balance方案</h3><ol><li><p>按照更新后的server组数计算平均数，以及余数，维护一个未分配的shards数组</p></li><li><p>首先对原方案做调整，向新平均数靠近，回收多出来的shards存到未分配的数组中：</p></li></ol><p>如果有余数，可以容许余数个Group的shard值是平均数+1，超出余数个后只能容许是平均数；</p><p>如果没有余数，只能容许所有的Group的shard值是平均值；</p><p>把以上两走情况结合，直接按照left&gt;0判断，容许范围是average还是average+1</p><ol start="3"><li>最后对没有达到average的server增添，直到未维护shard分配完成。</li></ol><p>因为之前以及保证了left个average+1的server，那么其他的server都是average个</p><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p>1.除非必要（超出平均数或平均数+1），否则不移除原有的切片</p><p>2.对于不够的平均数的server，添加新的切片,达到average</p><h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><ol><li>之前的设计没有控制<strong>left个数</strong>的Group的shard值是平均数+1，而是直接放到了平均数+1，会导致以下分配缺陷：</li></ol><p>对于不够的平均数的server，添加新的切片：</p><p>这时候可能会有个问题，就是在添加新切片的时候，未分配的shard的余量不够了，因为前面容许放到了平均数+1，可能出现对超出负载进行删减的过程中，没有删除任何平均数+1的server情况，那就没有未分配的shard给新的server。所以需要在删除的过程完成后，查看有没有剩下，如果没有剩下，就要删除到平均值，然后重新分配。但是这样修改之后会违背第一个性质，导致重分配浪费的情况。</p><p>修改为控制<strong>left个数</strong>的Group的shard值是平均数+1，代码设计时这对left变量修改即可</p><ol start="2"><li><p>— <strong>FAIL</strong>: TestMulti (0.63s)</p><p>  test_test.go:61: Shards wrong</p><p><strong>FAIL</strong></p><p>相同条件下配置需要时一模一样的，也就是gids数组是有一定排列顺序规则的。改为每次生成用于reBalance的gids后都sort以下</p></li></ol><h3 id="4B-Sharded-Key-x2F-Value-Server"><a href="#4B-Sharded-Key-x2F-Value-Server" class="headerlink" title="4B-Sharded Key&#x2F;Value Server"></a>4B-Sharded Key&#x2F;Value Server</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>每个 shardkv 服务器都作为副本组replica group的一部分运行。每个副本组为一些键空间分片提供 Get 、 Put 和 Append 操作。在 client.go 中使用 key2shard() 来查找密钥属于哪个分片。多个副本组合作为完整的分片集提供服务。 shardctrler 服务的<strong>单个实例</strong>将分片分配给副本组；当此分配发生变化时，副本组必须将分片传递给彼此，同时确保客户端不会看到不一致的响应。</p><p>您的存储系统必须为使用其客户端接口的应用程序提供<strong>线性一致</strong>的接口。也就是说，完成的应用程序调用 shardkv&#x2F;client.go 中的 Clerk.Get() 、 Clerk.Put() 和 Clerk.Append() 方法必须显示为以<strong>相同顺序影响所有副本</strong>。 Clerk.Get() 应该看到由最近的 Put &#x2F; Append 写入相同键的值，即使 Get和 Put与配置更改几乎同时到达。</p><p>只有当分片的 Raft 副本组中的<strong>大多数服务器都处于活动状态</strong>并且可以<strong>相互通信</strong>并且可以<strong>与大多数 shardctrler 服务器通信</strong>时，你的每个分片才需要取得进展。即使某些副本组中的少数服务器已死、暂时不可用或运行缓慢，您的实现也必须运行（服务请求并能够根据需要<strong>重新配置</strong>）。</p><p>一个 shardkv 服务器只是一个副本组的成员。给定某个副本组中的所有服务器永远不会改变（也就是一个raft集群为最小单位）。</p><p>我们为您提供 client.go 代码，该代码<strong>将每个 RPC 发送到负责 RPC 密钥的副本组</strong>。如果副本组表示它不负责这个key了，它会重试；在这种情况下，客户端代码向<strong>分片控制器请求最新配置并重试</strong>。作为<strong>处理重复客户端 RPC</strong> 支持的一部分，您必须修改 client.go，就像在 kvraft lab3中一样。</p><blockquote><p>注意：您的服务器不应调用分片控制器的 Join() 处理程序。测试人员将在适当的时候调用 Join()。</p></blockquote><blockquote><p><strong>Task</strong>: 您的首要任务是通过第一个 shardkv 测试。在此测试中，只有一个分片分配，因此您的代码应该与 Lab 3 服务器的代码非常相似。最大的修改是让您的服务器检测<strong>配置何时发生</strong>并开始接受其key与它现在拥有的分片匹配的请求。</p></blockquote><p>现在您的解决方案适用于静态分片情况，是时候解决配置更改问题了。您需要让您的服务器<strong>监视配置更改</strong>，并在检测到配置更改时启动分片迁移过程。如果一个副本组丢失了一个分片，它必须<strong>立即停止向该分片中的key提供请求</strong>，并<strong>开始将该分片的数据迁移到接管所有权的副本组</strong>。如果一个副本组获得一个分片，它需要<strong>等待让前任发送全部的数据给它，然后才能接受该分片相关的请求</strong></p><blockquote><p><strong>Task:<strong>在配置更改期间实施分片迁移。确保副本组中的所有服务器都在它们</strong>执行的操作序列中的同一点执行迁移</strong>，以便它们都接受或拒绝并发的客户端请求。&#x2F;&#x2F; raft一致性通过再转移。</p><p>在进行后面的测试之前，您应该专注于通过第二个测试（“加入然后离开”）。当您通过所有测试（但不包括 TestDelete ）时，您就完成了此任务。</p></blockquote><blockquote><p>注意：您的服务器需要<strong>定期轮询 shardctrler 以了解新配置</strong>。测试预计您的代码大约每 100 毫秒轮询一次；更频繁是可以的，但太少可能会导致问题。</p></blockquote><blockquote><p>注意<strong>：服务器需要相互发送 RPC，以便在配置更改期间传输分片</strong>。 shardctrler 的 Config 结构包含服务器名称，但您需要 labrpc.ClientEnd 才能发送 RPC。您应该使用传递给 StartServer() 的 make_end() 函数将服务器名称转换为 ClientEnd 。 shardkv&#x2F;client.go 包含执行此操作的代码。</p></blockquote><p>提示：将代码添加到 server.go 以定期从 shardctrler 获取最新配置，并添加代码以在接收组不负责客户端密钥的分片时拒绝客户端请求。您仍然应该通过第一个测试。</p><p>提示：您的服务器应该向客户端 RPC 响应 ErrWrongGroup 错误,如果服务器不负责这个key（即其分片未分配给服务器组的密钥）。确保您的 Get 、 Put 和 Append 处理程序在并发<strong>重新配置</strong>时做出正确的决定。</p><p>提示：按顺序一次处理<strong>一个</strong>重新配置。</p><p>提示：如果测试失败，请检查 gob 错误（例如“gob：type not registered for interface …”）。 Go 并不认为 gob 错误是致命的，尽管它们对实验室来说是致命的。</p><p>提示：您需要为跨分片移动的客户端请求提供至多一次语义（<strong>重复检测</strong>）。</p><p>提示：想想 shardkv 客户端和服务器应该如何处理 ErrWrongGroup 。如果客户端收到 ErrWrongGroup ，它是否应该更改序列号？如果服务器在执行 Get &#x2F; Put 请求时返回 ErrWrongGroup，是否应该更新客户端状态？</p><p>提示：服务器迁移到新配置后，它可以<strong>继续存储它不再拥有的分片</strong>（尽管这在真实系统中会令人遗憾）。这可能有助于简化您的服务器实现。</p><p>提示：当组 G1 在配置更改期间需要来自 G2 的分片时，G2 在处理日志条目期间的什么时候将分片发送到 G1 是否重要？</p><p>提示：您可以在 RPC 请求或回复中<strong>发送整个map</strong>，这可能有助于简化分片传输的代码。</p><p>提示：如果您的某个 RPC 处理程序在其回复中包含作为服务器状态一部分的map（例如键&#x2F;值map），您可能会因竞争而出现错误。 RPC 系统必须读取map才能将其发送给调用者，但它并没有持有覆盖map的锁。但是，您的服务器可能会在 RPC 系统读取它时继续修改同一个map。解决方案是让 <strong>RPC 处理程序在回复中包含map的副本</strong>。</p><p>提示：如果你在 Raft 日志条目中放置一个 a map or a slice ，你的键&#x2F;值服务器随后在 applyCh 上看到条目并在你的键&#x2F;值服务器的状态中保存对 a map or a slice 的引用，你可能有一个race。制作 map or slice 的副本，并将副本存储在键&#x2F;值服务器的状态中。race是在你的键&#x2F;值服务器修改 map&#x2F;slice 和 Raft 读取它同时持久化它的日志之间进行的。</p><p>提示：在配置更改期间，两个组可能需要在它们之间<strong>双向移动分片</strong>。如果您看到死锁，这就是一个可能的来源。</p><h3 id="构想"><a href="#构想" class="headerlink" title="构想"></a>构想</h3><p><img src="D:\MyTxt\typoraPhoto\image-20230529140159716.png" alt="image-20230529140159716"></p><h4 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h4><ul><li>什么时候修改配置</li></ul><ol><li>100ms轮询sk配置，判断是否需要求改配置和数据迁移。</li><li>配置每次只能+1的递增，且递增过程中产生数据迁移时不能修改配置。</li><li>按照顺序一次处理一个重新配置，raft一致性通过后修改配置</li></ol><ul><li>配置修改互相之间怎么交换分片？</li></ul><ol><li>建立一个新的RPC，处理groups之间的数据迁移</li><li>采取pulling的方式，如果需要就向目标gid拉取，如果不再负责，则设置为outState为true给出</li></ol><ul><li>修改配置是否需要raft一致性通过？</li></ul><ol><li>看Get请求，一开始就要判断这个分片是否处于当前的group，所以不是leader也需要知道是不可接受shard分片请求的情况，所以先设置raft一致通过后再修改配置，包括修改为不再负责</li></ol><h4 id="配置修改的Op"><a href="#配置修改的Op" class="headerlink" title="配置修改的Op"></a>配置修改的Op</h4><ul><li><p>还要考虑上述不是clientRPC操作（也就是处理配置shard）在raft实现后的<strong>重复检查</strong>吗？</p><p>那就不用请求表检查，用这个操作有没有已经在执行来判断</p></li><li><p>用什么命名配置修改相关的Op的管道？</p><p> 还是raft的index </p></li><li><p>配置修改的条目需要等待timeOut吗？</p><p>timeOut是为了client请求的时候有个raft网络分区卡在那里不能取得一致性，也就是不再是真正的leader了，所以client需要换一个server来重新发送RPC;</p><p>对于配置修改的Op，有可能这个raft也陷入网络分区，不再是leader就会导致一直卡着不能一致性后返回，所以还是得设置timeOut判断，timeOut之后不做为真正的leader，就不需要修改配置的操作了。等到下一次pollingConfig的goroutine判断为leader的server再重新请求配置</p><p>timeOut是对于RPC设置的，RPC是单个goroutine。那我的修改配置也是开单独的goroutine。那么我就不需要像RPC那样一定要返回重试，改为定时重试，就不需要goroutine等着返回了</p><p>所以完全不需要timeOut在内的返回通道</p></li><li><p>防止新配置应用之前添加更新的配置</p></li></ul><p>决定配置修改后，也就是start新配置之后，就不能再pollingConfig；在配置修改apply，pulling新的shard完成，就重新开始可以</p><p>start一个原配置+1的新配置，还没改任何东西，这时候换leader，那新leader拉取的也是原配置+1的新配置；如果不换leader，检查configChecker的时候不会添加新的配置；如果原配置+1的新配置apply之后，需要立刻修改InState和OutState,然后再应用curconfig为新的config，如果配置没有变则可以立即开始下一次config检查，如果配置变了，还需要去pull shard；如果pull shard完成，InState改回false。</p><p>OutState不用于防止新配置应用之前添加更新的配置，而是给出shard的时候用</p><p>TOOD 之后可能OutState还在删除旧配置的时候，用于防止新配置应用之前添加更新的配置</p><h4 id="配置修改和同步新shard的顺序"><a href="#配置修改和同步新shard的顺序" class="headerlink" title="配置修改和同步新shard的顺序"></a>配置修改和同步新shard的顺序</h4><p>同步新shard 肯定是在 配置修改同步完成并执行后来做的。 </p><p>同步完成修改InState为ture的shard就是需要向目标gid拉取的shard，检测到需要拉取在开始</p><ul><li>是不是不能在更新配置完成后再去开goroutine拉取，否则如果更新配置完成后就宕机，那恢复之后也用于不回去拉取这个shard。</li></ul><p>是，所以选择开一个新的groutine定期检查是否要拉取，这样重启后也能继续处理pullshard操作，而不会导致死锁。</p><p>这么做的依据是raft层的持久化保证了apply之后的条目是不会再修改或应用的（否则有可能一些旧值把新的修改了），也就是已经通过了，持久化后不需要再提交一次。导致不会进入pull shard的函数了</p><p>这里还要仔细想想raft持久化log和快照，恢复之后上层server具体是什么过程：</p><p>persist其实是raft层的定期保存，而snapshot是server层的定期保存。persist层更新更加频繁，为了保证一致性，而snapshot是为了server宕机重启后快速恢复保存的。</p><p>拿到num+1的配置，配置一致性通过，应用新配置，旧的等删，新的等拿到数据。</p><h4 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h4><ol><li><p>需要判断分片是不是在当前的gid中，如果不是先拒绝</p></li><li><p>如果处在分片迁移过程中，迁移发出方需要立刻停止对该分片请求的控制（一迁移就修改为拒绝），接受方在迁移完成整个分片前停止对该分片的控制（全部迁移完再修改）</p></li><li><p>重复检测的<strong>客户端请求也需要按照分片处理</strong>，因为数据迁移的时候，rpc的请求列表也是迁移的一部分，不然重复检测在迁移后起不到作用，相同的client的请求要重新开始记录。比如上一次是发给旧的group的请求，执行了但网络原因没有回复client，client重复请求的时候，当前向新的client发送请求，需要旧的server的请求表才能进行重复检测</p></li></ol><p>请求表分片的效果是：分片的数据和它的请求表是一体的</p><h4 id="Raft条目"><a href="#Raft条目" class="headerlink" title="Raft条目"></a>Raft条目</h4><ol><li>添加条目的之前检查分片管理，条目<strong>一致性通过的时候再次检查分片管理</strong></li></ol><p>如果一致性通过之后也需要判断分片管理情况，处理ErrWrongGroup的情况</p><ol start="2"><li>group之间的采用pulling方式RPC拉取，但是单个group中在leader拉取之后还需要同步给所有raft实体，所以Op包含的数据应该要多点</li></ol><p>包括<strong>配置开始更改，开始删除shard，开始接受shard</strong>都需要一致性通过。</p><p>问题：不能直接删除shard，因为可能需要的还没拿到shard，</p><h4 id="Group之间的Pull-shard"><a href="#Group之间的Pull-shard" class="headerlink" title="Group之间的Pull shard"></a>Group之间的Pull shard</h4><blockquote><p> 设置一个新的RPC互相交流，一直拉，直到拿到需要的shard并且一致化通过并应用</p></blockquote><ol><li><p>按照inState为true的shard的，逐个shard拿</p></li><li><p>leader先拿到shard，然后raft同步shard到组内取</p></li><li><p>一致性通过后，添加新的shard，修改inStats</p></li></ol><ul><li>PRC接受函数方</li></ul><ol><li>更新到互相交流的configNum一致时，才开始互相传递数据</li><li>决定发送回给拿的group，也需要一致性通过，通过后如果是leader回复需要的shard，然后删除整个shard的数据，做垃圾清理。还要加上重复检测，如果RPC回复出现失败但已经执行的话，用重复检测。</li></ol><p>被pullshard方的状态修改是需要一致性的，但是考虑了RPC返回时可能不成功，需要考虑重复请求，直到成功收到shard，应该有两种方案：</p><ol><li><p>PullShard RPC接受函数进行重复检验，并且添加入raft层，等待一致性满足后，用chan返回leaderRPC返回。</p></li><li><p>PullShard RPC接受函数被拉取后，不修改，直到RPC请求方真正拿到了shard后，再增加一个RPC来告诉接收方，我已经拿到了shard，可以把那个shard的状态改过来，并且需要加入到raft层，等通过后修改状态，并删除整个shard的数据。这还要考虑另一个RPC的返回情况。</p></li></ol><p>我选择1方案试试。方案1的重复检验比较麻烦，因为每次配置修改不仅拉取一次，按照分片拉取，而且增加了请求表，需要持久化和交换数据。</p><ul><li>修改每次配置拉取按照group来拉，一次拉一个group，这样重复检测就是按照修改一次配置的一个请求顺序。</li></ul><p>考虑一种情况，当被pull方的shard被拉去一次，raft一致通过后删除这个分片，但是因为网络原因RPC返回的时候断了，被shard已经被raft集群执行过了。对方没有收到需要的shard,下一次再来pullRPC的时候，重复检验，从请求表中读取这个shard的内容并且返回。如果这时候被pull方已经进入下一个配置，并且把这个shard删除，shard请求表也删除了,就不能实现重复的直接返回结果。这种情况，互相请求的请求表需要一直保存，纳入持久化</p><p>删除应该是要删除分片的数据，和分片的请求表，因为都发出去了。</p><blockquote><p>看了很多人用方案2，也就是明确拿到了再删除shard对于的数据，这样删的更干净点。</p></blockquote><ol><li><p>server在pullshard完成后，shard改为wait状态，等待告知exower删除整个分片</p></li><li><p>被pullshard后，shard状态先不改，保持out，因为还不能确定RPC发送方<strong>真正拿到了shard并且一致化通过并应用</strong>了,保持不能进入下一个config，等待删干净后进入下一个config check。</p></li></ol><blockquote><p>设置一个新的RPC，通知shard的ex-ower已经拿好并应用了，可以开始删除shard数据；</p><p>防止重启后不恢复RPC，开新线程来检测是否提醒ex-ower</p></blockquote><p>delshards RPC告知ex-ower开始删除shards的数据，等一致化通过，返回chan告知已经删除了再返回RPC。如果RPC返回的时候断了，那因为已经执行了Del操作，看到数据删除了，直接返回成功就行。</p><ul><li>这里和方案1的区别就是，执行了就直接返回OK，而方案1需要返回shard数据如果执行了，就只能一直卡着。</li></ul><blockquote><p>PullShards PRC 和 DelShards RPC的重复检测</p><ol><li><p>PullShards PRC：</p><p> args.NewConfigNum &gt; kv.curConfig.NumRPC 接收方还没有更新到这个配置，让请求方再等等重新请求</p><p> args.NewConfigNum &lt; kv.curConfig.Num 过时的RPC 舍弃这个RPC。因为被pull放只有 被通知可以删除整个shard后才会更新配置，所以被pull方配置更新则需求方已经拿到shard，说明只能是过时的RPC.</p></li><li><p>DelShards RPC：</p><p>因为DelShards RPC是类似于客户端请求，直接放到raft中，等apply后用chan回复。再次收到这个kv.curConfig更新不能保证接收方已经不在wait了。所以重复的RPC也需要返回OK（类似于客户端请求）。</p><p>考虑RPC失败的不确定性，就算回复是过时的RPC，也就是接收方已经删除了，发送方处理回复也需要添加一个Op到raft层。而是把Op的有效性判断，交给apply。</p><ul><li><p>什么会出现args.ConfigNum &gt; kv.curConfig.Num？</p><p>当G1宕机恢复的时候，正在走他曾经的人生，这时候curConfig比较小，其他在wait的server会发送最新的args.ConfigNum。这时候应该让其他server等一会，等G1归来之后，拉平ConfigNum，才能有效的接受RPC。</p></li></ul></li></ol></blockquote><h4 id="快照-1"><a href="#快照-1" class="headerlink" title="快照"></a>快照</h4><p>快照测试过不了，重启之后，config变回了0，考虑是不是调整快照保存的变量</p><p>快照需要保存的变量：</p><p>还需要存curConfig、oldConfig否则恢复起来很慢</p><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>5.28-改配置，想好怎么改 &#x2F;&#x2F;go kv.pollingConfig()开始设计</p><h4 id="重点关注的不确定"><a href="#重点关注的不确定" class="headerlink" title="重点关注的不确定"></a>重点关注的不确定</h4><p>configchanging的取消位置</p><h3 id="bug-1"><a href="#bug-1" class="headerlink" title="bug"></a>bug</h3><h5 id="5-30"><a href="#5-30" class="headerlink" title="5.30"></a>5.30</h5><ol><li><p>死锁，</p><ul><li>位置：leader提交新的config到raft层，一致化通过拿出后，应用新的config死锁。</li><li>表现：leader修改配置的函数拿不到锁，但是follower能拿到锁</li><li>解决：锁被configChecker()拿着，没有释放</li></ul></li><li><p>RPC发给了未知的服务器，</p><ul><li>原因：第一次修改配置的时候，不需要pullRPC；好像此后num&#x3D;2的时候还有这个问题，RPC发不出去</li><li>解决：RPC名称写错了。。。</li></ul></li><li><p>案例跑不停</p><p>配置修改后接受客户端的请求，还没有直接pull，是不是考虑用定时器，然后配置改完闹钟直接设置响起，直接拉取；</p><p>否则来不及直接接受客户端的请求会来不及；先不改</p></li><li><p>快照案例跑不停</p><ul><li>有的server拍摄快照之后，进度落后了，配置比别人慢就不能接受别人的pullshard请求。但是别人一直在发RPC请求pullshard，导致落后的server没空更新配置？？？</li><li>分析：inStates和outStates需要都处理完全后才可以进行下一个配置，否则进入下一个配置后，其他的server来pullshard，因为配置不一致就不能发给他，而且配置不能倒退，永远不能让他pull走这段shard</li><li>解决：添加outStates这部分的处理，在配置更改的时候改为需要被pull，控制不能修改config，被Pullshard拉走之后改为回来</li><li>这里有个隐患：如果拉取了，但是RPC回复的时候网络断了，想再拉取就不好拉了，因为可能配置已经更新到下一个了。解决的方法：记录RPC，然后进行重复检验，如果被拉过了，那就把拉的部分重新给。（还没改，先等bug来）</li><li>之后考虑，添加groups之间交流的RPC重复检验的功能</li></ul></li><li><p>诡异的bug，server一直在向自己pullshard，而且configNum落后很多，过去的自己一直在请求拉取现在的自己的部分shard，害怕。<br>可能oldConfig的时候没有加锁，导致混乱了<br>刚才再改这个诡异的bug被同学拍了一下，然后我直接吓死</p></li><li><p>pullshard的RPC设置为一直获取，直到拿到成功</p><ul><li>修改为返回Confignum不匹配就返回</li></ul></li></ol><h4 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h4><ol><li>修改groups之间传输分片为按照group传，可能一次穿多个分片，减少RPC发送；如果配置接收方配置还没跟上，先sleep100ms。</li><li>出现有的group的curConfigNum &#x3D; 0 的情况</li></ol><p>考虑一种情况，如果shardkvService跑一段时间后，配置比较高，有一个kvGroup1死了，过了一会然后重新恢复。在G1宕机的时候，G2和G3可能需要从G1去pull shards，所以配置更新不了，也接受不了部分客户端请求。在G1恢复的时候，如果想要整个service继续运行，G1配置应该和之前的G2和G3保持一致，或者最多落后一个config。但是，如果没有快照，或者快照比较落后，恢复的配置很低，那S1想要catch up需要从G2和G3中pull shard，但是他们已经删除了。</p><p>如果G1恢复，没有快照，config从头开始。但是raft层持久化了，所有的logs都被保存，raft层重启的时候commitIndex和lastApplied重置为0，重新执行所有之前的logs。这些logs中包含了配置更新，添加新的shard，删除shard，nowait等。</p><ul><li>恢复的效果：G1走过他的来时路，慢慢重新成为现在的他。</li><li>在这期间，三个独立goroutine的checker会往raft层加很多新的条目，再恢复期间加的这些条目都是无效的，因为index比较大，所以也不会对恢复过程产生不良影响。</li><li>直到正确返回客户端的请求后，就是他已经恢复完全了</li></ul><h4 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h4><ol start="3"><li><p>bug group宕机重启后，更新不了最新的配置，不能接受客户端请求</p><ul><li>分析： 101S2已经恢复 15726，猜测是正确处理完成测试了，考虑101S0。101的配置不是最新的，怎么没有更新新的配置？</li><li>一般情况，配置更改指令加入raft层后，修改configchanging &#x3D;1，当raft层执行完成后，应用这个条目修改配置，configchanging 再改回0。考虑一种情况，如果加入raft层后宕机了，重启的时候如果有快照恢复到快照的时刻，这时候configchanging 可能是1或者0。</li><li>重启恢复的时候，可能会放进去新的config，修改configchanging为1，但是这个新的config不会被应用，也就是configchanging的值一直是0。</li><li>问题一个是changing改为1后没有改过来0，    DPrintf(“[Gid:%v]{S%v} applyConfigChange失败recvOp.Config.Num[%v] !&#x3D; kv.curConfig.Num[%v]+1”, kv.gid, kv.me, recvOp.Config.Num, kv.curConfig.Num)</li></ul><p>[Gid:102]{S1} 重启的位置在10879，第一次卡住不让配置更新16156 </p><p>configchanging这个参数没有一致化通过，宕机或者换leader的时候会突变。去掉这个控制，正常raft层加入新的配置，但是在apply 的时候控制配置的更新。</p><p>configchanging删掉后bug解决。这个参数明显违背分布式原则。。。</p></li><li></li></ol><p>[Gid:100]{S2}等着pull from[Gid:101]{S2}，但是目标service一直没有更新到这个config</p><p>[Gid:102]{S0}一直拉[Gid100]，但是拉不到。[Gid100]换leader了，</p><ul><li><p>NoWaitShards添加到raft层的操作，有一两条不是leader存的？</p><p>可能失效的leader残留的发送RPC函数，增加判断leader操作以去掉</p></li></ul><ol><li><p>还没恢复如初收到RPC，返回NoWaitShards ErrConfigNumNotMatch</p></li><li><p>看起来有个group频繁的更换leader</p><p><code>[Gid:102]&#123;S0&#125; configChangeable Err,shardStates[9][In]</code></p></li></ol><p>​<code>[Gid:102]&#123;S2&#125; configChangeable Err,shardStates[9][In]</code></p><p>​<code>[Gid:102]&#123;S1&#125; configChangeable Err,shardStates[9][In]</code></p><p>可能是网络分区，都认为自己是leader，</p><p>恢复之后，有一个leader开始PullShards，向[Gid:100]{S1} 15358</p><p>[Gid:100]{S1}在拉取shardctrl配置的的时候newConfig.Num[0] &lt;&#x3D; curConfigNum[6]。为什么会请求一个0配置？</p><p>可能是shardctrl有问题传了个空的？</p><ul><li>解决： 原来是shardctrl重复检测成功后直接返回了个空的config……………无语了</li></ul><ol start="6"><li>发送Del RPC请求的那个server不再是leader，不能改回nowait</li></ol><ul><li>这时Del的PRC接收方等着删Out状态，发送方还是wait状态 </li><li>[Gid:100]{S1}    [Gid:102]{S2}</li></ul><h4 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h4><ol><li>修改pullShardsLeader等需要拉取配置的操作，为直接用kv的成员变量的，而不是Query，可以加速获取配置，而且试一下解决死锁。</li></ol><ul><li>除了定时的配置检查，需要向ShardkvCtrler拉取配置，其他情况都不向他拉取。 改完后终于稳定过了TestConcurrent2</li></ul><ol start="2"><li><p>bug-server保持在一些shardStates[OUT]状态，不能修改配置</p><p>分析： [Gid:101]{S1} configChangeable Err,shardStates[4][Out]，configNum[4]</p><p>5 [100 100 100 100 100 100 100 100 100 100]</p><p>4 [100 100 100 100 100 102 102 102 102 102] </p><p>3 [100 100 100 100 101 102 102 102 101 101]</p><p>2 [100 100 100 100 100 102 102 102 102 102]</p><p>表现是：在configNum4的时候拍快照（在添加NoWaitShards，shards[[4]]之前），到configNum5后，宕机重新恢复，从configNum[4]开始恢复，读取lastIncludeIndex开始的日志。</p></li></ol><p>[Gid:101]{S1} shard[4 8 9]改为StateOut，应用config4，拍快照1，[4 8 9]被PullShard完成，添加DelShards[8 9]到raft层，一致化通过，还没有正式apply这个DelShards操作，拍快照2，DelShards[8 9] apply了,DelShards[4]到raft层一致化通过，还没有正式apply这个DelShards操作，拍快照3,DelShards[4] apply了。Configchange到 5 到raft层一致化通过，快照4，Configchange到 5 apply了。</p><p>被kill，StartServer读取快照，但是好像没有恢复到快照4，而是配置5（不明原因）；</p><p>又一次重启：</p><p>设想：这次重启的时候，应该到快照4，可以看到raft层的日志只有一条，也就是，Configchange到 5 这一条</p><p>问题：但是这个第二次重启读取snapshot 的时候，好像回到了快照3的时候，并且没有日志重新apply上来，一直卡住</p><ol start="3"><li>看晕了，不想看了，之后测快照重启的冲突。和垃圾清理</li></ol><h4 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h4><ol><li>重启恢复到快照的时候，之后继续同步很慢，可能是没有当前leader的term的日志，所以很多日志没有apply上来。</li></ol><ul><li>leader 在当选时要先提交一条空日志，这样可以保证集群的可用性。这条空日志不能在raft层添加，</li><li>在server层开一个协程负责定时检测 raft 层的 leader 是否拥有当前 term 的日志，如果没有则提交一条空日志，这使得新 leader 的状态机能够迅速达到最新状态，从而避免多 raft 组间的活锁状态。</li><li>不能在raft层添加空日志，因为lab2可能过不了。raft层应该遵循严格的规则。</li></ul><p>版本较低的 Group 在推进 Config 到这个版本之后已经正确处理过拉取数据或是清理数据的RPC也更新了 Shard 状态，但在重启后这最后处理的关键RPC对应的日志并没有重新被commit。原来，此时 leader 的 currentTerm 高于这个RPC对应的日志的 term，且这个时间节点客户端碰巧没有向该 Group 组执行读写请求，导致 leader 无法拥有当前任期的 term 的日志，无法将状态机更新到最新。</p><h3 id="4Challenge"><a href="#4Challenge" class="headerlink" title="4Challenge"></a>4Challenge</h3><h4 id="状态垃圾收集"><a href="#状态垃圾收集" class="headerlink" title="状态垃圾收集"></a>状态垃圾收集</h4><p>当副本组失去分片的所有权时，该副本组应从其数据库中删除丢失的键。保留它不再拥有且不再满足请求的价值是一种浪费。但是，这给迁移带来了一些问题。假设我们有两个组，G1 和 G2，并且有一个新的配置 C 将分片 S 从 G1 移动到 G2。如果 G1 在转换到 C 时从其数据库中删除 S 中的所有键，那么当 G2 尝试移动到 C 时，它如何获取 S 的数据？</p><p>使每个副本组保留旧分片的时间不要超过绝对必要的时间。即使副本组中的所有服务器（如上面的 G1）崩溃然后重新启动，您的解决方案也必须有效。如果您通过了 TestChallenge1Delete ，您就完成了这个挑战。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>go kv.shardDelChecker()</p><p>定时检测已经拿到的shards，然后用DelShards RPC通知ex-ower可以删除整个shards相关的所有数据，然后把状态改为OK。</p><h5 id="bug-添加删除shardRPC有些情况还是会超出"><a href="#bug-添加删除shardRPC有些情况还是会超出" class="headerlink" title="bug-添加删除shardRPC有些情况还是会超出"></a>bug-添加删除shardRPC有些情况还是会超出</h5><p>— <strong>FAIL</strong>: TestChallenge1Delete (18.00s)</p><p>  test_test.go:803: snapshot + persisted Raft state are too big: 153019 &gt; 117000</p><ul><li><p>分析：这个测试的maxraftstate[1],也就是要求每次提交log后都做快照；比较Snapshot+raftState的大小；检查后发现raftState的大小有时候会出现9000+，考虑减少一些Op结构体中的数据，少向raft传点数据</p></li><li><p>2023&#x2F;06&#x2F;05 14:05:29 [gi0][n0]:raft[665],snap[15712]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi0][n1]:raft[602],snap[15712]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi0][n2]:raft[665],snap[15712]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi1][n0]:raft[597],snap[17734]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi1][n1]:raft[597],snap[17734]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi1][n2]:raft[597],snap[17734]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi2][n0]:raft[600],snap[15698]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi2][n1]:raft[662],snap[15698]<br>2023&#x2F;06&#x2F;05 14:05:29 [gi2][n2]:raft[662],snap[15698]<br>2023&#x2F;06&#x2F;05 14:05:29 结束检查大小total153079，expected117000</p></li><li><p>大小分布倒是挺均匀的，就是都超限了。可以看出主要是snap很大</p></li><li><p>1.把oldConfig不存，改为重启的时候查： </p><p>2023&#x2F;06&#x2F;05 14:18:14 [gi0][n0]:raft[602],snap[15598]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi0][n1]:raft[665],snap[15598]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi0][n2]:raft[665],snap[15598]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi1][n0]:raft[597],snap[17620]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi1][n1]:raft[597],snap[17620]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi1][n2]:raft[597],snap[17620]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi2][n0]:raft[600],snap[15584]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi2][n1]:raft[662],snap[15584]<br>2023&#x2F;06&#x2F;05 14:18:14 [gi2][n2]:raft[600],snap[15584]</p><p>稍微减了点，但没有用</p></li><li><ol start="2"><li>猜测可能是我是在apply应用log之前snapshot的，所以在最后一个log是delshard的时候我没有删除就snapshot，导致snapshot很大。预期可能是apply这个log之后再snapshot。</li></ol></li><li><p>改到apply之后再snapshot检查后，解决这个最后的问题了！！结束了家人们</p></li></ul><h4 id="配置更改期间的客户端请求"><a href="#配置更改期间的客户端请求" class="headerlink" title="配置更改期间的客户端请求"></a>配置更改期间的客户端请求</h4><p>处理配置更改的最简单方法是在转换完成之前禁止所有客户端操作。虽然概念上很简单，但这种方法在生产级系统中并不可行；每当机器被带入或取出时，它会导致所有客户端长时间停顿。最好继续为不受正在进行的配置更改影响的分片提供服务。</p><p>修改您的解决方案，以便客户端对未受影响的分片中的键的操作在配置更改期间继续执行。当您通过 TestChallenge2Unaffected 时，您就完成了这个挑战。</p><p>虽然上面的优化很好，但我们仍然可以做得更好。假设某个副本组 G3 在转换到 C 时需要来自 G1 的分片 S1 和来自 G2 的分片 S2。我们真的希望 G3 在收到必要的状态后立即开始服务分片，即使它仍在等待其他分片。例如，如果 G1 关闭，一旦 G3 从 G2 接收到适当的数据，它仍应开始为 S2 提供服务请求，尽管到 C 的转换尚未完成。</p><p>修改您的解决方案，以便副本组在他们能够的时候开始服务分片，即使配置仍在进行中。当您通过 TestChallenge2Partial 时，您就完成了这个挑战。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web Server C++11</title>
      <link href="/project/2023/06/27/Linux-C++11-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/project/2023/06/27/Linux-C++11-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux服务器搭建入门课"><a href="#Linux服务器搭建入门课" class="headerlink" title="Linux服务器搭建入门课"></a>Linux服务器搭建入门课</h1><h2 id="1-Linux系统编程入门"><a href="#1-Linux系统编程入门" class="headerlink" title="1. Linux系统编程入门"></a>1. Linux系统编程入门</h2><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>gcc和g++都是GCC组织的编译器 ，套件和库；一般用gcc和g++两个编译器</p><ul><li><p>gcc不能自动和cpp程序库链接，一般编译和链接都用g++，因为g++会调用gcc</p></li><li><p>gcc编译c文件 gcc test.c -o app 然后.&#x2F;app<br>其中-o 指明输出文件名</p></li><li><p>预处理 编译 汇编 链接 </p></li><li><p>-c 只是编译不链接,生成目标文件“.o”  test.o</p><p>-S 只是编译不汇编,生成汇编代码  test.s</p><p>-E 只进行预编译,不做其他处理    test.i</p><p><strong>后置</strong> ：</p></li><li><p>-D 指定宏 配合#ifdef DEBUG #endif<br>g++ test.cpp -o test -DDEBUG <em>指定宏DEGUB</em></p></li><li><p>-I 指定include包含文件搜索目录</p></li><li><p>-L 指定编译时 库 的路径</p></li><li><p>-l 指定编译时 使用的 库</p></li></ul><p><img src="D:\MyTxt\typoraPhoto\image-20230214150013734.png" alt="image-20230214150013734"></p><p><img src="D:\MyTxt\typoraPhoto\image-20230214151216633.png" alt="image-20230214151216633"></p><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul><li><p>代码仓库，保存一些变量、函数、类等；编写差不多，但不能单独运行；</p></li><li><p>静态库在程序的链接阶段被复制到程序中；动态库在程序运行时，加载到内存中供程序调用</p></li><li><p>好处：1. 代码保密（cpp反汇编还原度低）；2. 方便部署和分发</p></li><li><p><strong>工作原理</strong>：静态库GCC链接时，把静态库代码打包到可执行程序中；<br>              动态度GCC链接时，动态库代码<strong>不会</strong>被打包到可执行程序中，运行时加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系；系统加载可执行代码时，需要知道库的名字和绝对路径，一般用<strong>动态载入器获取绝对路径，然后找到库文件载入内存中</strong><br> <strong>优缺点比较</strong>：</p><ul><li>静态库被打包到应用程序 ；加载速度快；<br>但消耗资源，浪费内存； 更新速度慢；</li><li>动态库 可以进程资源共享（共享库）；更新部署简单；控制加载时间；<br>  但加载速度慢；发布程序需要提供依赖的动态库；</li><li>库比较小用静态 大用动态</li></ul></li></ul><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><ul><li><p>命名规则 Linux:    libxxx.a<br>            Win :     libxxx.lib</p></li><li><p>制作静态库</p><ol><li><p>gcc获得.o文件 - c</p></li><li><p>将 .o文件打包，使用ar工具 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a  xxx.o xxx.o</span><br></pre></td></tr></table></figure><p>静态库移动到lib目录下</p></li><li><p>编译main程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -I ./include/ -L ./lib/ -l xxx</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230214160115050.png" alt="image-20230214160115050"></p></li></ol></li></ul><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><ul><li><p>命名规则 Linux:   libxxx.so 在Linux下是一个可执行文件<br>            Win :    libxxx.dll</p></li><li><p>制作动态库</p><ol><li><p>gcc得到.o文件，得到与位置无关的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC a.c b.c</span><br></pre></td></tr></table></figure><p>-fpic 用于编译阶段，产生的代码没有绝对地址，全部用相对地址，这正好满足了共享库的要求，共享库被加载时地址不是固定的。如果不加-fpic ，那么生成的代码就会与位置有关，当进程使用该.so文件时都需要重定位，且会产生成该文件的副本，每个副本都不同，不同点取决于该文件代码段与数据段所映射内存的位置</p></li><li><p>gcc得到动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure></li><li><p>编译mian程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app2 -I ./include/ -L ./lib/ -l calc</span><br></pre></td></tr></table></figure><p>运行时加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系；系统加载可执行代码时，需要知道库的名字和绝对路径，一般用<strong>动态载入器获取绝对路径，然后找到库文件载入内存中</strong></p><ol><li><p>窗口级别 直接export配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klchen@vmware:~/WinToUbuntu/lession06/library$ export LD_LIBRARY_PATH=$LD_LIBRAY_PATH:/home/klchen/WinToUbuntu/lession06/library/lib</span><br></pre></td></tr></table></figure></li><li><p>用户级别 在用户中配置.bashrc环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRAY_PATH:/home/klchen/WinToUbuntu/lession06/library/lib</span><br><span class="line"></span><br><span class="line">. .bashrc或者source .bashrc</span><br></pre></td></tr></table></figure></li><li><p>系统级别 在etc&#x2F;profile中export</p></li></ol><ul><li>还有&#x2F;etc&#x2F;ld.so.cache文件列表添加的方式</li></ul></li></ol></li></ul><h3 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。</p><p>◼Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><ul><li>make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，VisualC++的nmake，Linux下GNU的make。</li></ul><h4 id="makefile文件书写规则"><a href="#makefile文件书写规则" class="headerlink" title="makefile文件书写规则"></a>makefile文件书写规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span> </span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> <span class="comment">#clean操作在make不会被执行，需要手动make clean</span></span><br><span class="line"> <span class="comment">#表示clean是一个为目标，不会生成文件</span></span><br><span class="line"> .PHONY:clean</span><br><span class="line"> clean:</span><br><span class="line"> rm <span class="variable">$(objs)</span> -f</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230214231348841.png" alt="image-20230214231348841"></p><p><img src="D:\MyTxt\typoraPhoto\image-20230214231358292.png" alt="image-20230214231358292"></p><p><img src="D:\MyTxt\typoraPhoto\image-20230215135331986.png" alt="image-20230215135331986"></p><p><img src="D:\MyTxt\typoraPhoto\image-20230215135347416.png" alt="image-20230215135347416"></p><p><img src="D:\MyTxt\typoraPhoto\image-20230215135357950.png" alt="image-20230215135357950"></p><p><img src="D:\MyTxt\typoraPhoto\image-20230215135426200.png" alt="image-20230215135426200"></p><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>​调试工具，是许多类Unix系统中的标准开发环境</p><ul><li><p>主要功能：断点调试，监控，改BUG</p></li><li><p>准备工作 在生成可执行文件时添加</p><ol><li>-O关掉优化选项</li><li>-g打开调试选项：可执行文件中加入源代码信息，第几条机器指令对应源代码几行</li><li>-Wall打开所有warning</li></ol></li><li><p>gdb基本操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应该要保证可执行文件和源文件都在</span></span><br><span class="line">gdb 目标程序</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230215165845215.png" alt="image-20230215165845215"></p></li><li><p>断点操作</p><p><strong>退出gdb后断点全部失效</strong></p><p><img src="D:\MyTxt\typoraPhoto\image-20230215185707288.png" alt="image-20230215185707288"></p></li><li><p>调试命令 </p><p><img src="D:\MyTxt\typoraPhoto\image-20230215190042661.png" alt="image-20230215190042661"></p></li></ul><h3 id="Linux系统的IO函数"><a href="#Linux系统的IO函数" class="headerlink" title="Linux系统的IO函数"></a>Linux系统的IO函数</h3><p> 标准C库IO函数带有缓冲区，有FILE*fp文件指针，减少写磁盘次数；但是Linux系统自带的IO没有缓冲区</p><ul><li><p>在网络通信时候用linux系统自带的IO；</p></li><li><p>在磁盘读写用标准C库IO；</p></li><li><p>FILE类型 文件描述符</p></li><li><p>库函数说明查找</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Linux库函数</span></span><br><span class="line">man 2 xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标准C库</span></span><br><span class="line">man 3 xxx</span><br></pre></td></tr></table></figure></li></ul><h5 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h5><ul><li><p>用man操作打开函数的说明文档，可以查找头文件，看IO</p><p>man 1是普通的shell命令比如ls，<br> man 2是系统调用比如open，write说明，<br>    man 3是函数说明，一些库函数</p></li></ul><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>​       int open(const char *pathname, int flags);的说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">打开文件操作</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 打开一个已经存在的文件</span><br><span class="line">   <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line">       参数：</span><br><span class="line"></span><br><span class="line">      - pathname：要打开的文件路径</span><br><span class="line">        - flags：对文件的操作权限设置还有其他的设置</span><br><span class="line">              - flO_RDONLY,  O_WRONLY,  O_RDWR  这三个设置是互斥的</span><br><span class="line">      - 返回值：返回一个新的文件描述符，如果调用失败，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;作用：打印errno对应的错误描述</span><br><span class="line">       s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span><br><span class="line">       创建一个新的文件</span><br><span class="line">   <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="comment">/*man 1是普通的shell命令比如ls，</span></span><br><span class="line"><span class="comment">    man 2是系统调用比如open，write说明，</span></span><br><span class="line"><span class="comment">    man 3是函数说明，一些库函数。        </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;的说明参数：</span><br><span class="line">    - pathname：要创建的文件的路径</span><br><span class="line">    - flags：对文件的操作权限和其他的设置</span><br><span class="line">        - 必选项：O_RDONLY,  O_WRONLY, O_RDWR  这三个之间是互斥的，就是权限的设置只读、只写、读写</span><br><span class="line">        - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">    - mode：八进制的数，表示创建出的新的文件的操作权限，比如：<span class="number">0775</span></span><br><span class="line">    最终的权限是：mode &amp; ~umask</span><br><span class="line">    <span class="number">0777</span>   -&gt;   <span class="number">111111111</span></span><br><span class="line">&amp;   <span class="number">0775</span>   -&gt;   <span class="number">111111101</span></span><br><span class="line">----------------------------</span><br><span class="line">                <span class="number">111111101</span></span><br><span class="line">按位与：<span class="number">0</span>和任何数都为<span class="number">0</span></span><br><span class="line">umask的作用就是抹去某些权限，也可以自己</span><br><span class="line"></span><br><span class="line">flags参数是一个<span class="type">int</span>类型的数据，占<span class="number">4</span>个字节，<span class="number">32</span>位。</span><br><span class="line">flags <span class="number">32</span>个位，每一位就是一个标志位。</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>,O_RDONLY|O_CREAT,<span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="line">        - buf：需要读取数据存放的地方，数组的地址（传出参数）</span><br><span class="line">        - count：指定的数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：</span><br><span class="line">            &gt;<span class="number">0</span>: 返回实际的读取到的字节数</span><br><span class="line">            =<span class="number">0</span>：文件已经读取完了</span><br><span class="line">        - 失败：<span class="number">-1</span> ，并且设置errno</span><br></pre></td></tr></table></figure><h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="line">        - buf：要往磁盘写入的数据，数据</span><br><span class="line">        - count：要写的数据的实际的大小</span><br><span class="line">          write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    返回值：</span><br><span class="line">        成功：实际写入的字节数</span><br><span class="line">        失败：返回<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure><p>例子：读写复制文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//open打开资源文件</span></span><br><span class="line">    <span class="type">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建拷贝文件</span></span><br><span class="line">    <span class="type">int</span> destfd = open(<span class="string">&quot;copy.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(destfd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//频繁的读写操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        write(destfd,buf,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(srcfd);</span><br><span class="line">    close(destfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lseek移动文件指针偏移"><a href="#lseek移动文件指针偏移" class="headerlink" title="lseek移动文件指针偏移"></a>lseek移动文件指针偏移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    标准C库的函数</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    Linux系统函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span><br><span class="line">        - offset：偏移量</span><br><span class="line">        - whence:</span><br><span class="line">            SEEK_SET</span><br><span class="line">                设置文件指针的偏移量</span><br><span class="line">            SEEK_CUR</span><br><span class="line">                设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line">            SEEK_END</span><br><span class="line">                设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">    返回值：返回文件指针的位置</span><br><span class="line">    作用：</span><br><span class="line">    <span class="number">1.</span>移动文件指针到文件头</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>获取当前文件指针的位置</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span>获取文件长度</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span>拓展文件的长度，当前文件<span class="number">10b</span>, <span class="number">110b</span>, 增加了<span class="number">100</span>个字节</span><br><span class="line">    lseek(fd, <span class="number">100</span>, SEEK_END)</span><br><span class="line">    注意：需要写一次数据</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><ul><li>终端操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat xxx</span><br></pre></td></tr></table></figure><h5 id="stat函数-lstat函数获取文件信息"><a href="#stat函数-lstat函数获取文件信息" class="headerlink" title="stat函数 lstat函数获取文件信息"></a>stat函数 lstat函数获取文件信息</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：操作的文件的路径</span><br><span class="line">        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;获取软链接的文件信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：操作的文件的路径</span><br><span class="line">        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230218161815168.png" alt="image-20230218161815168"></p><p>例子：用stat实现ls -l</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟ls-l指令</span></span><br><span class="line"><span class="comment">//-rw-rw-r-- 1 klchen klchen 0 2月  18 14:01 a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过stat函数获取用户传入文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret=stat(argv[<span class="number">1</span>],&amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件类型和文件权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (st.st_mode &amp; __S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> __S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> __S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> __S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>]=<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断文件访问权限</span></span><br><span class="line">    perms[<span class="number">1</span>]= st.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>]= st.st_mode &amp; S_IWUSR ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>]= st.st_mode &amp; S_IXUSR ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    perms[<span class="number">4</span>]= st.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>]= st.st_mode &amp; S_IWGRP ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>]= st.st_mode &amp; S_IXGRP ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    perms[<span class="number">7</span>]= st.st_mode &amp; S_IROTH ? <span class="string">&#x27;r&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>]= st.st_mode &amp; S_IWOTH ? <span class="string">&#x27;w&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>]= st.st_mode &amp; S_IXOTH ? <span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬链接数</span></span><br><span class="line">    <span class="type">int</span> linkNum =st.st_nlink;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所有者</span></span><br><span class="line">    <span class="type">char</span> *fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所在组</span></span><br><span class="line">    <span class="type">char</span> *fileGrp=getgrgid(st.st_uid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> fileSize =st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取修改时间</span></span><br><span class="line">    <span class="type">char</span> *time = ctime(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime,time,<span class="built_in">strlen</span>(time) <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>,perms,linkNum,fileUser,fileGrp,fileSize,mtime,argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h4><h5 id="access判断文件权限或文件是否存在"><a href="#access判断文件权限或文件是否存在" class="headerlink" title="access判断文件权限或文件是否存在"></a>access判断文件权限或文件是否存在</h5><pre><code>#include &lt;unistd.h&gt;int access(const char *pathname, int mode);    作用：判断某个文件是否有某个权限，或者判断文件是否存在    参数：        - pathname: 判断的文件路径        - mode:            R_OK: 判断是否有读权限            W_OK: 判断是否有写权限            X_OK: 判断是否有执行权限            F_OK: 判断文件是否存在    返回值：成功返回0， 失败返回-1</code></pre><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在！！!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="chmod函数修改文件权限"><a href="#chmod函数修改文件权限" class="headerlink" title="chmod函数修改文件权限"></a>chmod函数修改文件权限</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="truncate修改文件尺寸"><a href="#truncate修改文件尺寸" class="headerlink" title="truncate修改文件尺寸"></a>truncate修改文件尺寸</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h4><h5 id="mkdir函数创建目录"><a href="#mkdir函数创建目录" class="headerlink" title="mkdir函数创建目录"></a>mkdir函数创建目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="chdir修改进程工作目录"><a href="#chdir修改进程工作目录" class="headerlink" title="chdir修改进程工作目录"></a>chdir修改进程工作目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br></pre></td></tr></table></figure><h5 id="getcwd获取当前目录"><a href="#getcwd获取当前目录" class="headerlink" title="getcwd获取当前目录"></a>getcwd获取当前目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h4><h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h5 id="readdir"><a href="#readdir" class="headerlink" title="readdir()"></a>readdir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class">//返回值 <span class="title">dirent</span>结构体的具体 元素 如图</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230219211206835.png" alt="image-20230219211206835"></p><h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir()"></a>closedir()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;<span class="comment">//此处 参数 关闭的是文件描述符</span></span><br></pre></td></tr></table></figure><h6 id="应用-统计某个目录下文件数量"><a href="#应用-统计某个目录下文件数量" class="headerlink" title="应用-统计某个目录下文件数量"></a>应用-统计某个目录下文件数量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFilenum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取某目录下所有文件个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否输入了文件名</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=getFilenum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平台文件的个数是 %d\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFilenum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>&#123;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    DIR *dir=opendir(path);</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="comment">//记录普通文件数</span></span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((ptr=readdir(dir))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略掉. 和..</span></span><br><span class="line">        <span class="type">char</span>* dname=ptr-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dname,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是目录递归</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            <span class="comment">//目录，需要继续读取目录</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="comment">//生成地址名称，字符串合并函数</span></span><br><span class="line">            <span class="built_in">sprintf</span>(newpath,<span class="string">&quot;%s/%s&quot;</span>,path,dname);</span><br><span class="line">            total+=getFilenum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">            <span class="comment">//普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件描述符操作函数"><a href="#文件描述符操作函数" class="headerlink" title="文件描述符操作函数"></a>文件描述符操作函数</h4><p>一个进程中有一个文件描述符表</p><h5 id="dup-文件描述符-复制-浅拷贝"><a href="#dup-文件描述符-复制-浅拷贝" class="headerlink" title="dup()文件描述符 复制 - 浅拷贝"></a>dup()文件描述符 复制 - 浅拷贝</h5><pre><code>#include &lt;unistd.h&gt;int dup(int oldfd);    作用：复制一个新的文件描述符    fd=3, int fd1 = dup(fd),    fd指向的是a.txt, fd1也是指向a.txt    从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</code></pre><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dup2-文件描述符-重定向"><a href="#dup2-文件描述符-重定向" class="headerlink" title="dup2()文件描述符 重定向"></a>dup2()文件描述符 重定向</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">    作用：重定向文件描述符,让newfd也来指向oldfd</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fcntl-函数-控制文件描述符"><a href="#fcntl-函数-控制文件描述符" class="headerlink" title="fcntl()函数 控制文件描述符"></a>fcntl()函数 控制文件描述符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。<span class="comment">//这个flag都可以|上O_NONBLOCK</span></span><br><span class="line">            <span class="comment">//设置fd非阻塞的方法，一般是fcntl+F_GETFL得到flag，|上O_NONBLOCK，然后fcntl+F_SETFL设置falg</span></span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改！！！！！</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            NONBLOK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。 导致当前进程线程被挂起-阻塞</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="comment">// 首先要获取文件描述符状态flag</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改完flag后替换进去</span></span><br><span class="line">    flag |= O_APPEND;   <span class="comment">// flag = flag | O_APPEND 此处用按位或来追加flag状态</span></span><br><span class="line">    <span class="type">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Linux多进程编程"><a href="#2-Linux多进程编程" class="headerlink" title="2. Linux多进程编程"></a>2. Linux多进程编程</h2><h3 id="2-1进程状态转换-终端指令"><a href="#2-1进程状态转换-终端指令" class="headerlink" title="2.1进程状态转换  -终端指令"></a>2.1进程状态转换  -终端指令</h3><ul><li><p>Linux中PBC的结构体task_struct</p></li><li><p>进程参数查看 ulimit -a </p></li><li><p>查看进程<br>ps aux &#x2F; ajx<br>a：显示终端上的所有进程，包括其他用户的进程<br>u：显示进程的详细信息<br>x：显示没有控制终端的进程<br>j：列出与作业控制相关的信息</p></li><li><p>STAT参数意义：<br>D 不可中断 Uninterruptible（usually IO）<br>R 正在运行，或在队列中的进程<br>S(大写) 处于休眠状态<br>T 停止或被追踪<br>Z 僵尸进程<br>W 进入内存交换（从内核2.6开始无效）<br>X 死掉的进程<br>&lt; 高优先级<br>N 低优先级<br>s 包含子进程</p><p>+ 位于前台的进程组</p></li><li><p>然后，实时显示进程动态<br>top<br>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令<br>执行后，可以按以下按键对显示的结果进行排序：<br>⚫ M 根据内存使用量排序<br>⚫ P 根据 CPU 占有率排序<br>⚫ T 根据进程运行时间长短排序<br>⚫ U 根据用户名来筛选进程<br>⚫ K 输入指定的 PID 杀死进程</p></li><li><p>杀死进程<br>kill [-signal] pid<br>kill –l 列出所有信号<br>kill –SIGKILL 进程ID<br>kill -9 进程ID<br>killall name 根据进程名杀死进程</p></li><li><p>进程号和进程组相关函数：<br>⚫ pid_t getpid(void);<br>⚫ pid_t getppid(void);  &#x2F;&#x2F;父进程的pid<br>⚫ pid_t getpgid(pid_t pid);</p></li></ul><h3 id="2-2进程创建"><a href="#2-2进程创建" class="headerlink" title="2.2进程创建"></a>2.2进程创建</h3><h5 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h5><ul><li><p>创建子进程</p><p>  #include &lt;sys&#x2F;types.h&gt;<br>  #include &lt;unistd.h&gt;</p><p>  pid_t fork(void);<br>  函数的作用：用于创建子进程。<br>  返回值：<br>      fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。<br>      在父进程中返回创建的子进程的ID,<br>      在子进程中返回0<br>      如何区分父进程和子进程：通过fork的返回值。<br>      在父进程中返回-1，表示创建子进程失败，并且设置errno<br><br>  父子进程之间的关系：<br>  区别：<br>      1.fork()函数的返回值不同<br>          父进程中: &gt;0 返回的子进程的ID<br>          子进程中: &#x3D;0<br>      2.pcb中的一些数据<br>          当前的进程的id pid<br>          当前的进程的父进程的id ppid<br>          信号集<br><br>  共同点：<br>      某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作<br>          - 用户区的数据<br>          - 文件描述符表<br><br>  父子进程对变量是不是共享的？<br>      - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。<br>      - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。<br>   实际上，更准确来说，Linux 的 fork() 使用是通过<strong>写时拷贝 (copy- on-write)</strong> 实现。<br>  写时拷贝是一种可以推迟甚至避免拷贝数据的技术。<br>  内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。<br>  只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。<br>  也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。<br>  注意：fork之后父子进程共享文件，<br>  fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p></li><li><p>查看例子</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    <span class="comment">//判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">//如果大于0，返回的创建的是子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process,pid:%d,ppid:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num:%d\n&quot;</span>,num);</span><br><span class="line">        num+=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num +=10:%d\n&quot;</span>,num);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process,pid:%d,ppid:%d&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num:%d\n&quot;</span>,num);</span><br><span class="line">        num+=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num +=10:%d\n&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i:%d,pid:%d\n&quot;</span>,i,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父进程和子进程执行的代码块分别是以下图：</li><li><ol><li>子进程只执行以下的自己进程部分</li></ol></li><li><ol start="2"><li>父子进程代码段一样，但是按照pid来运行；</li></ol></li><li><ol start="3"><li>写操作之后，进程资源之间互不影响，共同部分运行的是各自的资源</li></ol></li></ul><h5 id="gdb调试父子进程"><a href="#gdb调试父子进程" class="headerlink" title="gdb调试父子进程"></a>gdb调试父子进程</h5><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p><ul><li>设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child]</li><li>设置调试模式：set detach-on-fork [on | off]<br>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。</li><li>查看调试的进程：info inferiors<br>切换当前调试的进程为id进程：inferior id<br>使进程脱离 GDB 调试：detach inferiors id</li></ul><h5 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h5><p>◼ exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p><p>◼ exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p><p>注意：</p><ol><li><p>内核区的id等不会改变，但是用户取的数据都被替换</p></li><li><p>有p或者v后缀，一般filename直接写文件名，因为p会指定到环境变量查，v指定到数组envp[]中路径依次查找，没找到返回-1</p></li><li><p>一般fork新进程后，替换子进程数据</p></li></ol><ul><li>函数族</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族</span><br><span class="line">◼ int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">◼ int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">◼ int execle(const char *path, const char *arg, .../*, (char *) NULL, char *</span><br><span class="line">const envp[] */);</span><br><span class="line">◼ int execv(const char *path, char *const argv[]);</span><br><span class="line">◼ int execvp(const char *file, char *const argv[]);</span><br><span class="line">◼ int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line">◼ int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">l(list) 参数地址列表，以空指针结尾</span><br><span class="line">v(vector) 存有各参数地址的指针数组的地址</span><br><span class="line">p(path) 按 PATH 环境变量指定的目录搜索可执行文件</span><br><span class="line">e(environment) 存有环境变量字符串地址的指针数组的地址</span><br></pre></td></tr></table></figure><ul><li><p>execl()</p><pre><code>   #include &lt;unistd.h&gt;  int execl(const char *path, const char *arg, ...);      - 参数：          - path:需要指定的执行的文件的路径或者名称              a.out /home/nowcoder/a.out 推荐使用绝对路径              ./a.out hello world             - arg:是执行可执行文件所需要的参数列表          第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称          从第二个参数开始往后，就是程序执行所需要的的参数列表。          参数最后需要以NULL结束（哨兵）  - 返回值：      只有当调用失败，才会有返回值，返回-1，并且设置errno      如果调用成功，没有返回值。</code></pre></li><li><p>execlp</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... )</span>;</span><br><span class="line">    - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">    - 参数：</span><br><span class="line">        - file:需要执行的可执行文件的文件名</span><br><span class="line">            a.out</span><br><span class="line">            ps</span><br><span class="line">- arg:是执行可执行文件所需要的参数列表</span><br><span class="line">        第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">        从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">        参数最后需要以<span class="literal">NULL</span>结束（哨兵）</span><br><span class="line"></span><br><span class="line">- 返回值：</span><br><span class="line">    只有当调用失败，才会有返回值，返回<span class="number">-1</span>，并且设置errno</span><br><span class="line">    如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure></li><li><p>execv</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line">argv是需要的参数的一个字符串数组</span><br><span class="line"><span class="type">char</span> * argv[] = &#123;<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/ps&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">char</span> * envp[] = &#123;<span class="string">&quot;/home/nowcoder&quot;</span>, <span class="string">&quot;/home/bbb&quot;</span>, <span class="string">&quot;/home/aaa&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-进程退出"><a href="#2-3-进程退出" class="headerlink" title="2.3 进程退出"></a>2.3 进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*标准库</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment">  Linux系统（没有缓冲区，退出过不刷新缓冲区，直接退出，可能导致缓冲区的数据还没有拿出来）</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0);</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230222142604615.png" alt="image-20230222142604615"></p><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>◼ 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。<br>◼ 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init<br>进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束<br>了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。<br>◼ 因此孤儿进程并不会有什么危害</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，<strong>内核区的 PCB</strong> 没有办法自己释放掉，需要<strong>父进程</strong>去释放。<br>◼ 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。<br>◼ 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p><p><img src="D:\MyTxt\typoraPhoto\image-20230222143746621.png" alt="image-20230222143746621"></p><h5 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h5><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。<br>◼ 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><h6 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h6><ul><li><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *wstatus);    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。    参数：int *wstatus        进程退出时的状态信息，传入的是一个int类型的地址，传出参数。        //wstatus指针传入到宏里面可得到 退出的具体信息        //如果不需要查看直接 wait(NULL)    返回值：        - 成功：返回被回收的子进程的id        - 失败：-1 (所有的子进程都结束，调用函数失败)调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">◼ wait() 和 waitpid() 函数的功能一样，区别在于：</span><br><span class="line">**wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。**</span><br><span class="line">◼ 注意：一次wait或waitpid调用**只能清理一个子进程**，清理多个子进程应使用循环：while()</span><br><span class="line"></span><br><span class="line">* 退出信息相关宏函数查询</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  ◼ WIFEXITED(status) 非0，进程正常退出</span><br><span class="line">  ◼ WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</span><br><span class="line">  ◼ WIFSIGNALED(status) 非0，进程异常终止</span><br><span class="line">  ◼ WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</span><br><span class="line">  ◼ WIFSTOPPED(status) 非0，进程处于暂停状态</span><br><span class="line">  ◼ WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</span><br><span class="line">  ◼ WIFCONTINUED(status) 非0，进程暂停后已经继续运行</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">  例子;</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/wait.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">  </span><br><span class="line">      pid_t pid;</span><br><span class="line">      //创建5个子进程 </span><br><span class="line">      for(int i=0;i!=5;++i)&#123;</span><br><span class="line">          pid = fork();</span><br><span class="line">          if(pid == 0)&#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(pid &gt; 0)&#123;</span><br><span class="line">          //父进程</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              printf(&quot;父进程: %d\n&quot;,getpid());</span><br><span class="line">              int st;</span><br><span class="line">              int ret = wait(&amp;st);</span><br><span class="line">              if(ret == -1)&#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              if(WIFEXITED(st))&#123;</span><br><span class="line">                  //是不是正常退出</span><br><span class="line">                  printf(&quot;退出状态码: %d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">              &#125;</span><br><span class="line">              if(WIFSIGNALED(st))&#123;</span><br><span class="line">                  //是不是被异常终止</span><br><span class="line">                  printf(&quot;被哪个信号干掉: %d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">              &#125;</span><br><span class="line">              printf(&quot;child die,pid = %d\n&quot;,WTERMSIG(st));</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid == 0)&#123;</span><br><span class="line">          //子进程</span><br><span class="line">          printf(&quot;子进程: %d\n&quot;,getpid());</span><br><span class="line">          exit(0);</span><br><span class="line">          sleep(1);        </span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">###### waitpid()函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; 0 : 某个子进程的pid</span><br><span class="line">                pid = 0 : 回收当前进程组的所有子进程    </span><br><span class="line">                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - 参数：int *wstatus</span><br><span class="line">                     进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                0 : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line"> //这三个会返回值可以判断当前进程的子进程回收情况，可以以此来设计，很多子进程时，回收处理函数</span><br><span class="line">                &gt; 0 : 返回子进程的id</span><br><span class="line">                = 0 : options=WNOHANG, 表示还有子进程活着 </span><br><span class="line">                = -1 ：错误，或者没有子进程了</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 例子(设置非阻塞)：</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/wait.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">  </span><br><span class="line">      pid_t pid;</span><br><span class="line">      //创建5个子进程</span><br><span class="line">      for(int i=0;i!=5;++i)&#123;</span><br><span class="line">          pid = fork();</span><br><span class="line">          if(pid == 0)&#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(pid &gt; 0)&#123;</span><br><span class="line">          //父进程</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              printf(&quot;父进程: %d\n&quot;,getpid());</span><br><span class="line">              sleep(1);</span><br><span class="line">              </span><br><span class="line">              int st;</span><br><span class="line">              //int ret = waitpid(-1,&amp;st,0);</span><br><span class="line">              int ret = waitpid(-1,&amp;st,WNOHANG);</span><br><span class="line">              </span><br><span class="line">              if(ret == -1)&#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;else if(ret == 0)&#123;</span><br><span class="line">                  //子进程还有在运行的</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;else if(ret &gt; 0)&#123;</span><br><span class="line">                  if(WIFEXITED(st))&#123;</span><br><span class="line">                      printf(&quot;退出的状态码：%d\n&quot;,WEXITSTATUS(st));</span><br><span class="line">                  &#125;</span><br><span class="line">                  if(WIFSIGNALED(st))&#123;</span><br><span class="line">                      printf(&quot;被哪个信号干掉：%d&quot;,WTERMSIG(st));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              printf(&quot;child die,pid = %d\n&quot;,WTERMSIG(st));</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid == 0)&#123;</span><br><span class="line">          //子进程</span><br><span class="line">          while (1)</span><br><span class="line">          &#123;</span><br><span class="line">              printf(&quot;子进程: %d\n&quot;,getpid());</span><br><span class="line">              sleep(1);</span><br><span class="line">          &#125;</span><br><span class="line">          exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">### 2.4进程间通信IPC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管道在使用完毕后应该被关闭，这是为了防止出现资源泄漏的情况。如果没有关闭管道，在程序运行过程中会一直占用系统资源，而且可能导致其他进程无法使用同名管道。同时，如果管道没有被及时关闭，在程序意外退出时也可能导致数据丢失或者磁盘空间占用问题。因此，在使用完毕后，最好及时关闭管道。</span><br><span class="line"></span><br><span class="line">* TCP/IP方式： mysql -h127.0.0.1 -uroot -P3306 -p</span><br><span class="line">* windowOS 的一台主机：命名管道和共享内存</span><br><span class="line">* 类Unix的一台主机：套接字</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230222170747041.png&quot; alt=&quot;image-20230222170747041&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* （匿名）管道，Unix系统最古老的通信方式，所有Unix系统都支持</span><br><span class="line">* 统计目录中文件数量的命令： ls | wc -l</span><br><span class="line">   实际上就是创建管道 把写入端导出读取端</span><br><span class="line">* &lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230222172058889.png&quot; alt=&quot;image-20230222172058889&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">##### 管道特点</span><br><span class="line"></span><br><span class="line">1. 管道其实是内核在内存中维护的缓冲区，缓冲能力有限，不同操作系统大小不同；</span><br><span class="line">2. 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但是不存储数据，可以按照操作文件的方式操作管道。</span><br><span class="line">3. 一个管道是一个字节流，使用管道不存在消息和消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块是多少（每次都按照自己能力读取）</span><br><span class="line">4. 通过管道传递是顺序的。</span><br><span class="line">5. 管道中传递数据方向是单向的，一端写入，一端读取，也就是半双工。</span><br><span class="line">6. 从管道中读取数据是一次性操作，数据一旦被读走了，就从管道抛弃了，(队列实现)释放空间以便写入更多的数据，在管道中无法使用lseek()随机访问数据</span><br><span class="line">7. 管道只能在具有公共祖先的进程（父子进程，兄弟进程，具有亲缘关系）之间使用</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230222173206683.png&quot; alt=&quot;image-20230222173206683&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* 管道原理：子进程forkc()出来之后，可以共享文件描述符，可以操作建立管道</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230222173922960.png&quot; alt=&quot;image-20230222173922960&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* 管道数据结构：环形队列</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230222174026442.png&quot; alt=&quot;image-20230222174026442&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">##### 匿名管道传输pipe()函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int pipe(int pipefd[2]);</span><br><span class="line">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">            pipefd[0] 对应的是管道的读端</span><br><span class="line">            pipefd[1] 对应的是管道的写端</span><br><span class="line">        返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line"></span><br><span class="line">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 例子-父子间管道通信</span><br><span class="line">* 匿名管道一般不会实现双向读写，因为没有了sleep()，本进程会抢读管道，一般就是一个读，一个写，并且关闭另一个操作，俺理解为互斥</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //在fork()之前创建管道</span><br><span class="line">    int pipefd[2];</span><br><span class="line">    int ret=pipe(pipefd);</span><br><span class="line">    if(ret==-1)&#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if(pid&gt;0)&#123;</span><br><span class="line">        //父进程先读取，然后写</span><br><span class="line">        printf(&quot;父进程&quot;);</span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            //先读</span><br><span class="line">            //sizeof给出操作数的存储地址空间</span><br><span class="line">            int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">            printf(&quot;parent recv: %s ,pid : %d\n&quot;,buf,getpid());</span><br><span class="line"></span><br><span class="line">            //向管道写入数据</span><br><span class="line">            char* str=&quot;hello,this is parent process&quot;;</span><br><span class="line">            write(pipefd[1],str,strlen(str));   </span><br><span class="line">            sleep(1);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(pid ==0)&#123;</span><br><span class="line">        //子进程先写，然后读</span><br><span class="line">        //管道默认阻塞，sleep(10); 如果没有数据，读取端就等着</span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        printf(&quot;子进程&quot;);</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            //先写</span><br><span class="line">            char* str=&quot;hello,this is child process&quot;;</span><br><span class="line">            //strlen()函数给出字符串的长度</span><br><span class="line">            write(pipefd[1],str,strlen(str));   </span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">            //读取数据</span><br><span class="line">            int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">            printf(&quot;child recv: %s ,pid : %d\n&quot;,buf,getpid());</span><br><span class="line">            //清除一下</span><br><span class="line">            bzero(buff,1024);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 互斥读写操作的代码如下</span><br><span class="line"></span><br><span class="line">* ~~~c</span><br><span class="line">      //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;stdlib.h&gt;</span><br><span class="line">  #include &lt;string.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">      //在fork()之前创建管道</span><br><span class="line">      int pipefd[2];</span><br><span class="line">      int ret=pipe(pipefd);</span><br><span class="line">      if(ret==-1)&#123;</span><br><span class="line">          perror(&quot;pipe&quot;);</span><br><span class="line">          exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      //创建子进程</span><br><span class="line">      pid_t pid = fork();</span><br><span class="line">      if(pid&gt;0)&#123;</span><br><span class="line">          //父进程读取</span><br><span class="line">          printf(&quot;父进程\n&quot;);</span><br><span class="line">  </span><br><span class="line">          //关闭写端</span><br><span class="line">          close(pipefd[1]);</span><br><span class="line">  </span><br><span class="line">          char buf[1024]=&#123;0&#125;;</span><br><span class="line">          while(1)&#123;</span><br><span class="line">              int len = read(pipefd[0],buf,sizeof(buf));</span><br><span class="line">              printf(&quot;parent recv: %s ,pid : %d\n&quot;,buf,getpid());           </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(pid ==0)&#123;</span><br><span class="line">          //子进程写端</span><br><span class="line">          printf(&quot;子进程\n&quot;);</span><br><span class="line">  </span><br><span class="line">          //关闭读端</span><br><span class="line">          close(pipefd[0]);</span><br><span class="line">  </span><br><span class="line">          while(1)&#123;</span><br><span class="line">              char* str=&quot;hello,this is child process&quot;;</span><br><span class="line">              //strlen()函数给出字符串的长度</span><br><span class="line">              write(pipefd[1],str,strlen(str));   </span><br><span class="line">              sleep(1);                  </span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">* 获取管道大小</span><br><span class="line"></span><br><span class="line">*     // 1. 函数获取管道的大小</span><br><span class="line">      long size = fpathconf(pipefd[0], _PC_PIPE_BUF);</span><br><span class="line">      // 2. 终端获取管道信息</span><br><span class="line">      ulimit -a</span><br><span class="line"></span><br><span class="line">##### ps aux | grep xxx 操作实现 -父子进程通信案例</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    //在fork()之前发送数据给父进程，父进程读取到数据输出</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //创建管道</span><br><span class="line">    int fd[2];</span><br><span class="line">    int ret=pipe(fd);</span><br><span class="line">    if(ret==-1)&#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;  </span><br><span class="line">    //创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if(pid &gt; 0)&#123;</span><br><span class="line">    //父进程，读取管道信息输出到列表</span><br><span class="line">        close(fd[1]);</span><br><span class="line">        </span><br><span class="line">        char buf[1024]=&#123;0&#125;;</span><br><span class="line">        int len=-1;</span><br><span class="line">        //空间设置 -1 留一个字符串的结束符位置</span><br><span class="line">        while((len=read(fd[0],buf,sizeof(buf)-1))&gt;0)&#123;</span><br><span class="line">            //过滤数据输出</span><br><span class="line">            printf(&quot;%s&quot;,buf);</span><br><span class="line">            //清空buf内容</span><br><span class="line">            memset(buf,0,1024);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(NULL);</span><br><span class="line"></span><br><span class="line">    &#125;else if(pid == 0)&#123;</span><br><span class="line">    //子进程，把输出stdout_fileno的内容写入管道</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        // 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span><br><span class="line">        dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">        //替换到aux的内容</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        //如果没退出，报系统错误</span><br><span class="line">        perror(&quot;execlp&quot;);</span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">##### 管道读写的特点</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端</span><br><span class="line">读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</span><br><span class="line"></span><br><span class="line">2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程</span><br><span class="line">也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line"></span><br><span class="line">3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程</span><br><span class="line">向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line"></span><br><span class="line">4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程</span><br><span class="line">也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">    读管道：</span><br><span class="line">        管道中有数据，read返回实际读到的字节数。</span><br><span class="line">        管道中无数据：</span><br><span class="line">            写端被全部关闭，read返回0（相当于读到文件的末尾）</span><br><span class="line">            写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">    写管道：</span><br><span class="line">        管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">        管道读端没有全部关闭：</span><br><span class="line">            管道已满，write阻塞</span><br><span class="line">            管道没有满，write将数据写入，并返回实际写入的字节数</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">* 设置非阻塞 - 此时设置为管道读端继续read，由于没有写入，read()返回-1</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">        int flags = fcntl(pipefd[0], F_GETFL);  // 获取原来的flag</span><br><span class="line">        flags |= O_NONBLOCK;            // 修改flag的值</span><br><span class="line">        fcntl(pipefd[0], F_SETFL, flags);   // 设置新的flag</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 有名管道</span><br><span class="line"></span><br><span class="line">◼ 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提 出了有名管道（FIFO），也叫命名管道、FIFO文件。 </span><br><span class="line"></span><br><span class="line">有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此 通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 ◼ </span><br><span class="line"></span><br><span class="line">一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的 I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一 个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的 名称也由此而来：先入先出。</span><br><span class="line"></span><br><span class="line">##### 与匿名管道区别：</span><br><span class="line"></span><br><span class="line">有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： 1. FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 2. 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</span><br><span class="line"></span><br><span class="line">1. 通过命令创建有名管道 mkfifo 名字</span><br><span class="line"></span><br><span class="line">2. 通过函数创建有名管道 </span><br><span class="line">    int mkfifo(const char *pathname, mode_t mode); </span><br><span class="line"></span><br><span class="line">    ~~~c</span><br><span class="line">    创建fifo文件</span><br><span class="line">        1.通过命令： mkfifo 名字</span><br><span class="line">        2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">    </span><br><span class="line">        #include &lt;sys/types.h&gt;</span><br><span class="line">        #include &lt;sys/stat.h&gt;</span><br><span class="line">        int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">            参数：</span><br><span class="line">                - pathname: 管道名称的路径</span><br><span class="line">                - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                        是一个八进制的数</span><br><span class="line">            返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line">    ~~~</span><br><span class="line"></span><br><span class="line">3. 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 **open** 打开它，常见的文件 I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 </span><br><span class="line"></span><br><span class="line">4. FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是 从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</span><br><span class="line"></span><br><span class="line">##### 有名管道注意事项</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">    有名管道的注意事项：</span><br><span class="line">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">    读管道：</span><br><span class="line">        管道中有数据，read返回实际读到的字节数</span><br><span class="line">        管道中无数据：</span><br><span class="line">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="line">            写端没有全部被关闭，read阻塞等待</span><br><span class="line">    </span><br><span class="line">    写管道：</span><br><span class="line">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">        管道读端没有全部关闭：</span><br><span class="line">            管道已经满了，write会阻塞</span><br><span class="line">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">![image-20230223161443567](D:\MyTxt\typoraPhoto\image-20230223161443567.png)</span><br><span class="line"></span><br><span class="line">##### 同一路径下 有名管道创建并用于读写的例子</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">write.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    // 1.判断文件是否存在</span><br><span class="line">    int ret = access(&quot;fifo1&quot;, F_OK);</span><br><span class="line">    if(ret == -1) &#123;</span><br><span class="line">        printf(&quot;管道不存在，创建管道\n&quot;);</span><br><span class="line">        //2.创建管道文件</span><br><span class="line">        ret = mkfifo(&quot;fifo1&quot;, 0664);</span><br><span class="line"></span><br><span class="line">        if(ret == -1) &#123;</span><br><span class="line">            perror(&quot;mkfifo&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //以只写的方式打开管道</span><br><span class="line">    int fd=open(&quot;fifo1&quot;,O_WRONLY);</span><br><span class="line">    if(fd==-1)&#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写入数据</span><br><span class="line">    for (int i = 0; i &lt; 100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[1024];</span><br><span class="line">        //sprintf将字符串写入buf中</span><br><span class="line">        sprintf(buf,&quot;hello,%d\n&quot;,i);</span><br><span class="line">        printf(&quot;write data: %s\n&quot;,buf);</span><br><span class="line">        write(fd,buf,strlen(buf));</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">read.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">     //1. 打开管道文件</span><br><span class="line">     int fd = open(&quot;fifo1&quot;,O_RDONLY);</span><br><span class="line">     if(fd == -1)&#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //读数据</span><br><span class="line">     while(1)&#123;</span><br><span class="line">        char buf[1024] = &#123;0&#125;;</span><br><span class="line">        int len = read(fd,buf,sizeof(buf));</span><br><span class="line">        if(len == 0)&#123;</span><br><span class="line">            printf(&quot;写端断开连接了。\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;recv buf :%s\n&quot;,buf);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="2-5-内存映射"><a href="#2-5-内存映射" class="headerlink" title="2.5 内存映射"></a>2.5 内存映射</h3><p>Memory-mapped I&#x2F;O 是将磁盘文件的数据映射到内存，用户通过修改内存就可以修改磁盘文件</p><img src="D:\MyTxt\typoraPhoto\image-20230224145114660.png" alt="image-20230224145114660" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">    - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="type">void</span> *addr: <span class="literal">NULL</span>, 由内核指定</span><br><span class="line">        - length : 要映射的数据的长度，这个值不能为<span class="number">0</span>。建议使用文件的长度。</span><br><span class="line">                获取文件的长度：stat lseek</span><br><span class="line">        - prot : 对申请的内存映射区的操作权限</span><br><span class="line">            -PROT_EXEC ：可执行的权限</span><br><span class="line">            -PROT_READ ：读权限</span><br><span class="line">            -PROT_WRITE ：写权限</span><br><span class="line">            -PROT_NONE ：没有权限</span><br><span class="line">            要操作映射内存，必须要有读的权限。</span><br><span class="line">            PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">        - flags :</span><br><span class="line">            - MAP_SHARED : <span class="comment">//映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span></span><br><span class="line">            - MAP_PRIVATE ：<span class="comment">//不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）,可以用内存映射来存输入，之后用于写入</span></span><br><span class="line">        - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">            - 通过open得到，open的是一个磁盘文件</span><br><span class="line">            - 注意：文件的大小不能为<span class="number">0</span>，open指定的权限不能和prot参数有冲突，也就是不小于需要的权限。</span><br><span class="line">                prot: PROT_READ                open:只读/读写 </span><br><span class="line">                prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">        - offset：偏移量，一般不用。必须指定的是<span class="number">4</span>k的整数倍，<span class="number">0</span>表示不偏移。</span><br><span class="line">    - 返回值：返回创建的内存的首地址</span><br><span class="line">        失败返回MAP_FAILED，(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line">    - 功能：释放内存映射</span><br><span class="line">    - 参数：</span><br><span class="line">        - addr : 要释放的内存的首地址</span><br><span class="line">        - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样</span><br></pre></td></tr></table></figure><h5 id="使用内存映射实现进程间通信："><a href="#使用内存映射实现进程间通信：" class="headerlink" title="使用内存映射实现进程间通信："></a>使用内存映射实现进程间通信：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">使用内存映射实现进程间通信：</span><br><span class="line">1.有关系的进程（父子进程）</span><br><span class="line">    - 还没有子进程的时候</span><br><span class="line">        - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">    - 有了内存映射区以后，创建子进程</span><br><span class="line">    - 父子进程共享创建的内存映射区（类似于匿名管道）</span><br><span class="line"></span><br><span class="line">2.没有关系的进程间通信</span><br><span class="line">    - 准备一个大小不是0的磁盘文件</span><br><span class="line">    - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">        - 得到一个操作这块内存的指针</span><br><span class="line">    - 使用内存映射区通信（也就是映射同一块文件）</span><br><span class="line"></span><br><span class="line">注意：内存映射区通信，是非阻塞。</span><br></pre></td></tr></table></figure><h6 id="关系类进程通信"><a href="#关系类进程通信" class="headerlink" title="关系类进程通信"></a>关系类进程通信</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="comment">//创建内存映射区    </span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程，写入，父进程接受</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程读取</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,(<span class="type">char</span>*)ptr);<span class="comment">//相当于 把指针指向的内存地址的内容，写到buf中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写入</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;我是儿子，你好&quot;</span>);<span class="comment">//相当于往指针指向内存的位置写入这个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr,size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="非关系类进程通信"><a href="#非关系类进程通信" class="headerlink" title="非关系类进程通信"></a>非关系类进程通信</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">write.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程写入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建内存映射区    </span></span><br><span class="line">        <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;好哥们 你好\n&quot;</span>);       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭内存映射区</span></span><br><span class="line">        munmap(ptr,size);        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">read.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程读取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建内存映射区    </span></span><br><span class="line">        <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,(<span class="type">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s&quot;</span>,buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭内存映射区</span></span><br><span class="line">        munmap(ptr,size);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h5><ol><li><p>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<br>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p></li><li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<br>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p></li><li><p>如果文件偏移量为1000会怎样?<br>偏移量必须是4K的整数倍，返回MAP_FAILED</p></li><li><p>mmap什么情况下会调用失败?<br>- 第二个参数：length &#x3D; 0<br>    - 第三个参数：prot<br>    - 只指定了写权限<br>    - prot PROT_READ | PROT_WRITE<br>      第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY</p></li><li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?<br>- 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>    - 可以对新的文件进行扩展<br>    - lseek()<br>    - truncate()</p></li><li><p>mmap后关闭文件描述符，对mmap映射有没有影响？<br>int fd &#x3D; open(“XXX”);<br>mmap(,,,,fd,0);<br>close(fd);<br>映射区还存在，创建映射区的fd被关闭，没有任何影响。</p></li><li><p>对ptr越界操作会怎样？<br>void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p></li></ol><p>​       void *memcpy(void *dest, const void *src, size_t n);</p><h4 id="使用内存映射实现文件的拷贝"><a href="#使用内存映射实现文件的拷贝" class="headerlink" title="使用内存映射实现文件的拷贝"></a>使用内存映射实现文件的拷贝</h4><ul><li>使用内存映射实现文件拷贝的功能<br>  思路：<br>  1.对原始的文件进行内存映射<br>  2.创建一个新文件（拓展该文件）<br>  3.把新文件的数据映射到内存中<br>  4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中<br>  5.释放资源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新文件（拓展该文件）</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> * ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存拷贝 memcpy内存拷贝函数 在man 3 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名内存映射"><a href="#匿名内存映射" class="headerlink" title="匿名内存映射"></a>匿名内存映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名映射：不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//此处添加ANONYMOUS，表示映射没有任何文件支持，也就是匿名内存映射不需要任何文件支持，所以下一个文件描述符参数作为-1</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *) ptr, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-信号"><a href="#2-6-信号" class="headerlink" title="2.6 信号"></a>2.6 信号</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li><p>概述 : 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也<br>称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号<br>可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p></li><li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p><ol><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C<br>通常会给进程发送一个中断信号。</li><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给<br>相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的<br>内存区域。</li><li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU<br>时间超限，或者该进程的某个子进程退出。</li><li>运行 kill 命令或调用 kill 函数。</li></ol></li><li><p>使用信号的两个主要目的是：</p><ol><li>让进程知道已经发生了一个特定的事情。</li><li>强迫进程执行 它自己代码中的信号处理程序。</li></ol></li><li><p>信号的特点：</p><ol><li>简单</li><li>不能携带大量信息</li><li>满足某个特定条件才发送</li><li>优先级比较高</li></ol></li><li><pre><code class="shell">1. 查看系统定义的信号列表：kill –l前 31 个信号为常规信号，其余为实时信号2. ◼ 查看信号的详细信息：man 7 signal◼ 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件(Core文件包含了一些关于异常的信息) Stop 暂停当前进程 Cont 继续执行当前被暂停的进程3. 信号的几种状态：产生、未决、递达4. SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230225153502429.png&quot; alt=&quot;image-20230225153502429&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230225153518112.png&quot; alt=&quot;image-20230225153518112&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230225153533345.png&quot; alt=&quot;image-20230225153533345&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230225153713035.png&quot; alt=&quot;image-20230225153713035&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  * 这里注意kill 9不能杀死僵尸进程</span><br><span class="line">  * 可以用kill -l查看信号对应的编号</span><br><span class="line"></span><br><span class="line">##### kill() raise() abort()</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">    - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">    - 参数：</span><br><span class="line">        - pid ：</span><br><span class="line">            &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">            = 0 : 将信号发送给当前的进程组</span><br><span class="line">            = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">            &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="line">        - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">    kill(getppid(), 9);</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">    </span><br><span class="line">int raise(int sig);</span><br><span class="line">    - 功能：给当前进程或者线程发送信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - sig : 要发送的信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功 0</span><br><span class="line">        - 失败 非0</span><br><span class="line">    kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">void abort(void);</span><br><span class="line">    - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">    类似于: kill(getpid(), SIGABRT);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0) &#123;</span><br><span class="line">        // 子进程</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            printf(&quot;child process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if(pid &gt; 0) &#123;</span><br><span class="line">        // 父进程</span><br><span class="line">        printf(&quot;parent process\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;kill child process now\n&quot;);//这里传的是子进程pid</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### alarm() </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">    - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="line">            函数会给当前的进程发送一个信号：SIGALARM，（查表，会终止进程）</span><br><span class="line">    - 参数：</span><br><span class="line">        seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">                取消一个定时器，通过alarm(0)。</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 之前没有定时器，返回0</span><br><span class="line">        - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">- SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">    alarm(10);  -&gt; 返回0</span><br><span class="line">    过了1秒</span><br><span class="line">    alarm(5);   -&gt; 返回9</span><br><span class="line"></span><br><span class="line">alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 例子</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">//查看1秒计算机能数多少个数？</span><br><span class="line">/*</span><br><span class="line">    实际时间 = 内核时间 + 用户时间 + 消耗时间</span><br><span class="line">    进行文件的IO操作比较消耗时间</span><br><span class="line"></span><br><span class="line">    定时器，与进程的状态无关，alarm都会计时</span><br><span class="line">*/</span><br><span class="line">int main()&#123;</span><br><span class="line">    alarm(1);</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##### setitimer()</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    #include &lt;sys/time.h&gt;</span><br><span class="line">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="line">                        struct itimerval *old_value);</span><br><span class="line">   - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">        - which : 定时器以什么时间计时</span><br><span class="line">          ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="line">          ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">          ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line"></span><br><span class="line">        - new_value: 设置定时器的属性</span><br><span class="line">        </span><br><span class="line">            struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">            struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">            struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct timeval &#123;        // 时间的结构体</span><br><span class="line">                time_t      tv_sec;     //  秒数     </span><br><span class="line">                suseconds_t tv_usec;    //  微秒    </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        过10秒后，每个2秒定时一次</span><br><span class="line">       </span><br><span class="line">        - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">    </span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 0</span><br><span class="line">        失败 -1 并设置错误号</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##### signal 捕捉函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    typedef void (*sighandler_t)(int);</span><br><span class="line">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">        - 功能：设置某个信号的捕捉行为</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum: 要捕捉的信号</span><br><span class="line">            - handler: 捕捉到信号要如何处理</span><br><span class="line">                - SIG_IGN ： 忽略信号</span><br><span class="line">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">                回调函数：</span><br><span class="line">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">            失败，返回SIG_ERR，设置错误号</span><br><span class="line">            </span><br><span class="line">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 例子： 用setitimer配合signal捕捉</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">//设置回调函数</span><br><span class="line">void myAlarm(int num)&#123;</span><br><span class="line">    //这里可以查表得到信号14是SIGALRM</span><br><span class="line">    printf(&quot;捕捉到了信号编号是: %d\n&quot;,num);</span><br><span class="line">    printf(&quot;xxxxxxxxxxxx\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">  // 注册信号捕捉</span><br><span class="line">    // signal(SIGALRM, SIG_IGN);</span><br><span class="line">    // signal(SIGALRM, SIG_DFL);</span><br><span class="line">    // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span><br><span class="line">    signal(SIGALRM,myAlarm);</span><br><span class="line"></span><br><span class="line">    //设置间隔时间</span><br><span class="line">    struct itimerval new_value;</span><br><span class="line">    //时间变量必须要初始化</span><br><span class="line">    new_value.it_interval.tv_sec = 2;</span><br><span class="line">    new_value.it_interval.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    //延迟时间,到3s后开始计时</span><br><span class="line">    new_value.it_value.tv_sec = 3;</span><br><span class="line">    new_value.it_value.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">     //是非阻塞的   </span><br><span class="line">    int ret = setitimer(ITIMER_REAL,&amp;new_value,NULL);</span><br><span class="line">    printf(&quot;开始计时\n&quot;);</span><br><span class="line">    if(ret == -1)&#123;</span><br><span class="line">        perror(&quot;setitimer&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">//保存程序不关闭 阻塞</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 2.7信号集</span><br><span class="line"></span><br><span class="line">* 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</span><br><span class="line">* 在 PCB 中有两个非常重要的信号集。一个称之为 “**阻塞信号集**”（**信号掩码（也就是阻塞信号集）**可以设置，比如empty和add） ，另一个称之为“**未决信号集**” （只读）。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。</span><br><span class="line">* 信号的 “未决” 是一种**状态**，指的是从**信号的产生到信号被处理前**的这一段时间。</span><br><span class="line">* 信号的 “阻塞” 是一个**开关动作**，指的是**阻止信号被处理**，但不是阻止信号产生。</span><br><span class="line">* 信号的**阻塞就是让系统暂时保留信号留待以后发送**。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</span><br><span class="line">* 下图，进程的虚拟地址空间，包括用户区和内核区，内核区中有PCB进程控制块，PCB中有未决信号集和阻塞信号集 </span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\MyTxt\typoraPhoto\image-20230226152103733.png&quot; alt=&quot;image-20230226152103733&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">~~~shell</span><br><span class="line">1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</span><br><span class="line"></span><br><span class="line">2.信号产生但是没有被处理 （未决）</span><br><span class="line">    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</span><br><span class="line">    - SIGINT信号状态被存储在第二个标志位上</span><br><span class="line">        - 这个标志位的值为0， 说明信号不是未决状态</span><br><span class="line">        - 这个标志位的值为1， 说明信号处于未决状态</span><br><span class="line">    </span><br><span class="line">3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</span><br><span class="line">    - 阻塞信号集默认不阻塞任何的信号</span><br><span class="line">    - 如果想要阻塞某些信号需要用户调用系统的API</span><br><span class="line"></span><br><span class="line">4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</span><br><span class="line">    - 如果没有阻塞，这个信号就被处理</span><br><span class="line">    - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">以下信号集相关的函数都是对     自定义的信号集!!     进行操作。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">    - 功能：清空信号集中的数据,将信号集中的所有的标志位置为<span class="number">0</span></span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">    - 功能：将信号集中的所有的标志位置为<span class="number">1</span></span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，需要操作的信号集</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为<span class="number">1</span>，表示阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：设置信号集中的某一个信号对应的标志位为<span class="number">0</span>，表示不阻塞这个信号</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：传出参数，需要操作的信号集</span><br><span class="line">        - signum：需要设置不阻塞的那个信号</span><br><span class="line">    - 返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">    - 功能：判断某个信号是否阻塞</span><br><span class="line">    - 参数：</span><br><span class="line">        - <span class="built_in">set</span>：需要操作的信号集</span><br><span class="line">        - signum：需要判断的那个信号</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">1</span> ： signum被阻塞</span><br><span class="line">        <span class="number">0</span> ： signum不阻塞</span><br><span class="line">        <span class="number">-1</span> ： 失败</span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空信号集的内容 初始化的时候常用</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="type">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sigprocmask-修改内核阻塞信号集"><a href="#sigprocmask-修改内核阻塞信号集" class="headerlink" title="sigprocmask() 修改内核阻塞信号集"></a>sigprocmask() 修改内核阻塞信号集</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">    - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    - 参数：</span><br><span class="line">        - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">            SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变;</span><br><span class="line">                假设内核中默认的阻塞信号集是mask， mask | <span class="built_in">set</span> <span class="comment">//(因为1代表阻塞，所以用或)</span></span><br><span class="line">            SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞;</span><br><span class="line">                mask &amp;= ~<span class="built_in">set</span> <span class="comment">//(先取反 再与）</span></span><br><span class="line">             <span class="comment">//这里要记住 | 运算的取消是 &amp;=~</span></span><br><span class="line">            SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line">        </span><br><span class="line">        - <span class="built_in">set</span> ：已经初始化好的用户自定义的信号集</span><br><span class="line">        - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="literal">NULL</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：<span class="number">-1</span></span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line">    - 功能：获取内核中的未决信号集</span><br><span class="line">    - 参数：<span class="built_in">set</span>,传出参数，保存的是内核中的未决信号集中的信息。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span></span><br><span class="line"><span class="comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置信号集，设置2 ，3号信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//把2,3号信号添加到set</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改内核中阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//获取当前未决的信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历前32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pendingset,i) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pendingset,i) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//解除阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction()信号捕捉函数"></a>sigaction()信号捕捉函数</h5><ul><li>最好用sigaction,而不是signal，因为标准可能不太一样</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">            - act ：捕捉到信号之后的处理动作</span><br><span class="line">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递<span class="literal">NULL</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功 <span class="number">0</span></span><br><span class="line">            失败 <span class="number">-1</span></span><br><span class="line"><span class="comment">/*sigaction的回调函数int类型参数，就是信号类型的宏定义；</span></span><br><span class="line"><span class="comment">这样可以用管道搭配epoll来读传入的信号：</span></span><br><span class="line"><span class="comment">1.用sig的回调函数向fd[1]写，传到fd[0]读端 </span></span><br><span class="line"><span class="comment">2.然后把fd[0]加入epoll实例，就可以IO多路复用，得到突然传入的sig，并且用Switch判断sig的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">        <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">        <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="comment">// 不常用</span></span><br><span class="line">        <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">        <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。回调函数执行完之后，会转换到系统的阻塞信号集。这里一般需要把该临时阻塞信号集清空sigemptyset()</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">        <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">        <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">        <span class="type">int</span>        sa_flags;</span><br><span class="line">        <span class="comment">// 被废弃掉了</span></span><br><span class="line">        <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉特性：</span></span><br><span class="line"><span class="number">1.</span> 信号捕捉过程中会使用临时的阻塞信号集，处理完后，切换恢复到内核的阻塞信号集</span><br><span class="line"><span class="number">2.</span> 在回调sa_handler函数的期间，默认会屏蔽该函数的调用，执行完之后，才能继续处理</span><br><span class="line"><span class="number">3.</span> 信号集只是标志位，不能支持排队</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="D:\MyTxt\typoraPhoto\image-20230226165653806.png" alt="image-20230226165653806" style="zoom: 80%;" /><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);  <span class="comment">// 清空临时阻塞信号集</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SIGCHLD信号-回收子进程"><a href="#SIGCHLD信号-回收子进程" class="headerlink" title="SIGCHLD信号 - 回收子进程"></a>SIGCHLD信号 - 回收子进程</h5><ul><li>SIGCHLD信号产生的条件</li></ul><ol><li>子进程终止时</li><li>子进程接收到 SIGSTOP 信号停止时</li><li>子进程处在停止态，接受到SIGCONT后唤醒时</li></ol><p>  以上三种条件都会给父进程发送 SIGCHLD 信号，<strong>父进程默认会忽略该信号</strong></p><h6 id="SIGCHLD-实现回收子进程-比较常用配合waitpid来批量回收子进程"><a href="#SIGCHLD-实现回收子进程-比较常用配合waitpid来批量回收子进程" class="headerlink" title="SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程"></a>SIGCHLD 实现回收子进程 - 比较常用配合waitpid来批量回收子进程</h6><ul><li>不阻塞父进程；提前捕捉，防止全死完了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   使用SIGCHLD信号解决僵尸进程的问题。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子进程的Callback function</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,num);</span><br><span class="line">    <span class="comment">//回收子进程PCB</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//wait调用一次只能回收一个，如果多个子进程同时死了，例如4个，那么肯定会发送4次信号，但是有可能有些信号会被忽略掉，所以要循环把所有的死了的子进程都回收掉用waitpid()配合循环。</span></span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//回收了一个子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;回收死亡的子进程：%d\n&quot;</span>,ret);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//rer == 0还有子进程活着,等他们死</span></span><br><span class="line">            <span class="comment">//ret &lt; 0没有活着的子进程了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="comment">/*1. 这里理解好阻塞:阻塞是接受了不处理。</span></span><br><span class="line"><span class="comment">      2. 为什么先阻塞SIGCHLD就可以保证父进程能处理所有僵尸进程？设置了SIGCHLD在阻塞信号集中阻塞的1，你们只要是          只要曾经收到过SIGCHLD，未决就会保持1；等待之后父进程sigaction去处理，sigcation处理完之后置0；这里父进          程去处理的时候，只要未决是1，也就是不用考虑有多少个已经死了，只要知道有僵尸子进程，就可以用while循环加上          waitpid全部回收完成；</span></span><br><span class="line"><span class="comment">      补充：因为对SIGCHILD信号的默认处理是将其忽略（此时捕捉信号函数还没有注册），如果没有阻塞，直接忽略掉，那父进程就不知道之前发生了什么事情。</span></span><br><span class="line"><span class="comment">      3.《Linux/UNIX系统编程手册》指出为了保障可移植性，应用应在创建任何子进程之前就设置信号捕捉函数。【牛客789400243号】提出了这个观点，应该在fork之前就注册信号捕捉的。其实就是对应了书上这句话。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一些子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程在不阻塞情况下，回收子进程PCB</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//设置捕捉子进程死亡的SIGCHLD</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了不阻塞父进程自己的事情，在此处打开</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//父进程自己的事情</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid: %d\n&quot;</span>,getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid: %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8共享内存"><a href="#2-8共享内存" class="headerlink" title="2.8共享内存"></a>2.8共享内存</h3><ol><li>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制<strong>无需内核介入</strong>（较少介入）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li><li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</li></ol><h5 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h5><ol><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的<strong>共享内存标识符</strong>。</li><li>使用 shmat() 来<strong>附上</strong>共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li><li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个<strong>指向进程的虚拟地址空间中该共享内存段的起点的指针</strong>。</li><li>调用 shmdt() 来<strong>分离</strong>共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li><li>调用 shmctl() 来<strong>删除</strong>共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</li></ol><h5 id="共享内存函数"><a href="#共享内存函数" class="headerlink" title="共享内存函数"></a>共享内存函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁 <span class="comment">//因为有多个进程指向，类似于智能指针，全部标记销毁就销毁</span></span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节<span class="number">8</span>个位</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>例子：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">read_shm.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个进程</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>,<span class="number">4096</span>,IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share memery id:%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="comment">//2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//3. 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">//4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.删除共享内存</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">write_shm.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个进程</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>,<span class="number">4096</span>,IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share memery id:%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="comment">//2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.删除共享内存</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="共享内存操作命令"><a href="#共享内存操作命令" class="headerlink" title="共享内存操作命令"></a>共享内存操作命令</h5><ol><li>ipcs 用法<br> ipcs -a &#x2F;&#x2F; 打印当前系统中<strong>所有的进程间</strong>通信方式的信息<br> ipcs -m &#x2F;&#x2F; 打印出<strong>使用共享内存</strong>进行进程间通信的信息<br> ipcs -q &#x2F;&#x2F; 打印出<strong>使用消息队列</strong>进行进程间通信的信息<br> ipcs -s &#x2F;&#x2F; 打印出<strong>使用信号进行进程间通信</strong>的信息</li><li>ipcrm 用法<br>    ipcrm -M shmkey    &#x2F;&#x2F; 移除用shmkey创建的共享内存段<br>    ipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段<br>    ipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列<br>    ipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列<br>    ipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号<br>    ipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号</li></ol><h5 id="基础问题："><a href="#基础问题：" class="headerlink" title="基础问题："></a>基础问题：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">问题1：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br><span class="line"></span><br><span class="line">问题2：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为0的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为0的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br><span class="line"></span><br><span class="line">问题3：共享内存和内存映射的区别</span><br><span class="line">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="line">    2.共享内存效果更高</span><br><span class="line">    3.内存</span><br><span class="line">        所有的进程操作的是同一块共享内存。</span><br><span class="line">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="line">    4.数据安全</span><br><span class="line">        - 进程突然退出</span><br><span class="line">            共享内存还存在</span><br><span class="line">            内存映射区消失</span><br><span class="line">        - 运行进程的电脑死机，宕机了</span><br><span class="line">            数据存在在共享内存中，没有了</span><br><span class="line">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="line"></span><br><span class="line">    5.生命周期</span><br><span class="line">        - 内存映射区：进程退出，内存映射区销毁</span><br><span class="line">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span><br><span class="line">            如果一个进程退出，会自动和共享内存进行取消关联。</span><br></pre></td></tr></table></figure><h3 id="2-9守护进程"><a href="#2-9守护进程" class="headerlink" title="2.9守护进程"></a>2.9守护进程</h3><h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><p> 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的<strong>控制终端（Controlling Terminal）</strong>，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。</p><p>默认情况下（没有重定向），每个进程的<strong>标准输入、标准输出和标准错误输出都指向控制终端</strong>，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p><p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</p><h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><p>进程组和会话在进程之间形成了一种两级层次关系：<strong>进程组是一组相关进程的集合，会话是一组相关进程组的集合</strong>。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p><p>进程组由一个或多个共享<strong>同一进程组标识符（PGID）</strong>的进程组成。一个进程组拥有一个进程组<strong>首进程</strong>，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。</p><p>进程组拥有一个生命周期，其开始时间为<strong>首进程创建组的时刻</strong>，结束时间为<strong>最后一个</strong><br><strong>成员进程退出组的时刻</strong>。一个进程可能会因为终止而退出进程组，也可能会因为加入<br>了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p><h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><p>◼ 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会<br>话 ID。新进程会继承其父进程的会话 ID（<strong>SID</strong>）。</p><p>◼ 一个会话中的所有进程<strong>共享单个控制终端</strong>。控制终端会在会话首进程首次打开一个终<br>端设备时被建立。一个终端最多可能会成为<strong>一个</strong>会话的控制终端。</p><p>◼ 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为<br>后台进程组。只有<strong>前台进程组中的进程才能从控制终端中读取输入</strong>。当用户在控制终<br>端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p><p>◼ 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p><p><img src="D:\MyTxt\typoraPhoto\image-20230227112850159.png" alt="image-20230227112850159"></p><ul><li>进程组、会话操作函数</li></ul><p>◼ pid_t getpgrp(void);<br>◼ pid_t getpgid(pid_t pid);<br>◼ int setpgid(pid_t pid, pid_t pgid);<br>◼ pid_t getsid(pid_t pid);<br>◼ pid_t setsid(void);</p><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>◼ 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是<br>Linux 中的<strong>后台服务进程</strong>。它是一个生存期较长的进程，通常独立于控制终端并且周<br>期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>◼ 守护进程具备下列特征：</p><ol><li>生命周期很长，守护进程会在系统启动的时候被<strong>创建并一直运行直至系统被关闭</strong>。</li><li>它在后台运行并且<strong>不拥有控制终端</strong>。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li></ol><ul><li>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</li></ul><h6 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h6><p>◼ 执行一个 fork()，之后父进程退出，子进程继续执行。（1. 防止父进程死亡后出现shell提示符；2.防止该进程成为组进程的首进程）</p><p>◼ 子进程调用 setsid() 开启一个新会话。</p><p>◼ 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。<br>◼ 修改进程的当前工作目录，通常会改为根目录（&#x2F;）。<br>◼ 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>◼ 在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2()<br>使所有这些描述符指向这个设备。<br>◼ 核心业务逻辑</p><ul><li>例子：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个守护进程，每隔两秒获取系统时间，并且把这个时间写入到磁盘文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="comment">//捕捉到定时信号之后，获取系统时间，写入磁盘文件</span></span><br><span class="line">    <span class="type">time_t</span> tm =time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">// //直接打印,但是文件描述符 1 2 3都已经重定向了，所以打印不到终端</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf,&quot;%d-%d-%d,%d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon,loc-&gt;tm_mday,</span></span><br><span class="line">    <span class="comment">// loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化时间，写入磁盘文件中</span></span><br><span class="line">    <span class="type">char</span>* str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>,O_RDWR|O_CREAT|O_APPEND,<span class="number">0664</span>);</span><br><span class="line">    write(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//守护进程创建步骤</span></span><br><span class="line">    <span class="comment">//1.创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.子进程开启新会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置掩码 信号掩码（也就是阻塞信号集）</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改进程的当前工作目录（注意权限）</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/klchen/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.关闭、重定向文件描述符(让标准输入、输出、错误，也就是0 1 2重定向到那个设备)</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕捉定时信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myFun;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec =<span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec =<span class="number">0</span>; </span><br><span class="line">    setitimer(ITIMER_REAL,&amp;val,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持进程不关闭</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Linux多线程开发"><a href="#3-Linux多线程开发" class="headerlink" title="3.Linux多线程开发"></a>3.Linux多线程开发</h2><h3 id="3-1线程概述"><a href="#3-1线程概述" class="headerlink" title="3.1线程概述"></a>3.1线程概述</h3><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机<br>制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p><ul><li><p><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p></li><li><p>线程是<strong>轻量级的进程</strong>（<strong>LWP</strong>：Light Weight Process），在 Linux 环境下线程的本<br>质仍是进程。</p></li><li><p>查看指定进程的 LWP 号：ps –Lf pid</p></li><li><p>共享资源<br> 进程 ID 和父进程 ID<br> 进程组 ID 和会话 ID<br> 用户 ID 和 用户组 ID<br> 文件描述符表<br> 信号处置<br> 文件系统的相关信息：文件权限掩码<br>（umask）、当前工作目录<br> 虚拟地址空间（除栈、.text）&#x2F;&#x2F;这两个会被划分</p></li><li><p>非共享资源<br> 线程 ID<br> 信号掩码<br> 线程特有数据<br> error 变量<br> 实时调度策略和优先级<br> 栈，本地变量和函数的调用链接信息</p></li><li><p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p></li></ul><h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><ol><li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</li><li>调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。</li><li>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</li><li>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。</li></ol><h3 id="3-2线程操作"><a href="#3-2线程操作" class="headerlink" title="3.2线程操作"></a>3.2线程操作</h3><h5 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span><br><span class="line">称之为子线程。</span><br><span class="line">程序中默认只有一个进程，fork()函数调用，<span class="number">2</span>个进程</span><br><span class="line">程序中默认只有一个线程，pthread_create()函数调用，<span class="number">2</span>个线程。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">    - 功能：创建一个子线程</span><br><span class="line">    - 参数：</span><br><span class="line">        - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span><br><span class="line">        - attr : 设置线程的属性，一般使用默认值，<span class="literal">NULL</span></span><br><span class="line">        - start_routine : <span class="comment">//函数指针，这个函数是子线程需要处理的逻辑代码,注意函数返回值void*,俺的理解是调用函数指针后，还是需要返回值告诉主线程创建子线程及子线程工作的成功与否，与前面的sigaction信号触发后的回调函数不一样，那个不需要返回执行正确与否</span></span><br><span class="line">        - arg : 给第三个参数使用，传参</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号。这个错误号和之前errno不太一样。</span><br><span class="line">        获取错误号的信息：  <span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure><ul><li>例子-gcc pthread_create.c -o pthread_create -lpthread</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意线程不是标准库 ，需要指定第三方库名称 -l pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 子线程创建的callback Fuction, 子线程需要处理的逻辑代码，传入参数指定为任意类型指针 2. 此处返回的是void*类型 返回任意类型指针 </span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg: %d\n&quot;</span>,*((<span class="type">int</span>*)arg));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main()函数都在主线程中执行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试callback的传入参数</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个子线程,测试回调函数及其参数</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,(<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *error = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s&quot;</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">    功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span><br><span class="line">    参数：</span><br><span class="line">        retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。(类似于<span class="keyword">return</span> (<span class="type">void</span>*)&amp;value;)</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    功能：获取当前的线程的线程ID</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">    功能：比较两个线程ID是否相等</span><br><span class="line">    不同的操作系统，<span class="type">pthread_t</span>类型的实现不一样，有的是无符号的长整型，有的</span><br><span class="line">    是使用结构体去实现的。</span><br></pre></td></tr></table></figure><ul><li>例子-线程退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//相当于pthread_exit(NULL);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//mian thread已经退出，之后代码不会运行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="连接已终止的线程-线程回收"><a href="#连接已终止的线程-线程回收" class="headerlink" title="连接已终止的线程 - 线程回收"></a>连接已终止的线程 - 线程回收</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line">    - 功能：和一个已经终止的线程进行连接</span><br><span class="line">            回收子线程的资源</span><br><span class="line">            这个函数是阻塞函数，调用一次只能回收一个子线程</span><br><span class="line">            一般在主线程中使用</span><br><span class="line">    - 参数：</span><br><span class="line">        - thread：需要回收的子线程的ID</span><br><span class="line">        - retval: 接收子线程退出时的返回值</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">0</span> : 成功</span><br><span class="line">        非<span class="number">0</span> : 失败，返回的错误号</span><br></pre></td></tr></table></figure><ul><li>例子-回收子线程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">//退出并且设置返回值</span></span><br><span class="line">    pthread_exit((<span class="type">void</span>*)&amp;num);<span class="comment">//相当于 return (void*)&amp;num              </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> * error1 = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s&quot;</span>,error1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程的事情</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i != <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld,main thread tid:%ld&quot;</span>,tid,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主进程调用pthread_exit()回收子线程的资源</span></span><br><span class="line">    <span class="type">int</span> *thread_return;</span><br><span class="line">    <span class="comment">//二级指针，因为传出参数是指针，需要用二级指针指向他</span></span><br><span class="line">    ret = pthread_join(tid,(<span class="type">void</span>**)&amp;thread_return);</span><br><span class="line">    <span class="keyword">if</span> (ret !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *error2 = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>,error2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data: %d\n&quot;</span>,*thread_return);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程回收成功!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span><br><span class="line">      <span class="number">1.</span>不能多次分离，会产生不可预料的行为。</span><br><span class="line">      <span class="number">2.</span>不能去连接一个已经分离的线程，会报错。</span><br><span class="line">    - 参数：需要分离的线程的ID</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号</span><br></pre></td></tr></table></figure><ul><li>例子：线程分离</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分离后，对分离的子线程进行连接 ,连接不上了哦 pthread_join()</span></span><br><span class="line">    <span class="comment">// ret = pthread_join(tid, NULL);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) &#123;</span></span><br><span class="line">    <span class="comment">//     char * errstr = strerror(ret);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;error3 : %s\n&quot;, errstr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：取消线程（让线程终止）</span><br><span class="line">        取消某个线程，可以终止某个线程的运行，</span><br><span class="line">        但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</span><br><span class="line">        取消点cancellaction point：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">callback</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//printf是一个取消点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    - 初始化线程属性变量</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    - 释放线程属性的资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line">    - 获取线程分离的状态属性</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">    - 设置线程分离的状态属性</span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建线程属性变量</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">//初始化attr</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性变量为分离</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//创建的时候添加参数attr，设置分离</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid,&amp;attr,callback,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *errst = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1:%s\n&quot;</span>,errst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出线程id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld,main thread id: %ld\n&quot;</span>,tid,pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放线程资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3线程同步"><a href="#3-3线程同步" class="headerlink" title="3.3线程同步"></a>3.3线程同步</h3><ul><li><p>线程同步</p><ol><li>线程的主要优势在于，能够通过<strong>全局变量来共享信息</strong>。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li><li><strong>临界区</strong>是指访问某一<strong>共享资源的代码片段</strong>，并且这段代码的执行应为<strong>原子操作</strong>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</li><li><strong>线程同步</strong>：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li></ol></li><li><p>互斥量</p></li></ul><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共<br>享资源的原子访问。</p><ol><li>互斥量有两种状态：已锁定（locked）和未锁（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法 。</li><li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问</li><li>同一资源时将采用如下协议 ：<br>⚫ 针对共享资源锁定互斥量<br>⚫ 访问共享资源<br>⚫ 对互斥量解锁</li></ol><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域。</p><img src="D:\MyTxt\typoraPhoto\image-20230228103959862.png" alt="image-20230228103959862" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">互斥量的类型 <span class="type">pthread_mutex_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">    - 初始化互斥量</span><br><span class="line">    - 参数 ：</span><br><span class="line">        - mutex ： 需要初始化的互斥量变量</span><br><span class="line">        - attr ： 互斥量相关的属性，<span class="literal">NULL</span></span><br><span class="line">    - <span class="keyword">restrict</span> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。</span><br><span class="line">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex = xxx;</span><br><span class="line">        <span class="type">pthread_mutex_t</span> * mutex1 = mutex;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 释放互斥量的资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">    - 解锁</span><br></pre></td></tr></table></figure><ul><li>例子 - 用三个线程并发卖票，保证同步互斥</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建全局的互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> ticket = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//子线程 共享函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sellticket</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"><span class="comment">//卖票</span></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld正在卖第 %d 张票\n&quot;</span>,pthread_self(),ticket--);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//注意加锁之后要保证能够解锁，特别注意break,exit()这些直接退出的</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">6000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3,<span class="literal">NULL</span>,sellticket,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收子线程资源，阻塞</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放互斥资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        <span class="comment">//主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p> 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互<br>斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。<br>◼ <strong>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象</strong>，<br>若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p><ul><li>死锁的几种场景：<ol><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占锁资源</li></ol></li></ul><img src="D:\MyTxt\typoraPhoto\image-20230228111719038.png" alt="image-20230228111719038" style="zoom: 50%;" /><ul><li>演示死锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1, mutex2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">workA</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="comment">//首先，在 workA 中使用 pthread_mutex_lock(&amp;mutex1) 对线程A进行加锁，但是由于 cpu 执行的速度很快，导致在 workB 中，还没有使用 pthread_mutex_lock(&amp;mutex2) 对线程B进行加锁，workA就继续向下执行，因为资源 B 并没有被线程 B 加锁，所以在 workA 中的 pthread_mutex_lock(&amp;mutex2) 并未处于阻塞状态</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果B已经锁住了，那这里A就阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workA....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">workB</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这个因为A已经锁了，B阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workB....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, workA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, workB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>读写锁<br>◼ 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的<strong>绝对排它性</strong>，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。<br>◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。<br>为了满足当前能够<strong>允许多个读出，但只允许一个写入的需求</strong>，线程提供了读写锁来实现。</p><ul><li>读写锁的特点：<ol><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作。</li><li>写是独占的，写的优先级高。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 <span class="type">pthread_rwlock_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line">案例：<span class="number">8</span>个线程操作同一个全局变量。</span><br><span class="line"><span class="number">3</span>个线程不定时写这个全局变量，<span class="number">5</span>个线程不定时的读这个全局变量</span><br></pre></td></tr></table></figure><ul><li>例子 - 读写锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8个线程操作一个全局变量，3个写，5个读</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> num =<span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//写区锁</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write,tid: %ld,num: %d\n&quot;</span>,pthread_self(),num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//读区锁</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程创建</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>],rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i],<span class="literal">NULL</span>,writeNum,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i],<span class="literal">NULL</span>,readNum,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(wtid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(rtid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁，主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥结构-粗略版本的生产消费者模型，可能会导致已放弃 (核心已转储)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//队列方式读取，实际上是back指针，插入的时候用头插法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者 不断添加节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode -&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode -&gt;num = rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d,tid: %ld\n&quot;</span>,newNode-&gt;num,pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 获取节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">custmer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//同一块临界区，设置为都互斥</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node,num: %d,tid: %ld\n&quot;</span>,tmp-&gt;num,pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没了，快做\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//5个生产者线程，5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>],ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i],<span class="literal">NULL</span>,custmer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(ptid[i]);</span><br><span class="line">        pthread_detach(ctid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出主线程，释放锁</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完整的生产者消费者模型代码 - 固定缓冲区大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">int</span> *buf;</span><br><span class="line"><span class="type">int</span> bufSize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> bufPtr;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="comment">//三个信号量</span></span><br><span class="line"><span class="type">sem_t</span> full, empty, mutex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (bufPtr &lt; bufSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//信号量模型</span></span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        buf[++bufPtr] = bufPtr;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//信号量模型</span></span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        count = (count + <span class="number">1</span>) % __INT32_MAX__;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid[%ld], count[%d], data[%d]\n&quot;</span>, pthread_self(), count, buf[bufPtr--]);</span><br><span class="line"> </span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化三个信号量</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, bufSize);</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化读写指针、缓冲区</span></span><br><span class="line">    bufPtr = <span class="number">-1</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    buf = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * bufSize);</span><br><span class="line">    <span class="comment">//创建6个线程，一个作生产者，5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ppid, cpids[<span class="number">5</span>];</span><br><span class="line">    pthread_create(&amp;ppid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;cpids[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//detach分离，线程自动回收资源</span></span><br><span class="line">    pthread_detach(ppid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(cpids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程结束</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>某个条件满足之后开启或者解除阻塞;</p><ul><li>《Liunx&#x2F;UNIX系统编程手册》第531页有句话，条件变量并不保存状态信息，只是传递应用程序状态信息的一种通讯机制。发送信号时若无任何线程在等待该条件变量，这个也就会不了了之。线程如在此后等待该条件变量，只有当再次收到此变量的下一信号时，方可解除阻塞状态。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">条件变量的类型 <span class="type">pthread_cond_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">    - 等待，调用了该函数，线程会阻塞。<span class="comment">//1.这个函数调用阻塞的时候，会对互斥锁mutex解锁；当收到signal或者broadcasr的时候，取消阻塞，这个时候会重新加上锁mutex</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">    - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    - <span class="comment">//唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    - 唤醒<span class="comment">//所有的等待的线程</span></span><br></pre></td></tr></table></figure><ul><li>例子：资源不足的时候，条件变量wait等待生产者，生产者生产后，条件变量signal通知生产者</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="comment">//创建条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//队列方式读取，实际上是back指针，插入的时候用头插法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者 不断添加节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode -&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode -&gt;num = rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d,tid: %ld\n&quot;</span>,newNode-&gt;num,pthread_self());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生产一个，就同志消费者，唤醒一个等待的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 获取节点</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">custmer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//同一块临界区，设置为都互斥</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node,num: %d,tid: %ld\n&quot;</span>,tmp-&gt;num,pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*没有数据，需要等待</span></span><br><span class="line"><span class="comment">            当函数调用阻塞的时候，对互斥锁进行解锁，</span></span><br><span class="line"><span class="comment">            当不阻塞的时候，继续向下执行，会重新加锁</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没了，快做\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="comment">//usleep(100);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//5个生产者线程，5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>],ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i],<span class="literal">NULL</span>,custmer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(ptid[i]);</span><br><span class="line">        pthread_detach(ctid[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">信号量的类型 <span class="type">sem_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">    - 初始化信号量</span><br><span class="line">    - 参数： </span><br><span class="line">        - sem : 信号量变量的地址</span><br><span class="line">        - pshared : <span class="number">0</span> 用在线程间 ，非<span class="number">0</span> 用在进程间</span><br><span class="line">        - value : 信号量中的值</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 释放资源</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 对信号量加锁，调用一次对信号量的值<span class="number">-1</span>，如果值为<span class="number">0</span>，就阻塞</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    - 对信号量解锁，调用一次对信号量的值+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line">init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    sem_wait(&amp;psem);</span><br><span class="line">    sem_post(&amp;csem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer() &#123;</span><br><span class="line">    sem_wait(&amp;csem);</span><br><span class="line">    sem_post(&amp;psem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例子 - 用信号量实现生产者消费者</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">customer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Linux网络编程"><a href="#4-Linux网络编程" class="headerlink" title="4.Linux网络编程"></a>4.Linux网络编程</h2><h3 id="4-1网络基础"><a href="#4-1网络基础" class="headerlink" title="4.1网络基础"></a>4.1网络基础</h3><p>看pdf</p><h3 id="4-2-socket通信基础"><a href="#4-2-socket通信基础" class="headerlink" title="4.2 socket通信基础"></a>4.2 socket通信基础</h3><h5 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介</h5><p>所谓 socket（套接字），就是对<strong>网络中不同主机上的应用进程之间进行双向通信的端点的抽象</strong>。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制</strong>。</p><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为<strong>内核借助缓冲区形成的伪文件</strong>。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于<strong>本地</strong>进程间通信，而套接字多应用于<strong>网络进程间</strong>数据的传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 套接字通信分两部分：</span></span><br><span class="line">- 服务器端：被动接受连接，一般不会主动发起连接</span><br><span class="line">- 客户端：主动向服务器发起连接</span><br><span class="line"> </span><br><span class="line">socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。</span><br></pre></td></tr></table></figure><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>现代 CPU 的<strong>累加器</strong>一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在<strong>内存中排列的顺序</strong>将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于<strong>字节、字等的存储机制</strong>有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如<br>果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。</p><ul><li><strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数</strong><br><strong>据当然就无需谈顺序的问题了)。</strong></li><li>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整<br>数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地<br>址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地<br>址处。</li></ul><p><img src="D:\MyTxt\typoraPhoto\image-20230301104201183.png" alt="image-20230301104201183"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用union查找字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>)&amp;&amp;(test.bytes[<span class="number">1</span>] == <span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>)&amp;&amp;(test.bytes[<span class="number">1</span>] == <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h5><ul><li><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。<br>解决问题的方法是：<br>    发送端总是把要发送的数据转换成<strong>大端字节序数据后再发送</strong>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p></li><li><p><strong>网络字节顺序</strong>是 TCP&#x2F;IP 中规定好的一种数据表示格式，它<strong>与具体的 CPU 类型、操作系统等无关</strong>，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。<br>BSD Socket提供了封装好的转换接口，方便程序员使用。</p><ol><li>从主机字节序到网络字节序的转换函数：htons、htonl；</li><li>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network  网络字节序</span><br><span class="line">s - <span class="type">short</span>  <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">l  - <span class="type">long</span>  <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口 因为端口本身是unsigned short类型</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"><span class="comment">// 转IP因为端口本身是unsigned int类型</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// 网络字节序 - 主机字节序</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//htons 两个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//htonl 一般转化ip 四个字节</span></span><br><span class="line">    <span class="type">char</span>  buf[<span class="number">4</span>] = &#123;<span class="number">196</span>,<span class="number">168</span>,<span class="number">1.100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)buf;</span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span>*)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h4><p>客户端和服务器通信，需要IP Port ….，所以封装好了一个socket地址。</p><p>&#x2F;&#x2F; socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。</p><h5 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h5><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span>     sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure><ol><li>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议<br>族（protocol family，也称 domain）和对应的地址族入下所示</li></ol><img src="D:\MyTxt\typoraPhoto\image-20230301142702830.png" alt="image-20230301142702830" style="zoom:50%;" /><ul><li>宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。</li></ul><ol start="2"><li>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</li></ol><img src="D:\MyTxt\typoraPhoto\image-20230301142805645.png" alt="image-20230301142805645" style="zoom:50%;" /><p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line"><span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure><h5 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h5><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr <em>*退化成了（void *）**的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再</em>*强制类型转化为所需的地址类型**。</p><img src="D:\MyTxt\typoraPhoto\image-20230301143653912.png" alt="image-20230301143653912" style="zoom:50%;" /><p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>//这个用较多</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span> <span class="comment">//这个用较多</span></span><br><span class="line">  <span class="type">in_port_t</span> sin_port;     <span class="comment">/* Port number. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* Internet address. */</span>  <span class="comment">//这个用较多</span></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line">       <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">socklen_t</span> 是sockaddr_in的长度类型</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin6_family;</span><br><span class="line">  <span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">  <span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">  <span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><ul><li>所有<strong>专用</strong> socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要<strong>转化为通用</strong> socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</li></ul><h3 id="4-3-IP地址转换"><a href="#4-3-IP地址转换" class="headerlink" title="4.3 IP地址转换"></a>4.3 IP地址转换</h3><p>字符串ip-整数 ，主机-网络字节序的转换</p><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用<strong>点分十进制字符串</strong>表示 IPv4 地址，以及用<strong>十六进制字符串</strong>表示 IPv6 地址。但编程中我们需要先把它们<strong>转化为整数（二进制数）方能使用</strong>。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p><ul><li>旧接口- 以下函数比较久，且只使用于IPv4，而且是不可重用的函数，比如第三个因为直接用了那个结构体变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下函数比较久，且只使用于IPv4，而且是不可重用的函数，比如第三个因为直接用了那个结构体变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//转换成整数</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="comment">//转换成整数，保存在结构体in_addr中，成功返回1，失败返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"><span class="comment">//网络字节序的证书转换成点分十进制的字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><ul><li>新接口-下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET  AF_INET6</span><br><span class="line">  src:需要转换的点分十进制的IP字符串</span><br><span class="line">  dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET  AF_INET6</span><br><span class="line">  src: 要转换的ip的整数的地址</span><br><span class="line">  dst: 转换成IP地址字符串保存的地方</span><br><span class="line">  size：第三个参数的大小<span class="comment">//（数组的大小）</span></span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure><ul><li>IP地址转换例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建点分十进制ip地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.163.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ipv4字符串转化网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET,buf,&amp;num);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络字节序的整数转化为IPv4字符串</span></span><br><span class="line">        <span class="comment">//15个字符加上一个字符串结束符</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这里获取后，使用str和ip其实是一样</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = inet_ntop(AF_INET,&amp;num,ip,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str:%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip:%s\n&quot;</span>,ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ip == str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="4-4TCP通信流程"><a href="#4-4TCP通信流程" class="headerlink" title="4.4TCP通信流程"></a>4.4TCP通信流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 和 UDP -&gt; 传输层的协议</span></span><br><span class="line">UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠</span><br><span class="line">TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输</span><br><span class="line"> </span><br><span class="line">              UDP   TCP</span><br><span class="line">是否创建连接 无连接 ||面向连接</span><br><span class="line">是否可靠  不可靠 ||可靠的</span><br><span class="line">连接的对象个数   一对一、一对多、多对一、多对多 ||支持一对一</span><br><span class="line">传输的方式 面向数据报  ||面向字节流</span><br><span class="line">首部开销 <span class="number">8</span>个字节 ||最少<span class="number">20</span>个字节</span><br><span class="line">适用场景 实时应用（视频会议，直播）  ||可靠性高的应用（文件传输）</span><br></pre></td></tr></table></figure><img src="D:\MyTxt\typoraPhoto\image-20230301155418481.png" alt="image-20230301155418481" style="zoom: 67%;" /><h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">  - 监听：监听有客户端的连接</span><br><span class="line">  - 套接字：这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">  - 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字</span><br><span class="line">（fd）</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line"> - 接收数据</span><br><span class="line"> - 发送数据</span><br><span class="line"><span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于通信的套接字（fd）</span><br><span class="line"><span class="number">2.</span> 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line"><span class="number">3.</span> 连接成功了，客户端可以直接和服务器通信</span><br><span class="line">  - 接收数据</span><br><span class="line">  - 发送数据</span><br><span class="line"><span class="number">4.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><h3 id="4-4套接字函数"><a href="#4-4套接字函数" class="headerlink" title="4.4套接字函数"></a>4.4套接字函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">  - 参数：</span><br><span class="line">    - domain: 协议族</span><br><span class="line">   AF_INET : ipv4</span><br><span class="line">   AF_INET6 : ipv6</span><br><span class="line">   AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">      SOCK_STREAM : 流式协议<span class="comment">//TC一般 用这个</span></span><br><span class="line">      SOCK_DGRAM : 报式协议<span class="comment">//UDP等</span></span><br><span class="line">    - protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">      - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">      - SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">    - 返回值：</span><br><span class="line">      - 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">      - 失败：<span class="number">-1</span>    </span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命名</span></span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定 <span class="comment">//也就是讲文件描述符告诉连接方</span></span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">      - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">      - addrlen : 第二个参数结构体占的内存大小</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// cat /proc/sys/net/core/somaxconn可以查看，本机是4096</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">  - 参数：</span><br><span class="line">    - sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">    - backlog : 未连接的和已经连接的和的最大值， <span class="comment">//一般给个 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 用于监听的文件描述符</span><br><span class="line">      - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">      - addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">  - 返回值：</span><br><span class="line">      - 成功 ：用于通信的文件描述符</span><br><span class="line">      - <span class="number">-1</span> ： 失败</span><br><span class="line">       </span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">  - 参数：</span><br><span class="line">   - sockfd : 用于通信的文件描述符</span><br><span class="line">      - addr : 客户端要连接的服务器的地址信息</span><br><span class="line">      - addrlen : 第二个参数的内存大小</span><br><span class="line">  - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure><h3 id="4-5-TCP通信并发实现"><a href="#4-5-TCP通信并发实现" class="headerlink" title="4.5 TCP通信并发实现"></a>4.5 TCP通信并发实现</h3><h5 id="TCP通信-单连"><a href="#TCP通信-单连" class="headerlink" title="TCP通信 单连"></a>TCP通信 单连</h5><ol><li>服务器端设置端口999；客户端的端口是随机分配的，只要去连接服务器端的999就行</li><li>服务器端要去连的IP是任意的；客户端要去连接的IP是服务器端的192.168.31.128</li></ol><h6 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务器端两个文件描述符</span></span><br><span class="line"><span class="comment">1. 监听文件描述符lfd，相当于创建socket分配了，只不过后续要绑定到struct sockaddr_in saddr结构体（ip，port）上；</span></span><br><span class="line"><span class="comment">2.连接文件描述符cfd,在accept之后分配，只不过针对当前客户端的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit(0):正常运行程序并退出程序; exit(1):非正常运行导致退出程序,exit（-1）：非正常运行导致退出程序，与1类似；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span> </span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//方法一：设置ip，保持网络字节序；这儿注意一下结构体嵌套，最后存的变量</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET,&quot;192.168.31.128&quot;,saddr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="comment">//方法二：直接写in_addr_t类型的变量算了；INADDR_ANY是linux下的任博 </span></span><br><span class="line">    <span class="comment">//设置ip号</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4，接受客户端连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出客户端数据</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">    inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">//获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">    <span class="comment">//5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//服务器接受客户端数据</span></span><br><span class="line">        <span class="comment">//cfd是客户端socket发过来的文件描述符</span></span><br><span class="line">        <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受了num个字节   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受完了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">    <span class="type">char</span>* data = <span class="string">&quot;连上了，我是服务器端&quot;</span>;</span><br><span class="line">        write(cfd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.断开关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端用自己socket生成的fd写读，并且把fd发给服务器端，服务器端用针对该客户端的cfd</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *data = <span class="string">&quot;这是客户端&quot;</span>;</span><br><span class="line">        write(fd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小作业-读取输入并且回射"><a href="#小作业-读取输入并且回射" class="headerlink" title="小作业-读取输入并且回射"></a>小作业-读取输入并且回射</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit(0):正常运行程序并退出程序; exit(1):非正常运行导致退出程序,exit（-1）：非正常运行导致退出程序，与1类似；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//方法一：设置ip，保持网络字节序；这儿注意一下结构体嵌套，最后存的变量</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET,&quot;192.168.31.128&quot;,saddr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="comment">//方法二：直接写in_addr_t类型的变量算了；INADDR_ANY是linux下的任博</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9988</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4，接受客户端连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出客户端数据</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">    inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">//获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">    <span class="comment">//5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//服务器接受客户端数据</span></span><br><span class="line">        <span class="comment">//cfd是客户端socket发过来的文件描述符</span></span><br><span class="line">        <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受了num个字节   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//接受完了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">    <span class="comment">//char* data = &quot;连上了，我是服务器端&quot;;</span></span><br><span class="line">        <span class="comment">// char data[1024];</span></span><br><span class="line">        <span class="comment">// scanf(&quot;%s&quot;,data);</span></span><br><span class="line">        <span class="comment">// printf(&quot;请输入\n&quot;);</span></span><br><span class="line">        write(cfd,recvBuf,<span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.断开关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9988</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//申请内存并且清空</span></span><br><span class="line">        <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,data);</span><br><span class="line">        write(fd,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是<strong>客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等</strong>。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手<br>来关闭一个连接。<br>三次握手的目的是保证双方互相之间建立了连接。<br>三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手</p><h6 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h6><img src="D:\MyTxt\typoraPhoto\image-20230302114709452.png" alt="image-20230302114709452" style="zoom:50%;" /><ul><li>16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或<br>应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号</li><li>32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输<br>方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个<br>TCP 报文段中，<strong>序号值被系统初始化为某个随机值 ISN</strong>（Initial Sequence Number，初始序号<br>值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上<br>该报文段所携带数据的第一个字节在整个字节流中的<strong>偏移</strong>。例如，某个 TCP 报文段传送的数据是字<br>节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从<br>B 到 A）的 TCP 报文段的序号值也具有相同的含义</li><li>32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是<br>收到的 <strong>TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度</strong> 。假设主机 A 和主机 B 进行<br>TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段<br>的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。</li><li>6 位标志位包含如下几项：<ol><li>URG 标志，表示紧急指针（urgent pointer）是否有效。</li><li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</li><li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾<br>出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</li><li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。</li><li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。</li><li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文<br>段。</li></ol></li><li>16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是<strong>接收</strong><br><strong>通告窗口</strong>（Receiver Window，RWND）。它告诉对方<strong>本端的 TCP 接收缓冲区还能容纳多少</strong><br><strong>字节的数据</strong>，这样对方就可以控制发送数据的速度</li><li>16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验<br>TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。<br>这也是 TCP 可靠传输的一个重要保障</li><li>16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一<br>个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏<br>移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li></ul><h6 id="三次握手连接过程"><a href="#三次握手连接过程" class="headerlink" title="三次握手连接过程"></a>三次握手连接过程</h6><img src="D:\MyTxt\typoraPhoto\image-20230302135058522.png" alt="image-20230302135058522" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：</span><br><span class="line">  <span class="number">1.</span>客户端将SYN标志位置为<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>生成一个随机的<span class="number">32</span>位的序号seq=J ， 这个序号后边第三次握手的时候是可以携带数据（数据的大小）</span><br><span class="line">第二次握手：</span><br><span class="line">  <span class="number">1.</span>服务器端接收客户端的连接： ACK=<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>服务器会回发一个确认序号： ack=客户端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br><span class="line">  <span class="number">3.</span>服务器端会向客户端发起连接请求： SYN=<span class="number">1</span></span><br><span class="line">  <span class="number">4.</span>服务器会生成一个随机序号：seq = K</span><br><span class="line">第三次握手：</span><br><span class="line">  <span class="number">1.</span>客户单应答服务器的连接请求：ACK=<span class="number">1</span></span><br><span class="line">  <span class="number">2.</span>客户端回复收到了服务器端的数据：ack=服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br></pre></td></tr></table></figure><h5 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h5><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的<br>拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中<strong>间节点阻塞掉包</strong>，<br>谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种<br>技术，即<strong>容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包</strong><br><strong>（称窗口尺寸）。</strong><br>TCP 中采用滑动窗口来进行传输控制，<strong>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于</strong><br><strong>接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0<br>时，发送方一般不能再发送数据报。</p><ul><li>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构</li></ul><p>窗口理解为缓冲区的大小<br>滑动窗口的大小会随着发送数据和接收数据而变化。<br>通信的双方都有发送缓冲区和接收数据的缓冲区<br>服务器：<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）<br>客户端<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）</p><p><img src="D:\MyTxt\typoraPhoto\image-20230302142113013.png" alt="image-20230302142113013"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发送方的缓冲区：</span><br><span class="line">  白色格子：空闲的空间</span><br><span class="line">  灰色格子：数据已经被发送出去了，但是还没有被接收</span><br><span class="line">  紫色格子：还没有发送出去的数据</span><br><span class="line">接收方的缓冲区：</span><br><span class="line">  白色格子：空闲的空间</span><br><span class="line">  紫色格子：已经接收到的数据</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230302142141901.png" alt="image-20230302142141901"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span></span><br><span class="line"><span class="meta"># win: 滑动窗口</span></span><br><span class="line"><span class="number">1.</span> 客户端向服务器发起连接，客户单的滑动窗口是<span class="number">4096</span>，一次发送的最大数据量是<span class="number">1460</span></span><br><span class="line"><span class="number">2.</span> 服务器接收连接情况，告诉客户端服务器的窗口大小是<span class="number">6144</span>，一次发送的最大数据量是<span class="number">1024</span></span><br><span class="line"><span class="number">3.</span> 第三次握手</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span><span class="number">-9</span> 客户端连续给服务器发送了<span class="number">6</span>k的数据，每次发送<span class="number">1</span>k</span><br><span class="line"><span class="number">5.</span> 第<span class="number">10</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">2</span>k,窗</span><br><span class="line">口大小是<span class="number">2</span>k</span><br><span class="line"><span class="number">6.</span> 第<span class="number">11</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">4</span>k,窗</span><br><span class="line">口大小是<span class="number">4</span>k</span><br><span class="line"><span class="number">7.</span> 第<span class="number">12</span>次，客户端给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">8.</span> 第<span class="number">13</span>次，客户端主动请求和服务器断开连接，并且给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">9.</span> 第<span class="number">14</span>次，服务器回复ACK <span class="number">8194</span>, a:同意断开连接的请求 b:告诉客户端已经接受到方才发的<span class="number">2</span>k的数据</span><br><span class="line">c:滑动窗口<span class="number">2</span>k</span><br><span class="line"><span class="number">10.</span>第<span class="number">15</span>、<span class="number">16</span>次，通知客户端滑动窗口的大小</span><br><span class="line"><span class="number">11.</span>第<span class="number">17</span>次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</span><br><span class="line"><span class="number">12.</span>第<span class="number">18</span>次，第四次挥手，客户端同意了服务器端的断开请求</span><br></pre></td></tr></table></figure><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。</p><img src="D:\MyTxt\typoraPhoto\image-20230302143729767.png" alt="image-20230302143729767" style="zoom:50%;" /><h5 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。</span><br><span class="line"> </span><br><span class="line">思路：</span><br><span class="line">  <span class="number">1.</span> 一个父进程，多个子进程</span><br><span class="line">  <span class="number">2.</span>父进程负责等待并接受客户端的连接</span><br><span class="line">  <span class="number">3.</span>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信</span><br></pre></td></tr></table></figure><h6 id="server-process"><a href="#server-process" class="headerlink" title="server_process"></a>server_process</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycleChild</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//子进程回收完</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//回收该子进程完成</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d被回收了\n&quot;</span>,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用SIGCHLD回收子进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recycleChild;</span><br><span class="line">    <span class="comment">//注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不停处理新客户端的链接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每连接上一个客户端，创建一个子进程处理</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程    </span></span><br><span class="line">            <span class="comment">//获取客户端信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">            <span class="comment">//获取IP，网络字节序转化成点分十进制</span></span><br><span class="line">            inet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,clientIP,<span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">            <span class="comment">//获取端口</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//不停读写</span></span><br><span class="line">            <span class="comment">//服务器读取客户端数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> num = read(cfd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//接受了num个字节   </span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//接受完了</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">                write(cfd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子进程退出，等待回收 多进程别忘了回收子进程资源！！！！</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="client"><a href="#client" class="headerlink" title="client"></a>client</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf,<span class="string">&quot;recvBuf: %d\n&quot;</span>,i++);</span><br><span class="line">        <span class="comment">//输入 把\0也写入</span></span><br><span class="line">        write(fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多线程实现并发服务器-类似于线程池"><a href="#多线程实现并发服务器-类似于线程池" class="headerlink" title="多线程实现并发服务器 - 类似于线程池"></a>多线程实现并发服务器 - 类似于线程池</h5><h6 id="server-process-1"><a href="#server-process-1" class="headerlink" title="server_process"></a>server_process</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传到选定子线程的数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程通信</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line">    <span class="comment">//不停读写</span></span><br><span class="line">        <span class="comment">//服务器读取客户端数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> num = read(pinfo-&gt;fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//接受了num个字节   </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>,recvBuf);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//接受完了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务器回复客户端数据</span></span><br><span class="line">            write(pinfo-&gt;fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子线程退出，记得分离！！！！！</span></span><br><span class="line">        close(pinfo-&gt;fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//1.创建socket用于监听</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.绑定文件描述符</span></span><br><span class="line">        <span class="comment">//socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        <span class="comment">//初始化协议族</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">//0.0.0.0</span></span><br><span class="line">        <span class="comment">//设置端口号 </span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.连接</span></span><br><span class="line">        <span class="comment">//初始化数据</span></span><br><span class="line">        <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos)/<span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="comment">//清空数据       The  bzero()  function erases the data in the n bytes of the memory starting at the location pointed to by s, by writing zeros (bytes containing &#x27;\0&#x27;) to that area.</span></span><br><span class="line">            bzero(&amp;sockinfos[i],<span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">            <span class="comment">//设置初始值</span></span><br><span class="line">            sockinfos[i].fd=<span class="number">-1</span>;</span><br><span class="line">            sockinfos[i].tid=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从线程数组中找到可用的子线程，进行连接通信</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].tid == <span class="number">-1</span>)&#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有空闲线程,等会，重新找</span></span><br><span class="line">            <span class="keyword">if</span>(i == max <span class="number">-1</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr,&amp;cliaddr,len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建子进程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid,<span class="literal">NULL</span>,working,pinfo);</span><br><span class="line">        <span class="comment">//子线程分离</span></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="client-和前面一样"><a href="#client-和前面一样" class="headerlink" title="client - 和前面一样"></a>client - 和前面一样</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        <span class="comment">//设置协议族</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.128&quot;</span>,&amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="comment">//设置端口 </span></span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9898</span>);</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf,<span class="string">&quot;recvBuf: %d\n&quot;</span>,i++);</span><br><span class="line">        <span class="comment">//输入 把\0也写入</span></span><br><span class="line">        write(fd,recvBuf,<span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = read(fd,recvBuf,<span class="keyword">sizeof</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data:%s\n&quot;</span>,recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符，退出</span></span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h5><img src="D:\MyTxt\typoraPhoto\image-20230302175535303.png" alt="image-20230302175535303" style="zoom: 80%;" /><img src="D:\MyTxt\typoraPhoto\image-20230302175650175.png" alt="image-20230302175650175" style="zoom:67%;" /><ul><li>上图红线是发送方，虚线是接收方</li></ul><p>2MSL（Maximum Segment Lifetime）<br>主动断开连接的一方, 最后进入一个 TIME_WAIT状态, 这个状态会持续: 2msl</p><ul><li>msl: 官方建议: 2分钟, 实际是30s</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方</span><br><span class="line">必须处于TIME_WAIT 状态并持续 <span class="number">2</span>MSL 时间。</span><br><span class="line">这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。</span><br><span class="line">主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，</span><br><span class="line">被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。<span class="comment">//事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。</span></span><br><span class="line">    <span class="comment">//为什么不需要第五次挥手？如果被动关闭方没有接受到ACK，肯定对继续传送FIN，这时候主动方就知道第四次的ACK没穿送到位</span></span><br></pre></td></tr></table></figure><ul><li>半关闭</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2</span><br><span class="line">状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发</span><br><span class="line">送的数据，但是 A 已经不能再向 B 发送数据。<span class="comment">//为什么四次：第二次和第三次需要分开 ！服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</span></span><br></pre></td></tr></table></figure><ul><li>从程序的角度，可以使用 API 来控制实现<strong>半连接状态</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区别于close()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">   该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发</span><br><span class="line">出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以</span><br><span class="line">SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用 close 中止一个连接，但它只是<strong>减少描述符的引用计数</strong>，并不直接关闭连接，只有当描述符的引用<br>计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也可选择中止一个方<br>向的连接，只中止读或只中止写。<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用<br> 进程都调用了 close，套接字将被释放。</li><li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。<br> 但如果一个进程 close(sfd) 将不会影响到其它进程。</li></ol><h5 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h5><ul><li><p>在不调用端口复用的时候， 如果服务器端处于time_wait状态，就会占用当前端口号，直到释放掉。</p><p>比如，如果重启服务器的话，就会显示地址已经使用，导致不能重启</p></li><li><p>端口复用最常用的用途是:</p><ol><li>防止服务器重启时之前绑定的端口还未释放</li><li>程序突然退出而系统<strong>没有释放端口</strong></li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> </span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - sockfd : 要操作的文件描述符</span><br><span class="line">        - level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">        - optname : 选项的名称</span><br><span class="line">            - SO_REUSEADDR</span><br><span class="line">            - SO_REUSEPORT</span><br><span class="line">        - optval : 端口复用的值（整形）</span><br><span class="line">            - <span class="number">1</span> : 可以复用</span><br><span class="line">            - <span class="number">0</span> : 不可以复用</span><br><span class="line">        - optlen : optval参数的大小</span><br><span class="line">端口复用，设置的时机是在服务器绑定bind端口之前。</span><br><span class="line">setsockopt();</span><br><span class="line">bind();</span><br></pre></td></tr></table></figure><ul><li>查看网络相关信息的命令<br>netstat<br> 参数：-a 所有的socket<br>   -p 显示正在使用socket的程序的名称<br>   -n 直接使用IP地址，而不通过域名服务器</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int optval = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accpet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client&#x27;s ip is %s, and port is %d\n&quot;</span>, cliIp, cliPort );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小写转大写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            recvBuf[i] = <span class="built_in">toupper</span>(recvBuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大写字符串发给客户端</span></span><br><span class="line">        ret = send(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-IO多路复用"><a href="#4-6-IO多路复用" class="headerlink" title="4.6  IO多路复用"></a>4.6  IO多路复用</h3><ul><li>I&#x2F;O 多路复用使得<strong>程序能同时监听多个文件描述符</strong>，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的<br>系统调用主要有 select、poll 和 epoll</li></ul><h5 id="IO多路复用概述"><a href="#IO多路复用概述" class="headerlink" title="IO多路复用概述"></a>IO多路复用概述</h5><p>又叫IO多路转接，IO指的是针对内存</p><ul><li><p>BIO模型（线进程和客户端一一对应 accept、read会阻塞）的缺点：</p><ol><li><p>线程或者进程会消耗资源；</p></li><li><p>线程或者进程的调度消耗CPU资源；</p></li><li><p>根本问题：BOLCKING阻塞</p><img src="D:\MyTxt\typoraPhoto\image-20230303164114741.png" alt="image-20230303164114741" style="zoom: 67%;" /></li></ol></li><li><p>非阻塞，忙轮询的模型：</p><ol><li><p>提高了程序的执行效率；</p></li><li><p>但是轮询需要占用更多的CPU和系统资源</p><img src="D:\MyTxt\typoraPhoto\image-20230303164324869.png" alt="image-20230303164324869" style="zoom: 33%;" /></li></ol></li><li><p>NIO模型：</p><ol><li>需要不停调用，read就要调用n次</li></ol></li></ul><img src="D:\MyTxt\typoraPhoto\image-20230303164452309.png" alt="image-20230303164452309" style="zoom:50%;" /><ul><li>IO多路转接技术：<br>委托内核，比较快，而且直接可以知道哪些有数据，不需要全部read一遍（select需要）<ol><li>select只会告诉你有几个文件描述符，有数据到达</li><li>epoll很勤快，她不仅会告诉你有几个快递到了，还会告诉你是哪个快递公司的快递</li></ol></li></ul><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><blockquote><p>主旨思想：</p><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li><li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O<br>操作时，该函数才返回。<br>a.这个函数是阻塞<br>b.函数对文件描述符的检测的操作是由内核完成的</li><li>在返回时，它会告诉进程有多少（哪些）描述符要进行I&#x2F;O操作。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128   1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">//需要检测的文件描述符，传入内核，然后通过传入传出参数得到</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">     fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">   - nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span><span class="comment">//也就是检测位+1，因为数组从0开始</span></span><br><span class="line">      - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">        - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">      - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">        - <span class="comment">//委托内核检测写缓冲区是不是还可以写数据（不满的就可以写） 一般不检测</span></span><br><span class="line"> - exceptfds : 检测发生异常的文件描述符的集合 <span class="comment">//一般用不到</span></span><br><span class="line">      - ti meout : 设置的超时时间 <span class="comment">//检测的最大时间，因为不能一直阻塞，除非设置NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">       <span class="type">long</span>   tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">       <span class="type">long</span>   tv_usec;     <span class="comment">/* microseconds */</span></span><br><span class="line">     &#125;;</span><br><span class="line">- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化<span class="comment">//永久阻塞</span></span><br><span class="line">        - tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">       - tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">         </span><br><span class="line">   - 返回值 :</span><br><span class="line">  - &gt;<span class="number">1</span> : 失败</span><br><span class="line">      - &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="D:\MyTxt\typoraPhoto\image-20230303114212143.png" alt="image-20230303114212143"></p><ul><li>对应 3 4 100 101的fd：</li></ul><ol><li>先定义reads 1024bit（0-1023），然后监听 3 4 100 101的fd放到reads中</li><li>用select把reads读到内核中，并且检测，检测到有数据的置位1，没数据置位0，（比如只有3 4 有数据）</li><li>然后从内核态拷贝到用户态（用户态遍历之后知道3 4 有数据），然后对有数据的进行通信</li></ol><h6 id="select实现多路转接"><a href="#select实现多路转接" class="headerlink" title="select实现多路转接"></a>select实现多路转接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    listen(lfd,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多路转接模型</span></span><br><span class="line">        <span class="comment">//创建fd_set集合，存放需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset,tmp;<span class="comment">//底层表示1024个文件描述符</span></span><br><span class="line">        <span class="comment">//清空rdset</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">        <span class="comment">//添加lfd</span></span><br><span class="line">    FD_SET(lfd,&amp;rdset);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        tmp = rdset;</span><br><span class="line">        <span class="comment">//调用系统函数，让内核帮检测哪个有数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>,&amp;tmp,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有数据变化</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明有文件描述符对应的缓冲区数据有ret个发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd,&amp;tmp))&#123;</span><br><span class="line">                <span class="comment">//表示有新的客户端连接进来</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//新的文件描述符加入到集合中 </span></span><br><span class="line">                FD_SET(cfd,&amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//内核判断集合中有数据的文件描述符后，依次读取数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd+<span class="number">1</span>;i &lt;= maxfd;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i,&amp;tmp))&#123;</span><br><span class="line">                    <span class="comment">//说明这个文件描述符对应的客户端发来数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(i,&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        FD_CLR(i,&amp;rdset);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                        write(i,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul><li>select() 的缺点：<br>1.每次调用select，都需要把fd集合从用户态<strong>拷贝</strong>到内核态，这个开销在fd很多时会很大<br>2.同时每次调用select都需要在内核<strong>遍历传递进来的所有fd</strong>，这个开销在fd很多时也很大<br>3.select<strong>支持的文件描述符数量太小</strong>了，默认是1024<br>4.<strong>fds集合不能重用</strong>，每次都需要重置</li><li>poll解决了缺点3 4</li></ul><img src="D:\MyTxt\typoraPhoto\image-20230303165739608.png" alt="image-20230303165739608" style="zoom:50%;" /><ul><li>poll接口说明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span>  fd;     <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line"><span class="type">short</span> events;   <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line"><span class="type">short</span> revents;   <span class="comment">/* 文件描述符实际发生的事件 */</span>              <span class="comment">//调用poll的时候会传出</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">    - <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">    - timeout : 阻塞时长</span><br><span class="line">      <span class="number">0</span> : 不阻塞</span><br><span class="line">      <span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">      &gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">  - 返回值：</span><br><span class="line">    <span class="number">-1</span> : 失败</span><br><span class="line">    &gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure><img src="D:\MyTxt\typoraPhoto\image-20230303170358379.png" alt="image-20230303170358379" style="zoom: 67%;" /><h6 id="poll实现多路转接"><a href="#poll实现多路转接" class="headerlink" title="poll实现多路转接"></a>poll实现多路转接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul><li>直接在内核操作，内核用rbtree比较快，事件驱动，红黑树节点上注册有回调函数，事件到来后执行回调函数</li><li>去掉拷贝到内核的开销，并且能告知哪些文件描述符发送改变，而不只是个数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检</span></span><br><span class="line">测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向</span><br><span class="line">链表）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">-1</span> : 失败</span><br><span class="line">        &gt; <span class="number">0</span> : 文件描述符<span class="comment">//操作epoll实例的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">            - epfd : epoll实例对应的文件描述符</span><br><span class="line">            - op : 要进行什么操作</span><br><span class="line">                EPOLL_CTL_ADD:  添加 <span class="comment">//记得提前设置一个epoll_event结构</span></span><br><span class="line">                EPOLL_CTL_MOD:  修改</span><br><span class="line">                EPOLL_CTL_DEL:  删除 <span class="comment">//删除处理，第四的个参数为NULL</span></span><br><span class="line">            - fd : 要检测的文件描述符</span><br><span class="line">            - event : 检测文件描述符什么事情</span><br><span class="line"><span class="comment">// 检测函数                </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - events : 传出参数，保存了发送了变化的文件描述符的信息 <span class="comment">//之后遍历读取处理</span></span><br><span class="line">        - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">        - timeout : 阻塞时间</span><br><span class="line">            - <span class="number">0</span> : 不阻塞</span><br><span class="line">            - <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">            - &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">                </span><br><span class="line">    - 返回值：</span><br><span class="line">         - 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">         - 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure><h6 id="epoll实现多路转接"><a href="#epoll实现多路转接" class="headerlink" title="epoll实现多路转接"></a>epoll实现多路转接</h6><p>建立epoll实例，添加EPOLLIN，用epoll_wait返回所有事件，可以得到所有事件；<br>然后按照事件类型逐个处理，把新连接进来的客户端添加到epoll实例中监听，把处理好的事件从epoll实例中去掉；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd,epevs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd =epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)&#123;</span><br><span class="line">                <span class="comment">//监听的文件描述符有数据到达，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="comment">//添加到需要监听的部分 可以重用之前的epoll_event数据结构</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;epev);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//过滤写事件，也就是说对于不同时间要单独处理</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从epoll实例中删除掉</span></span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,curfd,<span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                    write(curfd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);    </span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Epoll的工作模式"><a href="#Epoll的工作模式" class="headerlink" title="Epoll的工作模式"></a>Epoll的工作模式</h5><ul><li>LT 模式 （水平触发）<br>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br> 读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>   a.用户不读数据，数据一直在缓冲区，epoll 会一直通知<br>   b.用户只读了一部分数据，epoll会通知<br>   c.缓冲区的数据读完了，不通知</li></ul><blockquote><p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这<br>种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操<br>作。如果你不作任何操作，内核还是会继续通知你的。</p></blockquote><ul><li><p>ET 模式（边沿触发）</p><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br> 读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>   a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了<br>   b.用户只读了一部分数据，epoll不通知<br>   c.缓冲区的数据读完了，不通知</p></li></ul><blockquote><p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述<br>符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，<br>并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述<br>符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成<br>未就绪），内核不会发送更多的通知（only once）。<br>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll<br>工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写<br>操作把处理多个文件描述符的任务饿死。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    - EPOLLET<span class="comment">//边沿触发 用的时候|上前面的检测事件</span></span><br></pre></td></tr></table></figure><h6 id="水平触发-默认"><a href="#水平触发-默认" class="headerlink" title="水平触发 - 默认"></a>水平触发 - 默认</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd,epevs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd =epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)&#123;</span><br><span class="line">                <span class="comment">//监听的文件描述符有数据到达，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="comment">//添加到需要监听的部分 可以重用之前的epoll_event数据结构</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;epev);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//过滤写事件，也就是说对于不同时间要单独处理</span></span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取完了 清空文件描述符</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从epoll实例中删除掉</span></span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,curfd,<span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>,buf);</span><br><span class="line">                    write(curfd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);    </span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        <span class="comment">//fgets获取stdin的输入，阻塞</span></span><br><span class="line">        fgets(sendBuf,<span class="keyword">sizeof</span>(sendBuf),<span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="comment">//usleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="边沿触发-EPOLLET"><a href="#边沿触发-EPOLLET" class="headerlink" title="边沿触发 - EPOLLET"></a>边沿触发 - EPOLLET</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-7-UDP通信"><a href="#4-7-UDP通信" class="headerlink" title="4.7  UDP通信"></a>4.7  UDP通信</h3><img src="D:\MyTxt\typoraPhoto\image-20230306102024691.png" alt="image-20230306102024691" style="zoom: 80%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">        - 参数：</span><br><span class="line">            - sockfd : 通信的fd</span><br><span class="line">            - buf : 要发送的数据</span><br><span class="line">            - len : 发送数据的长度</span><br><span class="line">            - flags : <span class="number">0</span></span><br><span class="line">            - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">            - addrlen : 地址的内存大小</span><br><span class="line">                </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">        - 参数：</span><br><span class="line">            - sockfd : 通信的fd</span><br><span class="line">            - buf : 接收数据的数组</span><br><span class="line">            - len : 数组的大小</span><br><span class="line">            - flags : <span class="number">0</span></span><br><span class="line">            - src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span> <span class="comment">//传出参数 不需要最后两个参数都可以指定NULL</span></span><br><span class="line">            - addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure><h5 id="UDP实现流程"><a href="#UDP实现流程" class="headerlink" title="UDP实现流程"></a>UDP实现流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        recvfrom(fd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP: %s,Port: %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ipbuf,<span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>,recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        sendto(fd,recvbuf,<span class="built_in">strlen</span>(recvbuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf,<span class="string">&quot;hello,i am client %d\n&quot;</span>,num++);</span><br><span class="line">        sendto(fd,sendBuf,<span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        recvfrom(fd,sendBuf,<span class="keyword">sizeof</span>(sendBuf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>,sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>广播和多播都用UDP</li></ul><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广<br>播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。<br>a.只能在局域网中使用。<br>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息</p><img src="D:\MyTxt\typoraPhoto\image-20230306114206431.png" alt="image-20230306114206431" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> </span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">    - sockfd : 文件描述符</span><br><span class="line">    - level : SOL_SOCKET</span><br><span class="line">    - optname : SO_BROADCAST</span><br><span class="line">    - optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播<span class="comment">//1</span></span><br><span class="line">    - optlen : optval的大小</span><br><span class="line"><span class="comment">//使用的时候创建广播地址的套接字IP地址设置为广播地址，也就是最后一位255</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置广播属性</span></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd,SOL_SOCKET,SO_BROADCAST,&amp;op,<span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建广播地址  因为这里服务端是主动给别人发送数据了，不需要手动绑定一个端口了，但是底层肯定还会分配一个端口给他的。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="comment">//广播地址</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.31.255&quot;</span>,&amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.通信</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> sendbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendbuf,<span class="string">&quot;hello,client...%d\n&quot;</span>,num++);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        sendto(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据: %d\n&quot;</span>,num);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建socket 选择数据报而不是流</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.客户端绑定本地接受的ip和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    cliaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">int</span> ret = bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        recvfrom(fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h5><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。<br>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方<br>案。多播数据报只应该由对它感兴趣的接口接收，也就是说由<strong>运行相应多播会话应用系统的主机上</strong><br><strong>的接口接收</strong>。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网<br>使用。<br>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据</p><img src="D:\MyTxt\typoraPhoto\image-20230306140538652.png" alt="image-20230306140538652" style="zoom: 50%;" /><ul><li>组播地址：<br>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从  224.0.0.0 到 239.255.255.255 ，<br>并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</li></ul><img src="D:\MyTxt\typoraPhoto\image-20230306140713969.png" alt="image-20230306140713969" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">- level : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> //</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    // 客户端加入到多播组：</span></span><br><span class="line"><span class="class">    - <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">    - optname : IP_ADD_MEMBERSHIP</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* IP multicast address of group.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">// 组播的IP地址</span></span><br><span class="line">    <span class="comment">/* Local IP address of interface.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>多播通信示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 初始化多播地址 从表中选一个多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="comment">// 2.客户端绑定IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-本地套接字"><a href="#4-8-本地套接字" class="headerlink" title="4.8 本地套接字"></a>4.8 本地套接字</h3><ul><li>本地套接字的作用：本地的进程间通信<br> 有关系的进程间的通信<br> 没有关系的进程间的通信<br>本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。</li></ul><img src="D:\MyTxt\typoraPhoto\image-20230306153412355.png" alt="image-20230306153412355" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 本地套接字通信的流程 - tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件:  sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">    <span class="type">char</span> sun_path[UNIX_PATH_MAX];   <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="number">1.</span> 创建监听的套接字</span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span> <span class="comment">//对local socket的数据结构</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 监听</span><br><span class="line">    listen(lfd, <span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span> 等待并接受连接请求</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">6.</span> 关闭连接</span><br><span class="line">    close();</span><br><span class="line"><span class="comment">// 客户端的流程</span></span><br><span class="line"><span class="number">1.</span> 创建通信的套接字</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的IP 端口</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 连接服务器</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">5.</span> 关闭连接</span><br><span class="line">    close();</span><br></pre></td></tr></table></figure><ul><li>例子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-WebServer项目"><a href="#5-WebServer项目" class="headerlink" title="5.WebServer项目"></a>5.WebServer项目</h2><h3 id="5-1-阻塞非阻塞、同步异步"><a href="#5-1-阻塞非阻塞、同步异步" class="headerlink" title="5.1 阻塞非阻塞、同步异步"></a>5.1 阻塞非阻塞、同步异步</h3><p><img src="D:\MyTxt\typoraPhoto\image-20230306165424115.png" alt="image-20230306165424115"></p><ul><li>典型的一次IO的两个阶段是什么？数据就绪 和 数据读写</li></ul><ol><li>数据就绪：根据系统IO操作（现在只考虑网络IO）的就绪状态<br>阻塞<br>非阻塞</li><li>数据读写：根据应用程序和内核的交互方式<br>同步<br>异步</li></ol><ul><li>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO</li></ul><img src="D:\MyTxt\typoraPhoto\image-20230306165722791.png" alt="image-20230306165722791" style="zoom:67%;" /><blockquote><p> 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为<br>阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。<br>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是<br>由请求方A<strong>自己来完成</strong>的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时<br>（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以<br>处理其它逻辑了，当<strong>B监听到事件处理</strong>完成后，会用事先约定好的通知方式，通知A处理结果。</p></blockquote><p> 同步阻塞 同步非阻塞异步阻塞异步非阻塞</p><h3 id="5-2-Unix-x2F-Linux上的五种IO模型"><a href="#5-2-Unix-x2F-Linux上的五种IO模型" class="headerlink" title="5.2 Unix&#x2F;Linux上的五种IO模型"></a>5.2 Unix&#x2F;Linux上的五种IO模型</h3><h5 id="a-阻塞-blocking"><a href="#a-阻塞-blocking" class="headerlink" title="a.阻塞 blocking"></a>a.阻塞 blocking</h5><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必<br>须等这个函数返回才能进行下一步动作</p><ol><li>有等待 阻塞 2. 有数据拷贝 同步</li></ol><img src="D:\MyTxt\typoraPhoto\image-20230306170646903.png" alt="image-20230306170646903" style="zoom: 67%;" /><h5 id="b-非阻塞-non-blocking（NIO）"><a href="#b-非阻塞-non-blocking（NIO）" class="headerlink" title="b.非阻塞 non-blocking（NIO）"></a>b.非阻塞 non-blocking（NIO）</h5><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调<br>用总是<strong>立即返回</strong>，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两<br>种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 <strong>EAGAIN</strong>。</p><img src="D:\MyTxt\typoraPhoto\image-20230306171245018.png" alt="image-20230306171245018" style="zoom: 67%;" /><h5 id="c-IO复用（IO-multiplexing）"><a href="#c-IO复用（IO-multiplexing）" class="headerlink" title="c.IO复用（IO multiplexing）"></a>c.IO复用（IO multiplexing）</h5><p>Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是<br>这些函数可以<strong>同时(非)阻塞地处理多个IO操作</strong>。而且可以同时对多个读操作、写操作的IO函数进行<strong>检测</strong>。直到有数<br>据可读或可写时，才真正调用IO操作函数。&#x2F;&#x2F;主要不是处理高并发，而是同时处理多个IO的优点</p><img src="D:\MyTxt\typoraPhoto\image-20230306171636481.png" alt="image-20230306171636481" style="zoom: 67%;" /><h5 id="d-信号驱动（signal-driven）"><a href="#d-信号驱动（signal-driven）" class="headerlink" title="d.信号驱动（signal-driven）"></a>d.信号驱动（signal-driven）</h5><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进<br>程收到SIGIO 信号，然后处理 IO 事件 </p><img src="D:\MyTxt\typoraPhoto\image-20230306172310990.png" alt="image-20230306172310990" style="zoom:67%;" /><p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需<br>要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率 </p><p>&#x2F;&#x2F;从内核空间拷贝到用户空间还是需要拷贝，也就是同步操作，不常用</p><h5 id="e-异步（asynchronous）"><a href="#e-异步（asynchronous）" class="headerlink" title="e.异步（asynchronous）"></a>e.异步（asynchronous）</h5><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方<br>式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p><img src="D:\MyTxt\typoraPhoto\image-20230306175126070.png" alt="image-20230306175126070" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> aio_fildes;       <span class="comment">/* File desriptor.  */</span></span><br><span class="line">  <span class="type">int</span> aio_lio_opcode;       <span class="comment">/* Operation to be performed.  */</span></span><br><span class="line">  <span class="type">int</span> aio_reqprio;      <span class="comment">/* Request priority offset.  */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">void</span> *aio_buf;   <span class="comment">/* Location of buffer.  */</span></span><br><span class="line">  <span class="type">size_t</span> aio_nbytes;        <span class="comment">/* Length of transfer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value.  */</span></span><br><span class="line">  <span class="comment">/* Internal members.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line">  <span class="type">int</span> __abs_prio;</span><br><span class="line">  <span class="type">int</span> __policy;</span><br><span class="line">  <span class="type">int</span> __error_code;</span><br><span class="line">  <span class="type">__ssize_t</span> __return_value;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">  <span class="type">__off_t</span> aio_offset;       <span class="comment">/* File offset.  */</span></span><br><span class="line">  <span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">__off64_t</span> aio_offset;     <span class="comment">/* File offset.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-Web-Server网页服务器"><a href="#5-3-Web-Server网页服务器" class="headerlink" title="5.3 Web Server网页服务器"></a>5.3 Web Server网页服务器</h3><h5 id="网页服务器简介"><a href="#网页服务器简介" class="headerlink" title="网页服务器简介"></a>网页服务器简介</h5><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主<br>要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自<br>客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返<br>回一个 Error 信息。</p><p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则<br>先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请<br>求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针<br>对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p><img src="D:\MyTxt\typoraPhoto\image-20230306222359507.png" alt="image-20230306222359507" style="zoom: 67%;" /><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在<br>TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的<br>头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p><blockquote><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（<strong>默认端口为80,HTTPS是443</strong>）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，<strong>HTTP可以在任何互联网协议上，或其他网络上实现</strong>。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 <strong>TCP 作为其传输层</strong>。<br>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p></blockquote><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客<br>户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方<br>法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版<br>本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求&#x2F;响应的步骤：</p><ol><li>客户端连接到 Web 服务器<br> 一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接<br> 字连接。例如，<a href="http://www.baidu.com.(url)/">http://www.baidu.com。（URL）</a></li><li>发送 HTTP 请求<br> 通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求<br> 头部、空行和请求数据 4 部分组成。</li><li>服务器接受请求并返回 HTTP 响应<br> Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个<br> 响应由状态行、响应头部、空行和响应数据 4 部分组成。</li><li>释放连接 TCP 连接<br> 若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连<br> 接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li><li>客户端浏览器解析 HTML 内容<br> 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应<br> 头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据<br> HTML 的语法对其进行格式化，并在浏览器窗口中显示。</li></ol><ul><li>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</li></ul><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</li><li>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三<br>次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</li><li>释放 TCP 连接;</li><li>浏览器将该 HTML 文本并显示内容。</li></ol><p><img src="D:\MyTxt\typoraPhoto\image-20230306223145625.png" alt="image-20230306223145625"></p><p>HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客<br>户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端<br>在没有接收到请求之前不会发送响应</p><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><img src="D:\MyTxt\typoraPhoto\image-20230307094705215.png" alt="image-20230307094705215" style="zoom: 67%;" /><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; </span><br><span class="line">BIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752; </span><br><span class="line">BDORZ=FFFB88E999055A3F8A630C64834BD6D0; </span><br><span class="line">__yjs_duid=1_d05d52b14af4a339210722080a668ec21614320694782; BD_HOME=1; </span><br><span class="line">H_PS_PSSID=33514_33257_33273_31660_33570_26350; </span><br><span class="line">BA_HECTOR=8h2001alag0lag85nk1g3hcm60q</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=</span><br></pre></td></tr></table></figure><h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><img src="D:\MyTxt\typoraPhoto\image-20230307094824169.png" alt="image-20230307094824169" style="zoom:50%;" /><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Bdpagetype</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Bdqid</span><span class="punctuation">: </span>0xf3c9743300024ee4</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>private</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=utf-8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 26 Feb 2021 08:44:35 GMT</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Fri, 26 Feb 2021 08:44:35 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BDSVRTM=13; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BD_HOME=1; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>H_PS_PSSID=33514_33257_33273_31660_33570_26350; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=172800</span><br><span class="line"><span class="attribute">Traceid</span><span class="punctuation">: </span>1614329075128412289017566699583927635684</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span><span class="punctuation">: </span>IE=Edge,chrome=1</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br></pre></td></tr></table></figure><h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h5><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态<br>的短语，彼此由空格分隔。<br>状态代码的第一个数字代表当前响应的类型：<br>1xx消息——请求已被服务器接收，继续处理<br>2xx成功——请求已成功被服务器接收、理解、并接受<br>3xx重定向——需要后续操作才能完成这一请求<br>4xx请求错误——请求含有词法错误或者无法被执行<br>5xx服务器错误——服务器在处理某个正确请求时发生错误<br>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍<br>然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><img src="D:\MyTxt\typoraPhoto\image-20230307095103231.png" alt="image-20230307095103231" style="zoom:67%;" /><p>更多状态码：<a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin</a></p><h4 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h4><p>服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor<br>和 Proactor，同步 I&#x2F;O 模型通常用于实现 Reactor 模式，异步 I&#x2F;O 模型通常用于实现 Proactor 模式。</p><h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><p>要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作<br>线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做<br>任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><ul><li>使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是</li></ul><img src="D:\MyTxt\typoraPhoto\image-20230307103757704.png" alt="image-20230307103757704" style="zoom: 67%;" /><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll<br>内核事件表中注册该 socket 上的写就绪事件。</li><li>当主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li></ol><h5 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h5><p>Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻<br>辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p><img src="D:\MyTxt\typoraPhoto\image-20230307103954411.png" alt="image-20230307103954411" style="zoom:67%;" /><ol><li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，<br>以及读操作完成时如何通知应用程序（这里以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据<br>已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求<br>后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以<br>及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据<br>已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><h5 id="模拟-Proactor-模式"><a href="#模拟-Proactor-模式" class="headerlink" title="模拟 Proactor 模式"></a>模拟 Proactor 模式</h5><p>使用同步 I&#x2F;O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向<br>工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下<br>来要做的只是对读写的结果进行逻辑处理。<br>使用同步 I&#x2F;O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p><img src="D:\MyTxt\typoraPhoto\image-20230307104242846.png" alt="image-20230307104242846" style="zoom:67%;" /><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更<br>多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事<br>件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 <strong>CPU 数量差不多</strong>。线程池中的所<br>有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子<br>线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主<br>线程选择哪个子线程来为新任务服务，则有多种方式：</p><ul><li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流<br>选取）算法，但更优秀、更智能的算法将使任务在各个<strong>工作线程中更均匀地分配</strong>，从而减轻服务器<br>的整体压力。</li><li>主线程和所有子线程通过一个共享的工作队列来同步，<strong>子线程都睡眠在该工作队列上</strong>。当有新的任<br>务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线<br>程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在<br>工作队列上</li></ul><img src="D:\MyTxt\typoraPhoto\image-20230307105723891.png" alt="image-20230307105723891" style="zoom:67%;" /><blockquote><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量<br>N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来<br>说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集<br>型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一<br>般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导<br>致资源浪费。</p></blockquote><ul><li><p>设置线程池目的：</p><p>空间换时间，浪费服务器的硬件资源，换取运行效率。</p><ol><li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li><li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中<br>获取，无需动态分配。</li><li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源</li></ol></li></ul><h4 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h4><p>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个<br>问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该<br>socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于<br>是就出现了两个线程同时操作一个 socket 的局面。<strong>一个socket连接在任一时刻都只被一个线程处理</strong>，可<br>以使用 epoll 的 EPOLLONESHOT 事件实现。<br>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异<br>常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事<br>件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思<br>考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个<br>socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进<br>而让其他工作线程有机会继续处理这个 socket。</p><h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。<br>有的应用层协议头部包含数据包类型字段，每种类型可以<strong>映射为逻辑单元的一种执行状态</strong>，服务器可以<br>根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE( Package _pack ) </span><br><span class="line">&#123;</span><br><span class="line">    PackageType _type = _pack.GetType();</span><br><span class="line">    <span class="keyword">switch</span>( _type )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            process_package_A( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            process_package_B( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。<br>状态之间的转移是需要状态机内部驱动，如下代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE() </span><br><span class="line">&#123;</span><br><span class="line">    State cur_State = type_A;</span><br><span class="line">        <span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">    &#123;</span><br><span class="line">        Package _pack = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span>( cur_State )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_package_state_A( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_package_state_B( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状<br>态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过<br>getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据<br>包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一<br>趟循环时，它将执行新的状态对应的逻辑。</li></ul><h4 id="服务器压力测试"><a href="#服务器压力测试" class="headerlink" title="服务器压力测试"></a>服务器压力测试</h4><p>Webbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发</p><ul><li>测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。</li><li>展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量。</li></ul><p>基本原理：Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的<br>结果通过pipe 告诉父进程，父进程做最终的统计结果。</p><ul><li>测试示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ./webbench -c <span class="number">1000</span>  -t  <span class="number">30</span>   http:<span class="comment">//192.168.31.128:18888/index.html</span></span><br><span class="line">权限不够重新make一下</span><br><span class="line">参数：</span><br><span class="line">    -c 表示客户端数</span><br><span class="line">    -t 表示时间</span><br></pre></td></tr></table></figure><h2 id="6-项目记录"><a href="#6-项目记录" class="headerlink" title="6. 项目记录"></a>6. 项目记录</h2><p>HTTP报文头</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读取到数据：GET / HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.31.128:10000</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,ar;q=0.8</span><br></pre></td></tr></table></figure><h3 id="1-面试题"><a href="#1-面试题" class="headerlink" title="1. 面试题"></a>1. 面试题</h3><ol><li><p>read读取完成的标志？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值<span class="number">1</span>，返回值<span class="number">-1</span>且errno=EAGAIN 或者EWOULDBLOCK</span><br><span class="line">    进行一些非阻塞(non-blocking)操作(对文件或socket)的时候续做read或者EWOULDBLOCK操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试</span><br><span class="line">    又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)</span><br></pre></td></tr></table></figure></li><li><p>epoll_wait得到的events中哪些是对方异常断开或者错误事件？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EPOLLRDHUP|EPOLLHUP|EPOLLERR</span><br><span class="line">    EPOLLRDHUP 对端关闭连接或者shutdown写入半连接</span><br><span class="line"> （程序里close()，shell下kill或ctr+c），触发EPOLLIN和EPOLLRDHUP</span><br><span class="line">表示对端关闭了写端，即半关闭状态，可以视为一种错误事件。当发生EPOLLRDHUP事件时，可以认为对端已经完成了写操作并关闭了连接，此时应该关闭套接字并且清理相关资源。在使用epoll时，通常可以将EPOLLRDHUP事件和EPOLLIN事件一起进行处理。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    EPOLLHUP 表示读写都关闭。本端调用shutdown(SHUT_RDWR),应该是本端（server端）出错才触发的。</span><br><span class="line">对应的连接被挂起，通常是对方关闭了连接</span><br><span class="line">通常情况下EPOLLHUP表示的是本端挂断，造成这种事件出现的原因有很多，其中一种便是出现错误，更加细致的应该是和RST联系在一起</span><br><span class="line">    </span><br><span class="line">    EPOLLERR      服务器这边出错,只有采取动作时，才能知道是否对方异常。</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//****************************  </span></span><br><span class="line">EPOLLHUP和EPOLLRDHUP都是表示连接异常断开的事件，但是它们的含义略有不同。</span><br><span class="line"></span><br><span class="line">EPOLLRDHUP则表示对端关闭了连接，即对端调用了close()函数。它只会在ET模式下才会触发。</span><br><span class="line">EPOLLHUP表示对端连接断开，也可能是其他错误事件，比如一个本地socket调用了shutdown之后，再往这个socket上写数据，会返回一个RST。这种情况下也会触发EPOLLHUP事件。</span><br><span class="line">在实际使用中，一般先判断EPOLLRDHUP，如果有则说明连接已经被对端关闭，如果没有再判断EPOLLHUP。</span><br><span class="line">    </span><br><span class="line">    -------------------------</span><br><span class="line">    对于 EPOLLERR和EPOLLHUP，不需要在epoll_event时针对fd作设置，一样也会触发</span><br><span class="line">    EPOLLERR和EPOLLHUP，是因为之前收到了对端close时发送的FIN 包，此时再给对端发送数据，对端会返回RST包</span><br><span class="line">    </span><br><span class="line">    对EPOLLRDHUP的处理应该放在EPOLLIN和EPOLLOUT前面，处理方式应该 是close掉相应的fd后，作其他应用层的清理动作</span><br></pre></td></tr></table></figure></li><li><p>修改，定时清理超时的请求：</p><ol><li>定时器类 和 请求数据类 ，定时器链表；</li><li>ALARM定时处理：管道写端交给sig，定期写入定时信号，读端交给epoll，如果socket是fd[0]且多EPOLLIN，说明定时到了，判断是是不是ALARM，如果是最后处理（因为清理的优先级最小），最后处理的话就是调用回调函数去删除那个数据对象，删除socket在epoll上的绑定。</li></ol></li></ol><h2 id="Ubuntu一些小操作"><a href="#Ubuntu一些小操作" class="headerlink" title="Ubuntu一些小操作"></a>Ubuntu一些小操作</h2><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><h3 id="1-VScode配置-SSH连接Ubuntu"><a href="#1-VScode配置-SSH连接Ubuntu" class="headerlink" title="1.VScode配置 SSH连接Ubuntu"></a>1.VScode配置 SSH连接Ubuntu</h3><ul><li><p>vscode扩展remote development下载</p></li><li><p>远程资源管理器 设置远程连接 ，默认配置文件修改为虚拟机IP地址 用户密码</p></li><li><p>生成宿主机SSH秘钥     ssh-keygen -t rsa 回车   生成位于C:\Users\klChen.ssh的私钥和公钥</p></li><li><p>生成虚拟机SSH秘钥    ssh-keygen -t rsa </p></li><li><p>配置秘钥<br>cd .ssh<br>创建文件，复制宿主机秘钥vim authorized_keys</p></li></ul><p>ctrl+L 清空终端屏</p><p>Ctrl+C中断了进程，返回到终端界面。</p><p>Ctrl+Z挂起了进程，返回到终端界面。</p><p>set nu在vim中设置行号</p><p>创建文件 touch 创建文件夹 mkdir</p><h4 id="文本文件上传"><a href="#文本文件上传" class="headerlink" title="文本文件上传"></a>文本文件上传</h4><p>​文本文件的换行符</p><p>Windows : \r\n</p><p>Linux : \n</p><p>可以在 Notepad ++ 里观察到此区别</p><p>视图 | 显示符号 | 显示行尾符</p><h4 id="修改格式"><a href="#修改格式" class="headerlink" title="修改格式"></a>修改格式</h4><p>换行符的转换：</p><p>编辑 | 文档格式转换 | 转换为 UNIX格式</p><p>注意：只有在编辑 SHELL 脚本时，才需要转换</p><p>其他格式的文件一般都不需要转换，如*.xml, *.java</p><p><strong>演示</strong>：Shell脚本的编辑 。。</p><ol><li><p>用 Notepad++打开编辑 mytest.sh</p></li><li><p>转成 Unix格式 \n</p></li><li><p>上传至Linux</p></li><li><p>chmod +x mytest.sh</p></li><li><p>运行 .&#x2F;mytest.sh</p></li></ol><h3 id="命令类"><a href="#命令类" class="headerlink" title="命令类"></a>命令类</h3><h5 id="1-归档"><a href="#1-归档" class="headerlink" title="1. 归档"></a>1. 归档</h5><p>tar , 即 tape archive 档案打包</p><p>创建档案包</p><p>tar  -cvf  example.tar  example</p><p>其中，</p><p>  c ,  表示 create 创建档案</p><p>  v , 表示 verbose 显示详情</p><p>  f ,  表示 file</p><p>也可以多个目录打包 tar -cvf xxx.tar file1 file2 file3 </p><p>还原档案包</p><p>tar  -xvf  example.tar</p><p>tar  -xvf  example.tar  -C  outdir</p><p>其中，-C 参数指定目标目录，默认解到当前目录下</p><h5 id="2-压缩解压"><a href="#2-压缩解压" class="headerlink" title="2. 压缩解压"></a>2. 压缩解压</h5><p>先前的tar格式并没有压缩，体积较大</p><p>并档并压缩</p><p>tar  -zcvf  example.tar.gz  example</p><p>解压缩</p><p>tar  -zxvf  example.tar.gz</p><p>tar  -zxvf  example.tar.gz  -C  outdir</p><p>通常我们所见的，都是 *.tar.gz 这种格式</p><h5 id="7z"><a href="#7z" class="headerlink" title="7z"></a>7z</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install p7zip-full</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">7z a -t7z -r filename.7z ./*</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">7z x filename.7z -r -o./* </span><br></pre></td></tr></table></figure><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>定义环境变量</p><p>export OUTDIR&#x3D;&#x2F;opt&#x2F;</p><p>显示环境变量</p><p>echo ${OUTDIR}</p><p>查看所有环境变量</p><p>printenv</p><h5 id="查看当前进程"><a href="#查看当前进程" class="headerlink" title="查看当前进程"></a>查看当前进程</h5><p>进程id：echo $$</p><p>终端设备：tty</p><p><img src="D:\MyTxt\typoraPhoto\image-20230227110412165.png" alt="image-20230227110412165"></p><h6 id="找函数"><a href="#找函数" class="headerlink" title="找函数"></a>找函数</h6><p>man 2 xxx</p><p>或者 man xxx +tab键</p><h5 id="查看网络相关信息的命令"><a href="#查看网络相关信息的命令" class="headerlink" title="查看网络相关信息的命令"></a>查看网络相关信息的命令</h5><p>netstat<br> 参数：-a 所有的socket<br>   -p 显示正在使用socket的程序的名称<br>   -n 直接使用IP地址，而不通过域名服务器</p><p> netstat -anp|grep xxxx<br>查看端口号占用信息</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><h4 id="利用Core文件查看异常的信息"><a href="#利用Core文件查看异常的信息" class="headerlink" title="利用Core文件查看异常的信息"></a>利用Core文件查看异常的信息</h4><ol><li>用ulimit -a查看Core文件允许产生的大小，一般是0；然后改为一定值 ulimit -c 1024</li><li>然后用-g调试编译.c文件</li><li>然后调试改文件，输入core-file core就能看到</li><li>这里系统版本不同，生成不出来Core文件</li></ol><h4 id="Linux下的时间设置"><a href="#Linux下的时间设置" class="headerlink" title="Linux下的时间设置"></a>Linux下的时间设置</h4><p>时钟时间 ＝ 阻塞时间 ＋ 就绪时间 ＋运行时间；</p><p>其中：运行时间&#x3D;用户CPU时间（用户的进程获得了CPU资源以后，在用户态执行的时间。）+系统CPU时间（用户进程获得了CPU资源以后，在内核态的执行时间。）；</p><ul><li>因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务</li></ul><h5 id="前后台进程"><a href="#前后台进程" class="headerlink" title="前后台进程"></a>前后台进程</h5><p>默认前台进程，阻塞</p><p>加上&amp;改为后台进程，改为非阻塞 ，但是注意要去查看，并且kill -9：<code>./sigprocmask&amp;</code></p><h5 id="段错误究竟是怎么发生的？段错误的复现为什么这么难？"><a href="#段错误究竟是怎么发生的？段错误的复现为什么这么难？" class="headerlink" title="段错误究竟是怎么发生的？段错误的复现为什么这么难？"></a>段错误究竟是怎么发生的？段错误的复现为什么这么难？</h5><p>段错误是个迷，有的人碰到过几次，有的人怎么也碰不到，这是由于神秘莫测的调度算法导致的。【潇潇_暮雨】小伙伴提出了，这是调用了不可重入的函数。《Linux&#x2F;UNIX系统编程手册》第21.1.2节 对可重入函数进行了详细的解释，有兴趣的可以去翻一下。</p><p>可重入函数的意思是：函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。通俗点讲，就是存在一个函数，A线程执行一半，B线程抢过CPU又来调用该函数，执行到1&#x2F;4倍A线程抢回执行权。在这样不断来回执行中，不出问题的，就是可重入函数。多线程中每个线程都有自己的堆栈，所以如果函数中只用到局部变量肯定是可重入的，没问题的。但是更新了全局变量或静态数据结构的函数可能是不可重入的。假设某线程正在为一个链表结构添加一个新的链表项，而另外一个线程也视图更新同一链表。由于中间涉及多个指针，一旦另一线程中断这些步骤并修改了相同指针，结果就会产生混乱。但是并不是一定会出现，一定是A线程刚好在修改指针，另外一线程又去修改才会出现。这就是为什么该问题复现难度较高的原因。</p><p>作者在文中指出，将静态数据结构用于内部记账的函数也是不可重入的。其中最明显的例子就是stdio函数库成员（printf()、scanf()等），它们会为缓冲区I&#x2F;O更新内部数据结构。所以，如果在捕捉信号处理函数中调用了printf()，而主程序又在调用printf()或其他stdio函数期间遭到了捕捉信号处理函数的中断，那么有时就会看到奇怪的输出，设置导致程序崩溃。虽然printf()不是异步信号安全函数，但却频频出现在各种示例中，是因为在展示对捕捉信号处理函数的调用，以及显示函数中相关变量的内容时，printf()都不失为一种简单而又便捷的方式。真正的应用程序应当避免使用该类函数。</p><p>printf函数会使用到一块缓冲区，这块缓冲区是使用malloc或类似函数分配的一块静态内存。所以它是不可重入函数</p><h4 id="虚拟地址空间层次划分"><a href="#虚拟地址空间层次划分" class="headerlink" title="虚拟地址空间层次划分"></a>虚拟地址空间层次划分</h4><p>从操作系统层级上看，虚拟地址空间主要分为两个部分内核区和用户区。</p><p><strong>一、内核区</strong></p><ol><li>内核空间为内核保留，<strong>不允许应用程序读写该区域的内容</strong>或直接调用内核代码定义的函数</li><li><strong>内核总是驻留在内存中</strong>，是操作系统的一部分。</li><li>系统中<strong>所有进程</strong>对应的<strong>虚拟地址空间的内核区</strong>都会<strong>映射到同一块物理内存</strong>上（<strong>系统内核只有一个</strong>）</li></ol><p><strong>二、用户区</strong></p><p><strong>每个进程的虚拟地址空间都是从 0 地址开始的</strong>，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G（以 32 位系统的虚拟地址空间为例），里边分为多个区块。</p><p>各分区由低地址到高地址依次是：</p><ol><li><strong>保留区:</strong> 位于虚拟地址空间的最底部，<strong>未赋予物理地址</strong>。任何对它的引用都是非法的，程序中的<strong>空指针（NULL）指向的就是这块内存地址</strong>。</li><li><strong>.text段: 代码段也称正文段或文本段</strong>，通常用于存放程序的<strong>执行代码</strong> (即 CPU 执行的<strong>机器指令，二进制</strong>)，代码段一般情况下是<strong>只读</strong>的，这是对执行代码的一种保护机制。</li><li><strong>.data段</strong>: <strong>数据段</strong>通常用于存放程序中<strong>已初始化且初值不为 0 的全局变量和静态变量</strong>。数据段属于**静态内存分配 (静态存储区)**，可读可写。</li><li><strong>.bss段: 未初始化以及初始为 0 的全局变量和静态变量</strong>，操作系统会将这些<strong>未初始化变量初始化为 0</strong>；</li><li><strong>堆(heap)<strong>：用于存放进程运行时</strong>动态分配的内存</strong>。<ul><li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li><li>堆向高地址扩展 (即 “向上生长”)，是<strong>不连续</strong>的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而<strong>链表从低地址向高地址遍历</strong>。</li></ul></li><li><strong>内存映射区(mmap)：**作为内存映射区**加载磁盘文件**，或者</strong>加载程序运作过程中需要调用的动态库**。</li><li><strong>栈(stack):</strong> 存储<strong>函数内部声明的非静态局部变量，函数参数，函数返回地址等信息</strong>，栈内存由<strong>编译器自动分配释放</strong>。<strong>栈</strong>和堆相反地址 <strong>“向下生长”</strong>，分配的<strong>内存是连续</strong>的。</li><li><strong>命令行参数</strong>：存储进程执行的时候<strong>传递给 main() 函数的参数，argc，argv []</strong></li><li><strong>环境变量</strong>: 存储和进程相关的环境变量，比如：<strong>工作路径</strong>，<strong>进程所有者</strong>等信息</li></ol><h2 id="C函数记录"><a href="#C函数记录" class="headerlink" title="C函数记录"></a>C函数记录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>；</span><br><span class="line"></span><br><span class="line">第一个参数：（buffer）</span><br><span class="line">这个参数就是接收字符串的字符数组。其大小必须要大于所接收的字符串的大小，否则的话会有空间不够从而导致内存溢出的风险。（这里比较大小时还要考虑到字符串最后的 ‘\0’）</span><br><span class="line"></span><br><span class="line">第二个参数：（format）</span><br><span class="line">这个参数就是要传的字符串了。</span><br><span class="line"></span><br><span class="line">其余参数：</span><br><span class="line">剩下的参数其实算是对第二个参数format的补充，可有可无，视情况而定</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">perror(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">作用：调用系统或者库函数有错的时候，发出错误信息</span><br></pre></td></tr></table></figure><pre><code> sizeof 和strlen 有本质上的区别。sizeof 是C 语言的一种单目运算符，如++、–等，并不是函数，sizeof 的优先级为2 级，比/、% 等3 级运算符优先级高，sizeof以字节的形式给出操作数的存储空间的大小。而 strlen 是一个函数，是由 C 语言的标准库提供的。strlen 计算的 是字符串的长度。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format [, argument] … )</span>;</span><br><span class="line">    跟 <span class="built_in">printf</span> 在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出;</span><br><span class="line"><span class="number">1.</span> 可以用<span class="built_in">sprintf</span>来将其他类型转换字符串类想</span><br><span class="line"><span class="number">2.</span> 可以生成字符串，拼接 格式等</span><br><span class="line">     <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello,%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>输入一串格式化的字符串，经过处理后可以将 %s %f %d等占位符替换为对应的数据；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">… 表示函数的参数个数可变，典型的如<span class="built_in">printf</span>()</span><br><span class="line"></span><br><span class="line">第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>  <span class="comment">// 重载了func函数，不重载也行</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">char</span> *res = <span class="literal">NULL</span>; </span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    res = func(format, ap);  </span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> res ;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>        <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;函数与<span class="built_in">sprintf</span>()函数对应，只是在函数调用时，把上面的...对应的一个个变量用va_list调用所替代。在函数调用前ap要通过va_start()宏来动态获取。</span><br><span class="line"><span class="number">2.</span> 结构体va_list用来存参数列表，</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>  //<span class="title">I</span>/<span class="title">O</span> <span class="title">vector</span>，与<span class="title">readv</span>和<span class="title">wirtev</span>操作相关的结构体</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/uio.h&gt;</span><br><span class="line"><span class="comment">/* Structure for scatter/gather I/O. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">     <span class="type">void</span> *iov_base; <span class="comment">/* Pointer to data. */</span></span><br><span class="line">     <span class="type">size_t</span> iov_len; <span class="comment">/* Length of data. */</span></span><br><span class="line">&#125;;</span><br><span class="line">成员iov_base指向一个缓冲区，这个缓冲区是存放readv所接收的数据或是writev将要发送的数据。</span><br><span class="line">成员iov_len确定了接收的最大长度以及实际写入的长度。   </span><br><span class="line">readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）</span><br><span class="line">    </span><br><span class="line">HTTP响应的时候配合writev(),写入响应头和体</span><br><span class="line">    writev(m_sockfd,m_iv,m_iv_count);</span><br></pre></td></tr></table></figure><h2 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h2><p>IPv4 192.168.31.128</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><ul><li><p>配置文件名以 *.cnf 为后缀,参考 windows下mysql的配置 : my.ini</p></li><li><p>配置文件都在&#x2F;etc下，在 &#x2F;etc&#x2F;init.d 下，是各个系统服务的启动脚本2 软件包搜索</p></li></ul><p>apt list | grep ssh</p><p>apt search ssh –names-only</p><p>3 删除软件包</p><p>apt remove xxx 卸载软件包</p><p>apt purge xxx 卸载软件包、并清除配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。此外，也可以直接在文件中写入要写的内容。也可以用于脚本编程时显示某一个变量的值，或者直接输出指定的字符串。</span><br><span class="line">1. -n : 表示输出之后不换行，直接显示新行的提示符</span><br><span class="line">2. -e : 表示对于转义字符按对应的方式进行处理。</span><br><span class="line">3. echo “想要的内容”&gt; 文件名：</span><br><span class="line">将想要的内容覆盖到对应的文件当中去，文件当中之前的内容不复存在了，实际上是修改了原文件的内容。</span><br><span class="line">4. echo “想要的内容”&gt;&gt; 文件名</span><br><span class="line">将想要的内容追加到文件后，对文件之前的内容不修改，只进行增添，也叫追加重定</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">内存拷贝</span><br></pre></td></tr></table></figure><h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POLL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//定义线程池模板类，方便复用</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    threadpool(<span class="type">int</span> thread_number=<span class="number">8</span>,<span class="type">int</span> max_requests=<span class="number">10000</span>);</span><br><span class="line">    ~threadpool();</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">append</span><span class="params">(T* request)</span>;    <span class="comment">//添加到请求队列中</span></span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="comment">//只能是静态函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="title function_">work</span><span class="params">(<span class="type">void</span>*arg)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_thread_number; <span class="comment">//线程数量</span></span><br><span class="line">    <span class="type">pthread_t</span>* m_threads;<span class="comment">//线程数组</span></span><br><span class="line">    <span class="type">int</span> m_max_requests;<span class="comment">//允许等待的最大量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T*&gt; m_workqueue; <span class="comment">//请求队列</span></span><br><span class="line">    locker m_queuelocker;<span class="comment">//互斥锁</span></span><br><span class="line">    sem m_queuestat;<span class="comment">// 信号量用来判断是否有任务需要处理</span></span><br><span class="line">    <span class="type">bool</span> m_stop;<span class="comment">//是否结束线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">threadpool&lt;T&gt;::threadpool(<span class="type">int</span> thread_number,<span class="type">int</span> max_requests):</span><br><span class="line">            m_thread_number(thread_number),m_max_requests(m_max_requests),</span><br><span class="line">            m_stop(<span class="literal">false</span>),m_threads(<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>))&#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">        m_threads = new <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">        <span class="keyword">if</span>(!m_threads)&#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建thread_number个线程，线程分离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=thread_number;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create the %d thread\n&quot;</span>,i);</span><br><span class="line">            <span class="comment">//“值得一提的是，在c++程序中使用pthread_creat时，该函数的第3个参数必须指向一个静态函数”</span></span><br><span class="line">            <span class="comment">//第四个参数 -向work传参this 用于调用非静态成员</span></span><br><span class="line">            <span class="keyword">if</span>(pthread_create(m_threads+i,<span class="literal">NULL</span>,work,this) != <span class="number">0</span>)&#123;</span><br><span class="line">                delete[] m_threads;</span><br><span class="line">                throw <span class="built_in">std</span>::exception();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pthread_detach(m_threads[i]) != <span class="number">0</span>)&#123;</span><br><span class="line">                delete[] m_threads;</span><br><span class="line">                throw <span class="built_in">std</span>::exception();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~threadpool()&#123;</span><br><span class="line">    delete[] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::append(T* request)&#123;</span><br><span class="line">    m_queuelocker.lock();</span><br><span class="line">    <span class="keyword">if</span>(m_workqueue.size() &gt; m_max_requests)&#123;</span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.push_back(request);</span><br><span class="line">    m_queuelocker.unlock();</span><br><span class="line">    m_queuestat.post();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt;T&gt;::work(<span class="type">void</span>*arg)&#123;</span><br><span class="line">    <span class="comment">//静态函数不能访问类内非静态成员,可以传入this指针</span></span><br><span class="line">    threadpool *pool = (threadpool*) arg;</span><br><span class="line">    pool-&gt;run();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::run()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!m_stop)&#123;</span><br><span class="line">        <span class="comment">//P</span></span><br><span class="line">        m_queuestat.wait();</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        m_queuelocker.lock();</span><br><span class="line">        <span class="comment">//其实这里wait会阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(m_workqueue.empty())&#123;</span><br><span class="line">            m_queuelocker.unlock();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* request = m_workqueue.front();</span><br><span class="line">        m_workqueue.pop_front();</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!request)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FD 65535 <span class="comment">//最大文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS_NUMBER 10000 <span class="comment">//监听的最大的事件数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件描述符添加到epoll中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">bool</span> one_shoot)</span>;</span><br><span class="line"><span class="comment">//将文件描述符从epoll中删除</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">removefd</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">//修改文件描述符</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">modfd</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> ev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加信号捕捉 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addsig</span><span class="params">(<span class="type">int</span> sig,<span class="type">void</span>(handler)(<span class="type">int</span>))</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">//设置回调函数</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">//注册信号捕捉</span></span><br><span class="line">    sigaction(sig,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取端口号</span></span><br><span class="line">    <span class="type">int</span> port =atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对SIGPIE信号进行处理</span></span><br><span class="line">    addsig(SIGPIPE,SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化线程池</span></span><br><span class="line">    threadpool&lt;http_conn&gt; *pool = <span class="literal">NULL</span>;</span><br><span class="line">    try&#123;</span><br><span class="line">        pool = new threadpool&lt;http_conn&gt;;</span><br><span class="line">    &#125;catch(...)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个数组，用于保存所有的客户端信息</span></span><br><span class="line">    http_conn *users = new http_conn[MAX_FD];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成监听的socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;reuse,<span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    bind(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    listen(listenfd,<span class="number">5</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll对象,事件数组，之后添加</span></span><br><span class="line">    epoll_event events[MAX_EVENTS_NUMBER];</span><br><span class="line">    <span class="type">int</span> epollfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听文件描述符添加到epoll实例当中</span></span><br><span class="line">    addfd(epollfd,listenfd,<span class="literal">false</span>);</span><br><span class="line">    http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epollfd,events,MAX_EVENTS_NUMBER,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>((num &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历事件数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sockfd == listenfd)&#123;</span><br><span class="line">                <span class="comment">//有客户端连接进来</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;new client\n&quot;</span>);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> client_addlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;client_address,&amp;client_addlen);</span><br><span class="line">                <span class="keyword">if</span>(connfd == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;error is: %d\n&quot;</span>,errno);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(http_conn::m_user_count &gt;=MAX_FD)&#123;</span><br><span class="line">                    <span class="comment">//目前连接数满了</span></span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将新的客户端初始化，放到数组中</span></span><br><span class="line">                users[connfd].init(connfd,client_address); </span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; (EPOLLRDHUP|EPOLLHUP|EPOLLERR))&#123;</span><br><span class="line">                <span class="comment">//对方异常断开或者错误等事件</span></span><br><span class="line">                users[sockfd].close_conn();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;EPOLLRDHUP|EPOLLHUP|EPOLLERR while epoll\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">                <span class="comment">//读事件发生</span></span><br><span class="line">                <span class="keyword">if</span>(users[sockfd].read())&#123;</span><br><span class="line">                    <span class="comment">//一次性把数据读完</span></span><br><span class="line">                    pool-&gt;append(users+sockfd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read ok\n&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    users[sockfd].close_conn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!users[sockfd].write())&#123;</span><br><span class="line">                    <span class="comment">//把respond写入客户端端fd后，把该客户端fd从epoll中删除</span></span><br><span class="line">                    users[sockfd].close_conn();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write response ok\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-----------------------\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(epollfd);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    delete[] users;</span><br><span class="line">    delete pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用#ifndef可以避免以下错误:如果在.h文件中定义了全局变量,一个C文件包含了.h文件多次,如果不加#ifndef宏定义,会出现变量重复定义的错误;如果加了#ifndef则不会出现这种错误</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">//线程同步封装类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    locker()&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_mutex_init(&amp;m_mutex,<span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~locker()&#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_mutex_t</span>&amp; <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_mutex;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    cond()&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_cond_init(&amp;m_cond,<span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~cond()&#123;</span><br><span class="line">        pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">wait</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_wait(&amp;m_cond,mutex)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">timewait</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex,<span class="keyword">struct</span> timespec t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_timedwait(&amp;m_cond,mutex,&amp;t)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_signal(&amp;m_cond)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">broadcast</span><span class="params">(<span class="type">pthread_mutex_t</span> mutex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_broadcast(&amp;m_cond)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    sem()=<span class="keyword">default</span>;</span><br><span class="line">    sem(<span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sem_init(&amp;m_sem,<span class="number">0</span>,num) != <span class="number">0</span>)&#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~sem()&#123;</span><br><span class="line">        sem_destroy(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁P</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">wait</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sem_wait(&amp;m_sem)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减锁V</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">post</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sem_post(&amp;m_sem)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http_conn</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_epollfd;    <span class="comment">//所有socket事件都被注册到同一个epollfd上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_user_count; <span class="comment">//统计用户的数量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FILENAME_LEN = <span class="number">200</span>;         <span class="comment">//文件名的最大长度</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;    <span class="comment">//读缓冲区的大小</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WRITE_BUFFER_SIZE =<span class="number">1024</span>;    <span class="comment">//写缓冲区大小 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP请求方法，这里只支持GET</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">METHOD</span> &#123;</span>GET = <span class="number">0</span>, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        解析客户端请求时，主状态机的状态</span></span><br><span class="line"><span class="comment">        CHECK_STATE_REQUESTLINE:当前正在分析请求行</span></span><br><span class="line"><span class="comment">        CHECK_STATE_HEADER:当前正在分析头部字段</span></span><br><span class="line"><span class="comment">        CHECK_STATE_CONTENT:当前正在解析请求体</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        服务器处理HTTP请求的可能结果，报文解析的结果</span></span><br><span class="line"><span class="comment">        NO_REQUEST          :   请求不完整，需要继续读取客户数据</span></span><br><span class="line"><span class="comment">        GET_REQUEST         :   表示获得了一个完成的客户请求</span></span><br><span class="line"><span class="comment">        BAD_REQUEST         :   表示客户请求语法错误</span></span><br><span class="line"><span class="comment">        NO_RESOURCE         :   表示服务器没有资源</span></span><br><span class="line"><span class="comment">        FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限</span></span><br><span class="line"><span class="comment">        FILE_REQUEST        :   文件请求,获取文件成功</span></span><br><span class="line"><span class="comment">        INTERNAL_ERROR      :   表示服务器内部错误</span></span><br><span class="line"><span class="comment">        CLOSED_CONNECTION   :   表示客户端已经关闭连接了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从状态机的三种可能状态，即行的读取状态，分别表示</span></span><br><span class="line">    <span class="comment">// 1.读取到一个完整的行 2.行出错 3.行数据尚且不完整</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_OPEN &#125;;</span><br><span class="line"></span><br><span class="line">    http_conn()&#123;&#125;</span><br><span class="line">    ~http_conn()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> sockaddr_in &amp;add)</span>;   <span class="comment">//初始化新收到的客户端的连接</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">close_conn</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">read</span><span class="params">()</span>;    <span class="comment">//非阻塞的读</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">write</span><span class="params">()</span>;   <span class="comment">//非阻塞的写</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">process</span><span class="params">()</span>;     <span class="comment">//处理用户请求</span></span><br><span class="line">  </span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;    <span class="comment">//初始化连接其余的数据</span></span><br><span class="line">    HTTP_CODE <span class="title function_">process_read</span><span class="params">()</span>;                  <span class="comment">//解析HTTP请求</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">process_write</span><span class="params">(HTTP_CODE ret)</span>;         <span class="comment">//写入HTTP响应</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这组函数被process_read调用以分析HTTP请求</span></span><br><span class="line">    HTTP_CODE <span class="title function_">parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span>;       <span class="comment">//解析HTTP请求首行</span></span><br><span class="line">    HTTP_CODE <span class="title function_">parse_headers</span><span class="params">(<span class="type">char</span> *text)</span>;            <span class="comment">//解析HTTP头部</span></span><br><span class="line">    HTTP_CODE <span class="title function_">parse_content</span><span class="params">(<span class="type">char</span> *text)</span>;            <span class="comment">//解析HTTP内容</span></span><br><span class="line">    LINE_STATUS <span class="title function_">parse_line</span><span class="params">()</span>;                       <span class="comment">//解析行  </span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">char</span>* <span class="title function_">get_line</span><span class="params">()</span> &#123;<span class="keyword">return</span> m_read_buf + m_start_line;&#125;</span><br><span class="line">    HTTP_CODE <span class="title function_">do_request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这组函数被process_read调用以填充HTTP应答</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">unmap</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format,...)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* content,...)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_content_type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_status_line</span><span class="params">(<span class="type">int</span> status,<span class="type">const</span> <span class="type">char</span>*title)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_headers</span><span class="params">(<span class="type">int</span> content_length)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_content_length</span><span class="params">(<span class="type">int</span> content_length)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_linger</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">add_blank_line</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_sockfd;   <span class="comment">//该HTTP连接的socket</span></span><br><span class="line">    sockaddr_in m_address;  <span class="comment">//通信的socket地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> m_read_buf[READ_BUFFER_SIZE];      <span class="comment">//读缓冲区</span></span><br><span class="line">    <span class="type">int</span> m_read_idx;                         <span class="comment">//标识读缓冲区中已经写入的数据的最后一个字节的下一个</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> m_real_file[FILENAME_LEN];         <span class="comment">// 客户请求的目标文件的完整路径，其内容等于 doc_root + m_url, doc_root是网站根目录</span></span><br><span class="line">    <span class="type">int</span> m_check_index;                      <span class="comment">//当前正在分析的字符在缓冲区的位置</span></span><br><span class="line">    <span class="type">int</span> m_start_line;                       <span class="comment">//当前正在解析的行的起始位置  </span></span><br><span class="line">    <span class="type">char</span> *m_url;                            <span class="comment">//目标文件名</span></span><br><span class="line">    <span class="type">char</span> *m_version;                        <span class="comment">//协议版本，只支持HTTP1.1  </span></span><br><span class="line">    <span class="type">char</span> *m_host;                            <span class="comment">//主机名</span></span><br><span class="line">    <span class="type">bool</span> m_linger;                          <span class="comment">//HTTP是否保持连接 keep alive</span></span><br><span class="line">    <span class="type">int</span> m_content_length;                   <span class="comment">//HTTP请求的消息总长度</span></span><br><span class="line"></span><br><span class="line">    METHOD m_method;                         <span class="comment">//请求方法</span></span><br><span class="line">    CHECK_STATE m_check_state;               <span class="comment">//主状态机当前所处的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> m_write_buf[WRITE_BUFFER_SIZE];      <span class="comment">//写缓冲区</span></span><br><span class="line">    <span class="type">int</span> m_write_idx;                          <span class="comment">//写缓冲区的待处理字节</span></span><br><span class="line">    <span class="type">char</span>* m_file_address;                     <span class="comment">//客户请求的目标地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">m_file_stat</span>;</span>                  <span class="comment">//目标文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">m_iv</span>[2];</span>                      <span class="comment">//采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示被写内存块的数量。 </span></span><br><span class="line">    <span class="type">int</span> m_iv_count;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes_to_send;                      <span class="comment">//将要发送的数据的字节数</span></span><br><span class="line">    <span class="type">int</span> bytes_have_send;                    <span class="comment">//已经发送的字节数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HTTP响应的一些状态信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_403_form = <span class="string">&quot;You do not have permission to get file from this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* error_500_form = <span class="string">&quot;There was an unusual problem serving the requested file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站的根目录</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* doc_root = <span class="string">&quot;/home/klchen/WinToUbuntu/WebServer/resources&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内静态变量初始化</span></span><br><span class="line"><span class="type">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置fd非阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span>&#123;</span><br><span class="line">    <span class="type">int</span> old_flag = fcntl(fd,F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_flag = old_flag | O_NONBLOCK;</span><br><span class="line">    fcntl(fd,F_SETFL,new_flag);</span><br><span class="line">    <span class="keyword">return</span> new_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要监听的文件描述符添加到epoll中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">bool</span> one_shoot)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="comment">//event.events = EPOLLIN ||EPOLLRDHUP;</span></span><br><span class="line">    event.events = EPOLLIN |EPOLLRDHUP;</span><br><span class="line">    <span class="comment">//设置一个Socket连接同时只能触发一次，防止读取的时候更新又开一个线程处理</span></span><br><span class="line">    <span class="keyword">if</span>(one_shoot)&#123;</span><br><span class="line">        event.events|=EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置文件描述符非阻塞</span></span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将监听文件描述符从epoll中删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removefd</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd)</span>&#123;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,<span class="number">0</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改文件描述符 ，修改socket上的ONESHOOT事件，以确保下一次可读的时候，EPOLL时间只触发一次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modfd</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> ev)</span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="comment">//为什么要添加 EPOLLET|EPOLLRDHUP？？？</span></span><br><span class="line">    event.events = ev|EPOLLONESHOT|EPOLLET|EPOLLRDHUP;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化连接</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;add)</span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口复用</span></span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;reuse,<span class="keyword">sizeof</span>(reuse));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新的客户端fd添加到epoll对象中</span></span><br><span class="line">    addfd(m_epollfd,sockfd,<span class="literal">true</span>);</span><br><span class="line">    m_user_count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他部分的初始化</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他部分的初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">http_conn::init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;    <span class="comment">//初始化状态为解析请求首行</span></span><br><span class="line">    m_check_index = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_url = <span class="number">0</span>;    </span><br><span class="line">    m_version = <span class="number">0</span>;     </span><br><span class="line">    m_method = GET;</span><br><span class="line">    bzero(m_read_buf,READ_BUFFER_SIZE);</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_linger = <span class="literal">false</span>;</span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bzero(m_read_buf,READ_BUFFER_SIZE);</span><br><span class="line">    bzero(m_write_buf,WRITE_BUFFER_SIZE);</span><br><span class="line">    bzero(m_read_buf,FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">http_conn::close_conn</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_epollfd != <span class="number">-1</span>)&#123;</span><br><span class="line">        removefd(m_epollfd,m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;<span class="comment">//关闭一个连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::read</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;一次性读完数据\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(m_read_idx &gt;= READ_BUFFER_SIZE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//第四个参数设置0，表示阻塞读取</span></span><br><span class="line">        bytes_read = recv(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(bytes_read == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((errno == EAGAIN)||(errno ==EWOULDBLOCK))&#123;</span><br><span class="line">                <span class="comment">//非阻塞情况下，没数据可读了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes_read == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//对方关闭</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes_read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            m_read_idx += bytes_read;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,m_read_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，</span></span><br><span class="line"><span class="comment"> 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其</span></span><br><span class="line"><span class="comment"> 映射到内存地址m_file_address处，并告诉调用者获取文件成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">http_conn::HTTP_CODE <span class="title function_">http_conn::do_request</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//或得路径+文件名</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file,doc_root);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file+len,m_url,FILENAME_LEN<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件权限</span></span><br><span class="line">    <span class="keyword">if</span>(stat(m_real_file,&amp;m_file_stat) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  NO_RESOURCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(m_file_stat.st_mode &amp; S_IROTH))&#123;</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是目录</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(m_file_stat.st_mode))&#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只读方式打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(m_real_file,O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建内存映射，写入</span></span><br><span class="line">    m_file_address = (<span class="type">char</span> *)mmap(<span class="literal">NULL</span>,m_file_stat.st_size,PROT_READ,MAP_PRIVATE,fd,<span class="number">0</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主状态机 解析请求</span></span><br><span class="line">http_conn::HTTP_CODE <span class="title function_">http_conn::process_read</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;</span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *text = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(((m_check_state == CHECK_STATE_CONTENT) &amp;&amp;(line_status == LINE_OK))</span><br><span class="line">        ||((line_status = parse_line()) == LINE_OK))&#123;</span><br><span class="line">    <span class="comment">//解析到了一行完整的数据，或者解析到了一行完整的请求体</span></span><br><span class="line">        <span class="comment">//获取一行数据</span></span><br><span class="line">        text = get_line();</span><br><span class="line">        m_start_line = m_check_index;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got 1 http line: %s\n&quot;</span>,text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (m_check_state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:&#123;</span><br><span class="line">                ret = parse_request_line(text);</span><br><span class="line">                <span class="keyword">if</span>(ret == BAD_REQUEST)&#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_HEADER:&#123;</span><br><span class="line">                ret = parse_headers(text);</span><br><span class="line">                <span class="keyword">if</span>(ret == BAD_REQUEST)&#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == GET_REQUEST)&#123;</span><br><span class="line">                    <span class="comment">//头部解析完了，得到一个完整的客户请求</span></span><br><span class="line">                    <span class="keyword">return</span> do_request();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_CONTENT:&#123;</span><br><span class="line">                ret = parse_content(text);</span><br><span class="line">                <span class="keyword">if</span>(ret == GET_REQUEST)&#123;</span><br><span class="line">                    <span class="keyword">return</span> do_request();</span><br><span class="line">                &#125;</span><br><span class="line">                line_status = LINE_OPEN;            </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析HTTP请求行，获得请求方法，目标URL，HTTP版本</span></span><br><span class="line">http_conn::HTTP_CODE <span class="title function_">http_conn::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span></span><br><span class="line">&#123;   <span class="comment">//读取到数据：GET /index.html HTTP/1.1</span></span><br><span class="line">        <span class="comment">//strpbrk是在源字符串（s1）中找出最先含有搜索字符串（s2）中任一字符的位置并返回，若找不到则返回空指针</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text,<span class="string">&quot; \t&quot;</span>);    <span class="comment">//text中空格和\t哪个先得到</span></span><br><span class="line">    <span class="keyword">if</span>(!m_url)&#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//strcasecmp用来比较参数s1和s2字符串前n个字符，比较时会自动忽略大小写的差异,strncasecmp有n指定比较最长位置    </span></span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">///index.html HTTP/1.1</span></span><br><span class="line">    <span class="type">char</span> *method = text;<span class="comment">//GET /index.html HTTP/1.1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(method,<span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        m_method = GET;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!m_version)&#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//HTTP/1.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(m_version,<span class="string">&quot;HTTP/1.1&quot;</span>)!= <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//http://192.168.31.128:10000/index.html</span></span><br><span class="line">    <span class="keyword">if</span>(strncasecmp(m_url,<span class="string">&quot;http://&quot;</span>,<span class="number">7</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        m_url+=<span class="number">7</span>;<span class="comment">// 192.168.31.128:10000/index.html</span></span><br><span class="line">        m_url=<span class="built_in">strchr</span>(m_url,<span class="string">&#x27;/&#x27;</span>); <span class="comment">// /index.html</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m_url || (m_url[<span class="number">0</span>] !=<span class="string">&#x27;/&#x27;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_check_state = CHECK_STATE_HEADER; <span class="comment">//主状态机检查状态变为请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http_conn::HTTP_CODE <span class="title function_">http_conn::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遇到空行，表示头部字段解析完成</span></span><br><span class="line">    <span class="keyword">if</span>(text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//如果HTTP请求有消息体，还需要读取m_content_length字节的消息体</span></span><br><span class="line">        <span class="comment">//状态机转移到CHECK_STATE_CONTENT状态</span></span><br><span class="line">        <span class="keyword">if</span>(m_content_length != <span class="number">0</span>)&#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，说明已经得到完整的HTTP请求,继续获取请求</span></span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strncasecmp(text,<span class="string">&quot;Connection:&quot;</span>,<span class="number">11</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//处理Connection:头部字段 Connection: keep-alive</span></span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>( strcasecmp(text,<span class="string">&quot;keep-alive&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Content-Length头部字段</span></span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        m_content_length = atol(text);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Host头部字段</span></span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;oop! unknow header %s\n&quot;</span>, text );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本项目没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了</span></span><br><span class="line">http_conn::HTTP_CODE <span class="title function_">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_read_idx &gt;=(m_content_length + m_check_index))&#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HTTP_CODE();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次状态机，解析行</span></span><br><span class="line">http_conn::LINE_STATUS <span class="title function_">http_conn::parse_line</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(;m_check_index &lt; m_read_idx;++m_check_index)&#123;</span><br><span class="line">        temp = m_read_buf[m_check_index];</span><br><span class="line">        <span class="comment">//考虑Linux的换行符是\r\n</span></span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//读到换行符的清空</span></span><br><span class="line">            <span class="keyword">if</span>((m_check_index + <span class="number">1</span>)== m_read_idx)&#123;</span><br><span class="line">                <span class="comment">//到缓存最后了</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m_read_buf[m_check_index+<span class="number">1</span>]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//完整解析一行了</span></span><br><span class="line">                m_read_buf[m_check_index++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_check_index++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//读了一半换行符</span></span><br><span class="line">            <span class="keyword">if</span>((m_check_index &gt; <span class="number">1</span>) &amp;&amp; (m_read_buf[m_check_index <span class="number">-1</span>] == <span class="string">&#x27;\r&#x27;</span>))&#123;</span><br><span class="line">                m_read_buf[m_check_index <span class="number">-1</span>] =<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_check_index++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LINE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向缓冲区写入待发送的数据</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(m_write_idx &gt;= WRITE_BUFFER_SIZE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_list arg_list;</span><br><span class="line">    va_start(arg_list,format);</span><br><span class="line">    <span class="type">int</span> len = vsnprintf(m_write_buf+m_write_idx,WRITE_BUFFER_SIZE<span class="number">-1</span>-m_write_idx,format,arg_list);</span><br><span class="line">    <span class="keyword">if</span>(len &gt;= (WRITE_BUFFER_SIZE<span class="number">-1</span>-m_write_idx))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_write_idx += len;</span><br><span class="line">    va_end(arg_list);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *content, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s&quot;</span>, content );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_content_type</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_status_line</span><span class="params">(<span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *title)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response(<span class="string">&quot;%s %d %s\r\n&quot;</span>,<span class="string">&quot;HTTP/1.1&quot;</span>,status,title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_headers</span><span class="params">(<span class="type">int</span> content_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        add_content_length(content_length) &amp;&amp;</span><br><span class="line">        add_content_type()&amp;&amp;</span><br><span class="line">        add_linger()&amp;&amp;</span><br><span class="line">        add_blank_line() </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_content_length</span><span class="params">(<span class="type">int</span> content_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response(<span class="string">&quot;Content-Length: %d\r\n&quot;</span>,content_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">http_conn::unmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_file_address)&#123;</span><br><span class="line">        munmap(m_file_address,m_file_stat.st_size);</span><br><span class="line">        m_file_address = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写HTTP响应</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::write</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//写完了</span></span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send  == <span class="number">0</span>)&#123;</span><br><span class="line">        modfd(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//分散写，有两个内存块，响应头+体</span></span><br><span class="line">        temp = writev(m_sockfd,m_iv,m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">             <span class="comment">// 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，</span></span><br><span class="line">            <span class="comment">// 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                modfd(m_epollfd,m_sockfd,EPOLLOUT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放内存映射</span></span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_have_send += temp;<span class="comment">//bytes_have_send不计较不同内存块的</span></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)&#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address+(bytes_have_send-m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len-temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有数据可以发了</span></span><br><span class="line">            unmap();</span><br><span class="line">            modfd(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(m_linger)&#123;</span><br><span class="line">                init();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_linger</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;Connection: %s\r\n&quot;</span>, ( m_linger == <span class="literal">true</span> ) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::add_blank_line</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据服务器处理HTTP请求的结果，决定返回给客户端的内容</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">switch</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERNAL_ERROR:</span><br><span class="line">        add_status_line(<span class="number">500</span>,error_500_title);</span><br><span class="line">        add_headers(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line">        <span class="keyword">if</span>( ! add_content(error_500_form))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BAD_REQUEST:</span><br><span class="line">        add_status_line( <span class="number">400</span>, error_400_title );</span><br><span class="line">        add_headers( <span class="built_in">strlen</span>( error_400_form ) );</span><br><span class="line">        <span class="keyword">if</span> ( ! add_content( error_400_form ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_RESOURCE:</span><br><span class="line">        add_status_line( <span class="number">404</span>, error_404_title );</span><br><span class="line">        add_headers( <span class="built_in">strlen</span>( error_404_form ) );</span><br><span class="line">        <span class="keyword">if</span> ( ! add_content( error_404_form ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FORBIDDEN_REQUEST:</span><br><span class="line">        add_status_line( <span class="number">403</span>, error_403_title );</span><br><span class="line">        add_headers(<span class="built_in">strlen</span>( error_403_form));</span><br><span class="line">        <span class="keyword">if</span> ( ! add_content( error_403_form ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FILE_REQUEST:</span><br><span class="line">        add_status_line(<span class="number">200</span>,ok_200_title);</span><br><span class="line">        add_headers(m_file_stat.st_size);</span><br><span class="line">        <span class="comment">//存储用于分写的内存位置</span></span><br><span class="line">        m_iv[<span class="number">0</span>].iov_base =  m_write_buf;</span><br><span class="line">        m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">        m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">        m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">        m_iv_count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_write_buf)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,m_write_buf); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;m_write_buf is empty!\n&quot;</span>); </span><br><span class="line">        &#125;          </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_have_send = m_write_idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_write_buf)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,m_write_buf); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m_write_buf is empty!\n&quot;</span>); </span><br><span class="line">    &#125;      </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有线程池中的工作线程调用，处理HTTP请求的入口函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">http_conn::process</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = process_read();</span><br><span class="line">    <span class="keyword">if</span>(read_ret == NO_REQUEST)&#123;</span><br><span class="line">        <span class="comment">//请求不完整，重新修改请求</span></span><br><span class="line">        modfd(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成响应      </span></span><br><span class="line">    <span class="type">bool</span> write_ret = process_write(read_ret);</span><br><span class="line">    <span class="keyword">if</span>(!write_ret)&#123;</span><br><span class="line">        close_conn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Generate response sucessfully\n&quot;</span>);</span><br><span class="line">    modfd(m_epollfd,m_sockfd,EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/project/2023/06/27/hello-world/"/>
      <url>/project/2023/06/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
